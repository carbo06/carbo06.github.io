<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/cat-32x32.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/cat-32x32.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/cat-16x16.png?v=5.1.4">


  <link rel="mask-icon" href="/images/cat-32x32.png?v=5.1.4" color="#222">





  <meta name="keywords" content="Boost," />










<meta name="description" content="What is boost spiritboost spirit is an object-oriented,recursive-descent parser and output generation library for C++.It allows you to write grammars and format descripting using a format similar to E">
<meta name="keywords" content="Boost">
<meta property="og:type" content="article">
<meta property="og:title" content="Boost Spirit">
<meta property="og:url" content="https://carbo06.github.io/2018/03/28/Boost-Spirit/index.html">
<meta property="og:site_name" content="Carbon&#39;s Blog">
<meta property="og:description" content="What is boost spiritboost spirit is an object-oriented,recursive-descent parser and output generation library for C++.It allows you to write grammars and format descripting using a format similar to E">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://www.boost.org/doc/libs/1_64_0/libs/spirit/doc/html/images/spiritstructure.png">
<meta property="og:image" content="http://www.boost.org/doc/libs/1_64_0/libs/spirit/doc/html/images/spiritkarmaflow.png">
<meta property="og:updated_time" content="2018-08-01T11:22:18.970Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Boost Spirit">
<meta name="twitter:description" content="What is boost spiritboost spirit is an object-oriented,recursive-descent parser and output generation library for C++.It allows you to write grammars and format descripting using a format similar to E">
<meta name="twitter:image" content="http://www.boost.org/doc/libs/1_64_0/libs/spirit/doc/html/images/spiritstructure.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"always","offset":12,"b2t":false,"scrollpercent":true,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://carbo06.github.io/2018/03/28/Boost-Spirit/"/>





  <title>Boost Spirit | Carbon's Blog</title><!-- hexo-inject:begin --><!-- hexo-inject:end -->
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Carbon's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">以梦为马 不负韶华</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://carbo06.github.io/2018/03/28/Boost-Spirit/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="carbo06@163.com">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Carbon's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Boost Spirit</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-28T15:53:11+08:00">
                2018-03-28
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于&#58;</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2018-08-01T19:22:18+08:00">
                2018-08-01
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Backend-Development/" itemprop="url" rel="index">
                    <span itemprop="name">Backend Development</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/03/28/Boost-Spirit/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count gitment-comments-count" data-xid="/2018/03/28/Boost-Spirit/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="What-is-boost-spirit"><a href="#What-is-boost-spirit" class="headerlink" title="What is boost spirit"></a>What is boost spirit</h1><p>boost spirit is an object-oriented,recursive-descent parser and output generation library for C++.It allows you to write grammars and format descripting using a format similar to Extended Backs Naur Form(EBNF) directly in C++.</p>
<p>The figure below shows the overall structure of Boost Spirit library.</p>
<p><img src="http://www.boost.org/doc/libs/1_64_0/libs/spirit/doc/html/images/spiritstructure.png" alt="image"></p>
<p>The three components Qi,Kama and Lex are designed to be used either stand alone or together. The general methodology is to use the token sequence generated by Lex as the input for a parser generated by Qi. On the opposite side of the equation,the hierarchical data structures generated by Qi are used for the output generators created using Kama.</p>
<p>The place of Spirit.Qi and Spirit.Kama in a data transformation flow of a typical application.</p>
<p><img src="http://www.boost.org/doc/libs/1_64_0/libs/spirit/doc/html/images/spiritkarmaflow.png" alt="image"></p>
<h2 id="Qi-Writing-Parsers"><a href="#Qi-Writing-Parsers" class="headerlink" title="Qi- Writing Parsers"></a>Qi- Writing Parsers</h2><p>Spirit.Qi is designed to be a practical parsing tool. Scanf ,boost::regex or boost::tokenizer do not scale well when we need to write more elaborate parsers.</p>
<h3 id="Examples"><a href="#Examples" class="headerlink" title="Examples"></a>Examples</h3><h4 id="Example-1-parsing-a-number"><a href="#Example-1-parsing-a-number" class="headerlink" title="Example #1 parsing a number"></a>Example #1 parsing a number</h4><p>Create a parser that will parse a floating-point number.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">double_</span><br></pre></td></tr></table></figure></p>
<h4 id="Example-2-parsing-2-numbers"><a href="#Example-2-parsing-2-numbers" class="headerlink" title="Example #2  parsing 2 numbers"></a>Example #2  parsing 2 numbers</h4><p>Create a parser that will accept a line consisting of 2 floating-point numbers.<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">double<span class="number">_</span> <span class="meta">&gt;&gt; </span>double<span class="number">_</span></span><br></pre></td></tr></table></figure></p>
<h4 id="Example-3-parsing-zero-or-more-numbers"><a href="#Example-3-parsing-zero-or-more-numbers" class="headerlink" title="Example #3 parsing zero or more numbers"></a>Example #3 parsing zero or more numbers</h4><p>Create a parser that will accept zero or more floating-point numbers.<br><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">*double_</span></span><br></pre></td></tr></table></figure></p>
<h4 id="Example-4-parsing-a-comma-delimited-list-of-numbers"><a href="#Example-4-parsing-a-comma-delimited-list-of-numbers" class="headerlink" title="Example #4 parsing a comma-delimited list of numbers"></a>Example #4 parsing a comma-delimited list of numbers</h4><p>This example will create a parser that accepts a comma-delimited list of numbers.<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">double<span class="number">_</span> <span class="meta">&gt;&gt; </span>*(char<span class="number">_</span>(<span class="string">','</span>) &gt;&gt; double<span class="number">_</span>)</span><br></pre></td></tr></table></figure></p>
<p>Notice char_(‘,’) is a literal charcter parser that can recognize the comma ‘,’.</p>
<h4 id="Let’s-Parse"><a href="#Let’s-Parse" class="headerlink" title="Let’s Parse"></a>Let’s Parse</h4><p>We are done with defining the parser.So the next step is invoking this parser to do its work.Here we will use <strong>phrase_parse</strong> function. One overload of this function accepts four arguments.</p>
<ol>
<li>iterator pointing to the start of the input.</li>
<li>iterator pointing to the end of the input.</li>
<li>parser object</li>
<li>another parser called the skip parser</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Iterator&gt;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">parse_numbers</span><span class="params">(Iterator first, Iterator last)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> qi::double_;</span><br><span class="line">    <span class="keyword">using</span> qi::phrase_parse;</span><br><span class="line">    <span class="keyword">using</span> ascii::space;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">bool</span> r = pharse_parse(</span><br><span class="line">        first,</span><br><span class="line">        last,</span><br><span class="line">        double_ &gt;&gt; *(<span class="string">','</span> &gt;&gt; double_),</span><br><span class="line">        space</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">if</span> (fisrt != last) </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Parser-Semantic-Actions"><a href="#Parser-Semantic-Actions" class="headerlink" title="Parser Semantic Actions"></a>Parser Semantic Actions</h3><p>The previous example was very simple.It only recognized data,but did noting with it.Now we want to extract information from what was parsed.<br>Semantic actions may be attached to any point in the grammar specification. These functions are C++ functions or function objects that are called whenever a part of the parser successfully recognizes a portion of the input.</p>
<h4 id="Example-of-Semantic-Actions"><a href="#Example-of-Semantic-Actions" class="headerlink" title="Example of Semantic Actions"></a>Example of Semantic Actions</h4><ul>
<li>using plain function pointer</li>
<li>using simple function object</li>
<li>using boost.bind with a plain function</li>
<li>using boost.bind with a member function</li>
<li>using boost.lambda</li>
</ul>
<p>Such as:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> client</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">namespace</span> qi = boost::qi;</span><br><span class="line">    <span class="comment">// A plain function</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; i)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// A member function</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">writer</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; i)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// A function object</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">print_action</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; i,qi::unset_type,qi::unset_type)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>All examples parse inputs of the form:<br><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"&#123;integer&#125;"</span></span><br></pre></td></tr></table></figure></p>
<p>These below shows the usages</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> boost::spirit::qi::int_;</span><br><span class="line"><span class="keyword">using</span> boost::spirit::qi::parse;</span><br><span class="line"><span class="keyword">using</span> client::print;</span><br><span class="line"><span class="keyword">using</span> client::writer;</span><br><span class="line"><span class="keyword">using</span> clinet::print_action;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* fisrt = <span class="string">"&#123;43&#125;"</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* last = first + <span class="built_in">std</span>::<span class="built_in">strlen</span>(first);</span><br><span class="line"></span><br><span class="line"><span class="comment">// example using plain function</span></span><br><span class="line">parse(first,last,<span class="string">'&#123;'</span>&gt;&gt;int_[&amp;print]&gt;&gt;<span class="string">'&#125;'</span>);</span><br><span class="line"><span class="comment">// example using simple function object</span></span><br><span class="line">parse(first,last,<span class="string">'&#123;'</span>&gt;&gt;int_[print_action()]&gt;&gt;<span class="string">'&#125;'</span>);</span><br><span class="line"><span class="comment">// example using boost bind with a plain function</span></span><br><span class="line">parse(fisrt,last,<span class="string">'&#123;'</span> &gt;&gt; int_[boost::bind(&amp;print,_1)]&gt;&gt;<span class="string">'&#125;'</span>);</span><br><span class="line"><span class="comment">// example using boost bind with a member function</span></span><br><span class="line">parse(first,last,<span class="string">'&#123;'</span>&gt;&gt; int_[boost::bind(&amp;writer::print,&amp;w,_1)]&gt;&gt;<span class="string">'&#125;'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// example using boost lambda</span></span><br><span class="line"><span class="keyword">namespace</span> lambda = boost::lambda;</span><br><span class="line"><span class="keyword">using</span> lambda::_1;</span><br><span class="line">parse(first,last,<span class="string">'&#123;'</span> &gt;&gt; int_[<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; _1 &lt;&lt; <span class="string">'\n'</span>] &gt;&gt; <span class="string">'&#125;'</span>);</span><br></pre></td></tr></table></figure>
<h4 id="Phoenix"><a href="#Phoenix" class="headerlink" title="Phoenix"></a>Phoenix</h4><p>Phoenix , a companion library bundled with Spirit. is sepcifically suited for binding semantic actions. It is like Boost.lambad on sterodis, with spiecial custom featrues that make it easy to  inergrate semantic action with Spirit.</p>
<h3 id="Complex-Our-first-complex-parser"><a href="#Complex-Our-first-complex-parser" class="headerlink" title="Complex - Our first complex parser"></a>Complex - Our first complex parser</h3><p>A parser that parses complex numbers.This time we are using Phoenix to do the semantic actions.<br>Here is a simple parser expression for complex numbers.<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'('</span> <span class="meta">&gt;&gt; </span>double<span class="number">_</span> &gt;&gt; -(<span class="string">','</span> &gt;&gt; double<span class="number">_</span>) &gt;&gt; <span class="string">')'</span> </span><br><span class="line"><span class="params">| double_</span></span><br></pre></td></tr></table></figure></p>
<p>This parser can parse complex numbers of the form:<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(123<span class="selector-class">.22</span>,2121<span class="selector-class">.21</span>)</span><br><span class="line">(213<span class="selector-class">.33</span>)</span><br><span class="line">212<span class="selector-class">.33</span></span><br></pre></td></tr></table></figure></p>
<p>This below shows example of action with phoniex</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> client</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Iterator&gt;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">parse_complex</span><span class="params">(Iterator first,Iterator last,<span class="built_in">std</span>::<span class="keyword">complex</span>&lt;<span class="keyword">double</span>&gt;&amp; c)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">using</span> boost::spirit::qi::double_;</span><br><span class="line">        <span class="keyword">using</span> boost::spirit::qi::_1;</span><br><span class="line">        <span class="keyword">using</span> boost::spirit::qi::phrase_parse;</span><br><span class="line">        <span class="keyword">using</span> boost::spirit::ascii::space;</span><br><span class="line">        <span class="keyword">using</span> boost::phoenix::ref;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">double</span> rN = <span class="number">0.0</span>;</span><br><span class="line">        <span class="keyword">double</span> iN = <span class="number">0.0</span>;</span><br><span class="line">        <span class="keyword">bool</span> r = phrase_parse(</span><br><span class="line">            first,</span><br><span class="line">            last,</span><br><span class="line">            (</span><br><span class="line">                <span class="string">'('</span> &gt;&gt; double_[ref(rN) = _1]</span><br><span class="line">                    &gt;&gt; -(<span class="string">','</span> &gt;&gt; double_[ref(iN) = _1]) &gt;&gt; <span class="string">')'</span> </span><br><span class="line">                | double_[ref(rN) = _1]</span><br><span class="line">            ),</span><br><span class="line">            space</span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">if</span> (!r || first != last)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        c = <span class="built_in">std</span>::<span class="keyword">complex</span>&lt;<span class="keyword">double</span>&gt;(rN,iN);</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Sum-adding-numbers"><a href="#Sum-adding-numbers" class="headerlink" title="Sum - adding numbers"></a>Sum - adding numbers</h3><p>Here is a parser that sums a comma-separated list of numbers.<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">namespace qi = boost::spirit::qi;</span><br><span class="line">namespace ascii = boost::spirit::ascii;</span><br><span class="line">namespace phoenix = boost::spirit::phoenix;</span><br><span class="line"></span><br><span class="line">using qi::double_;</span><br><span class="line">using qi::_1;</span><br><span class="line">using ascii::space;</span><br><span class="line">using phoenix::<span class="keyword">ref</span>;</span><br><span class="line"></span><br><span class="line">template&lt;typename <span class="built_in">Iterator</span>&gt;</span><br><span class="line"><span class="built_in">bool</span> adder(<span class="built_in">Iterator</span> first,<span class="built_in">Iterator</span> last,double&amp; n)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">bool</span> r = qi::phrase_parse(</span><br><span class="line">        first,</span><br><span class="line">        last,</span><br><span class="line">        (</span><br><span class="line">            double_[<span class="keyword">ref</span>(n) = _1] &gt;&gt; *(<span class="string">','</span> &gt;&gt; double_[<span class="keyword">ref</span>(n) += _1])</span><br><span class="line">        ),</span><br><span class="line">        space</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">if</span> (fisrt != last)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="Number-List-stuffing-numbers-into-a-std-vector"><a href="#Number-List-stuffing-numbers-into-a-std-vector" class="headerlink" title="Number List - stuffing numbers into a std::vector"></a>Number List - stuffing numbers into a std::vector</h3><p>This sample demonstrates a parser for a comma separated list of numbers. The numbers are inserted in a vector using phoenix.<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Iterator&gt;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">parse_numbers</span><span class="params">(Iterator fisrt,Iterator last,<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;&amp; v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> qi::double_;</span><br><span class="line">    <span class="keyword">using</span> qi::phrase_parse;</span><br><span class="line">    <span class="keyword">using</span> qi::_1;</span><br><span class="line">    <span class="keyword">using</span> ascii::space;</span><br><span class="line">    <span class="keyword">using</span> phoenix::push_back;</span><br><span class="line">    <span class="keyword">using</span> phoenix::ref;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">bool</span> r = phrase_parse(</span><br><span class="line">        first,</span><br><span class="line">        last,</span><br><span class="line">        (</span><br><span class="line">            double_[push_back(ref(v),_1)] &gt;&gt;</span><br><span class="line">            *(<span class="string">','</span> &gt;&gt; double_[push_back(ref(v),_1)])</span><br><span class="line">        ),</span><br><span class="line">        space</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">if</span>(first != last)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="Number-List-Redux-list-syntax"><a href="#Number-List-Redux-list-syntax" class="headerlink" title="Number List Redux - list syntax"></a>Number List Redux - list syntax</h3><p>So far, we’ve been using the syntax:<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">double<span class="number">_</span> <span class="meta">&gt;&gt; </span>*(<span class="string">','</span> &gt;&gt; double<span class="number">_</span>)</span><br></pre></td></tr></table></figure></p>
<p>to parse a comma-delimited list of numbers.Such lists are common in parsing and Spirit provides a simpler shortcut for them<br><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">double_ <span class="meta">%</span> <span class="string">','</span></span><br></pre></td></tr></table></figure></p>
<p>reads as a list of doubles separted by ‘,’.<br>The last example could be done as this:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Iterator&gt;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">parse_numbers</span><span class="params">(Iterator first,Iterator last,<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;&amp; v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> qi::double_;</span><br><span class="line">    <span class="keyword">using</span> qi::phrase_parse;</span><br><span class="line">    <span class="keyword">using</span> qi::_1;</span><br><span class="line">    <span class="keyword">using</span> ascii::space;</span><br><span class="line">    <span class="keyword">using</span> phoenix::push_back;</span><br><span class="line">    <span class="keyword">using</span> phoenix::ref;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">bool</span> r = phrase_parse(</span><br><span class="line">        first,</span><br><span class="line">        last,</span><br><span class="line">        (</span><br><span class="line">            double_[ref(v),_1] % <span class="string">','</span></span><br><span class="line">        ),</span><br><span class="line">        space</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">if</span> (first != last)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="Number-List-Attribute-one-more-with-style"><a href="#Number-List-Attribute-one-more-with-style" class="headerlink" title="Number List Attribute - one more,with style"></a>Number List Attribute - one more,with style</h3><p>As we know,the <strong>double_</strong> parser has a doubel attribute. All parsers have an attribute,even complex parsers.</p>
<p>Our parser<br><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">doubel_ <span class="meta">%</span> <span class="string">','</span></span><br></pre></td></tr></table></figure></p>
<p>has an attribute of std::vector<double>.<br>So we can simply pass in a std::vector<double> to our number of list parser.the overload of phrase_parse has five arguments:</double></double></p>
<ol>
<li>iterator pointing to start of the input</li>
<li>iterator pointing to last of the input</li>
<li>the parser object</li>
<li>another parser called skip parser</li>
<li>the parse’s attribute</li>
</ol>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">bool r = phrase_parse(</span><br><span class="line">    first,</span><br><span class="line">    last,</span><br><span class="line">    (</span><br><span class="line">        double_ % ','</span><br><span class="line">    ),</span><br><span class="line">    space,</span><br><span class="line">    v</span><br><span class="line">)<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<h3 id="Roman-Numerals"><a href="#Roman-Numerals" class="headerlink" title="Roman Numerals"></a>Roman Numerals</h3><p>This example demonstrates:</p>
<ul>
<li>symbol table</li>
<li>rule</li>
<li>grammar</li>
</ul>
<h4 id="Symbol-table"><a href="#Symbol-table" class="headerlink" title="Symbol table"></a>Symbol table</h4><p>Each entry in a symbol table has an associated mutable data solt. In this regard, one can view the symbol table as an associative container of key-value pairs where the keys are strings.</p>
<p>Here is a parser for roman hundreds(100..900) using the symbol table. Keep in mind that the data associated with each slot is the parser’s attribute(which is passed to attached semantic actions).</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hundreds_</span> :</span> qi::symbols&lt;<span class="keyword">char</span>, <span class="keyword">unsigned</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    hundreds_()</span><br><span class="line">    &#123;</span><br><span class="line">        add</span><br><span class="line">        (<span class="string">"C"</span>,<span class="number">100</span>)</span><br><span class="line">        (<span class="string">"CC"</span>,<span class="number">200</span>)</span><br><span class="line">        (<span class="string">"CCC"</span>,<span class="number">300</span>)</span><br><span class="line">        (<span class="string">"CD"</span>,<span class="number">400</span>)</span><br><span class="line">        (<span class="string">"D"</span>, <span class="number">500</span>)</span><br><span class="line">        (<span class="string">"DC"</span>, <span class="number">600</span>)</span><br><span class="line">        (<span class="string">"DCC"</span>,<span class="number">700</span>)</span><br><span class="line">        (<span class="string">"DCCC"</span>,<span class="number">800</span>)</span><br><span class="line">        (<span class="string">"CM"</span>,<span class="number">900</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; hundreds;</span><br></pre></td></tr></table></figure>
<p>we also can define tens ones symbol table.They are all parsers.</p>
<h4 id="Rules"><a href="#Rules" class="headerlink" title="Rules"></a>Rules</h4><p>Up until now,we have been inlining our parser expressions, passing them directly to the <strong><em>phrase_parse</em></strong> function. The expression evalutes into a temporary,unnamed parser which is passed into the <strong><em>phrase_parse</em></strong> function, used and then destroyed. This is fine for small parsers. When the expressions get complicated, you’d want to break the expressions into smaller easier-to-understand pieces, name them, and refer to them from other expressions by name.</p>
<p>A parser expression can be assigned to what is called a “rule”.Threr are various ways to declare rules.The simplest form is :<br><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">rule</span>&lt;<span class="keyword">Iterator&gt; </span>r<span class="comment">;</span></span><br><span class="line">// this rule cannot used <span class="keyword">by </span>phrase_parse <span class="meta">function</span>,</span><br><span class="line">// <span class="keyword">it </span>can only <span class="keyword">be </span>used <span class="keyword">by </span>parse <span class="meta">function</span> -- a version that does not do white <span class="meta">space</span> skipping.</span><br><span class="line">// <span class="meta">If</span> you want to have <span class="keyword">it </span>skip white spaces,you need to pass in the type skip parser.</span><br><span class="line"><span class="symbol">rule</span>&lt;<span class="keyword">Iterator,Skipper&gt; </span>r<span class="comment">;</span></span><br><span class="line"><span class="symbol">rule</span>&lt;<span class="keyword">string::iterator,space_type&gt; </span>r<span class="comment">;</span></span><br><span class="line">// This type of rule can <span class="keyword">be </span>used for <span class="keyword">both</span></span><br><span class="line"><span class="keyword">// </span>phrase_parse <span class="keyword">and </span>parse.</span><br></pre></td></tr></table></figure></p>
<p>There is one more rule form you should know about.<br><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">rule</span><span class="variable">&lt;Iterator,Signature,Skipper&gt;</span> r;</span><br></pre></td></tr></table></figure></p>
<p>The Signature specifies athe attributes of the rule. Recall that the double_ parser has an attribute of double. To be precise, these are <strong>synthesized</strong> attributes.The parser “synthesized” the attribute value.Think of them as the function return value.</p>
<p>There is another type of attribute called “inherited” attribute. You can think them as function arguments. And,rightly so, the rule signature is a function signature .</p>
<p>After having declared a rule,you can now assign any parser expression to it. Example:<br><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">r</span> = double_ &gt;&gt; *(<span class="string">','</span> &gt;&gt; double_);</span><br></pre></td></tr></table></figure></p>
<h4 id="Grammars"><a href="#Grammars" class="headerlink" title="Grammars"></a>Grammars</h4><p>A grammar encapsulates one or more rules.It has the same template parameters as the rule.You can declare a grammar by:</p>
<ol>
<li>deriving a struct from the grammar class template</li>
<li>declare one or more rules as member variables</li>
<li>initialize the base grammar class by giving it the start rule(its the first rule that gets called when the grammar starts parsing)</li>
<li>initalize your rules in your constrctor.</li>
</ol>
<p>The rommon numeral grammar is a very nice and simple example of a grammar.<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Iterator&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">roman</span> :</span>qi::grammar&lt;Iterator,<span class="keyword">unsigned</span>()&gt;</span><br><span class="line">&#123;</span><br><span class="line">    roman() : roman::base_type(start)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">using</span> qi::eps;</span><br><span class="line">        <span class="keyword">using</span> qi::lit;</span><br><span class="line">        <span class="keyword">using</span> qi::_val;</span><br><span class="line">        <span class="keyword">using</span> qi::_1;</span><br><span class="line">        <span class="keyword">using</span> ascii::char_;</span><br><span class="line">        </span><br><span class="line">        start = eps [_val = <span class="number">0</span>] &gt;&gt;</span><br><span class="line">            (</span><br><span class="line">                +lit(<span class="string">'M'</span>)   [_val += <span class="number">1000</span>]</span><br><span class="line">                || hundreds [_val += _1]</span><br><span class="line">                || tens     [_val += _1]</span><br><span class="line">                || ones     [_val += _1]</span><br><span class="line">            )</span><br><span class="line">    &#125;</span><br><span class="line">    qi::rule&lt;Iterator,<span class="keyword">unsigned</span>()&gt;  start;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol>
<li>the grammar and start rule sinature is unsigned() it has a synthesized attribute(return value) of type unsigned whith on inherited attributeds(argumnents).</li>
<li>roman::base_type is a typedef for grammar&lt;Iterator,unsigned()&gt;</li>
<li>_val is another Phoenix placeholder representing the rule’s synthesized attribute</li>
<li>eps is a special spirit parser that consumes no input but is always successful. We use it to initialize _val,the rule’s synthesized attribute, to zero before anything else. Using eps this way is good for doing pre and post initializations.</li>
<li>the example a || b reads, match a or b and in sequence.That is if both a and b match, it must be in sequence; this is equivalen to a &gt;&gt; -b | b,but more efficient.</li>
</ol>
<p>Usage<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> r = parse(iter,end,roman_parser,result);</span><br><span class="line"><span class="keyword">if</span> (r &amp;&amp; iter == end)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Parse success.\n"</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Result = "</span> &lt;&lt; result &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="Employee-Pasing-into-structs"><a href="#Employee-Pasing-into-structs" class="headerlink" title="Employee - Pasing into structs"></a>Employee - Pasing into structs</h3><p>This section shows how to parse and place the reult into a C++ struct.</p>
<p>fisrtly, let’s create a struct representing an employee.<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">employee</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> surname;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> forename;</span><br><span class="line">    <span class="keyword">double</span> salary;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>now we will write a parser for our employee. Inputs will be of the form.<br><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">employee&#123; age,<span class="string">"surname"</span>,<span class="string">"forename"</span>,salary &#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename Iterator&gt;</span><br><span class="line">struct employee_parser : qi::grammar&lt;Iterator,employee(),ascii::space_type&gt;</span><br><span class="line">&#123;</span><br><span class="line">    employee_parser()<span class="symbol">:employee_parser</span><span class="symbol">:</span><span class="symbol">:base_type</span>(start)</span><br><span class="line">    &#123;</span><br><span class="line">        using qi::int<span class="number">_</span>;</span><br><span class="line">        using qi::lit;</span><br><span class="line">        using qi::double<span class="number">_</span>;</span><br><span class="line">        using qi::lexeme;</span><br><span class="line">        using ascii::char<span class="number">_</span>;</span><br><span class="line">        </span><br><span class="line">        quoted_string %= lexeme[<span class="string">'"'</span> <span class="meta">&gt;&gt; </span>+(char<span class="number">_</span> - <span class="string">'"'</span>) &gt;&gt; <span class="string">'"'</span>];</span><br><span class="line">        </span><br><span class="line">        start %= </span><br><span class="line">            lit(<span class="string">"employee"</span>)</span><br><span class="line">            <span class="meta">&gt;&gt; </span><span class="string">'&#123;'</span></span><br><span class="line">            <span class="meta">&gt;&gt; </span>int<span class="number">_</span> &gt;&gt; <span class="string">','</span></span><br><span class="line">            <span class="meta">&gt;&gt; </span>quoted_string &gt;&gt; <span class="string">','</span></span><br><span class="line">            <span class="meta">&gt;&gt; </span>quoted_string &gt;&gt; <span class="string">','</span></span><br><span class="line">            <span class="meta">&gt;&gt; </span>double<span class="number">_</span></span><br><span class="line">            <span class="meta">&gt;&gt; </span><span class="string">'&#125;'</span></span><br><span class="line">            ;</span><br><span class="line">    &#125;</span><br><span class="line">    qi::rule&lt;Iterator,std::string(),ascii::space_type&gt; quoted_string;</span><br><span class="line">    qi::rule&lt;Iterator,employee(),ascii::space_type&gt; start;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="Lexeme"><a href="#Lexeme" class="headerlink" title="Lexeme"></a>Lexeme</h4><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lexeme[<span class="string">'"'</span> <span class="meta">&gt;&gt;</span>(char<span class="number">_</span> - <span class="string">'"'</span>) &gt;&gt; <span class="string">'"'</span>]</span><br></pre></td></tr></table></figure>
<p>lexeme inhibits sapce skipping from the open brace to the closing space.The expression parses quoted strings.<br><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+(char_ - '"')</span><br></pre></td></tr></table></figure></p>
<p>parses one or more chars,except the double quote. It stops when it sees a double quote.</p>
<p>+a matches one or more,its attribute is a std::vector<a> where A is the attribute of a .</a></p>
<h4 id="Sequence-Attribute"><a href="#Sequence-Attribute" class="headerlink" title="Sequence Attribute"></a>Sequence Attribute</h4><p>now what’s the attribute of<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'"'</span> <span class="meta">&gt;&gt; </span>(char<span class="number">_</span> - <span class="string">'"'</span>) &gt;&gt;<span class="string">'"'</span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">a</span> &gt;&gt; <span class="selector-tag">b</span> &gt;&gt; c </span><br><span class="line">fusion::vector&lt;A,B,C&gt;</span><br><span class="line"><span class="comment">// is a tuple</span></span><br></pre></td></tr></table></figure>
<p>Some parser,especially those very little parsers like ‘“‘ do not have attributes.<br>Nodes without attributes are disregarded.<br>so, ‘“‘ &gt;&gt; (char_ - ‘“‘) &gt;&gt;’”‘  ‘s attribue is<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fusion::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;</span><br></pre></td></tr></table></figure></p>
<p>but there is one more collpase rule.if the attribute is followed by a single element fusion::vector, The element is stripped naked from its container. so the attribute come to this<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;</span><br></pre></td></tr></table></figure></p>
<h4 id="Auto-Rules"><a href="#Auto-Rules" class="headerlink" title="Auto Rules"></a>Auto Rules</h4><p>it is typical to see rules like<br><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">r</span> = p[_val = _1]</span><br></pre></td></tr></table></figure></p>
<p>if you have a rule definiton such as the above,where the attribute of the right hand side of the rule is compitable with the left hand side.then you can rewrite is as:<br><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">r %= p<span class="comment">;</span></span><br></pre></td></tr></table></figure></p>
<p>so<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">quoted_string %= lexeme[<span class="string">'"'</span> <span class="meta">&gt;&gt; </span>+( char<span class="number">_</span> -<span class="string">'"'</span>) &gt;&gt; <span class="string">'"'</span>];</span><br></pre></td></tr></table></figure></p>
<p>is simple version of<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">quoted_string = lexeme[<span class="string">'"'</span> <span class="meta">&gt;&gt; </span>+ (char<span class="number">_</span> - <span class="string">'"'</span>) &gt;&gt; <span class="string">'"'</span>][_val = _1];</span><br></pre></td></tr></table></figure></p>
<p>Note: r %= p and r = p are equivalent if there are no semantic actions associated with p.</p>
<p>In case you are wondering, lit(“employee”) is the same as “employee”. We had to wrap it inside lit because immediately after it is &gt;&gt; ‘{‘. You can’t right-shift a char[] and a char - you know, C++ syntax rules.</p>
<h2 id="Karma-Writing-Generators"><a href="#Karma-Writing-Generators" class="headerlink" title="Karma - Writing Generators"></a>Karma - Writing Generators</h2><h3 id="Spirit-Karma-what’s-that"><a href="#Spirit-Karma-what’s-that" class="headerlink" title="Spirit.Karma - what’s that?"></a>Spirit.Karma - what’s that?</h3><p>Spirit.Karma is the counterpart to spirit.qi.<br>Some people say it’s the Yin to Spirit.Qi’s Yang. Spirit.karma is generating byte sequences from internal data structures as Spirit.Qi is parsing byte sequences into those internal data structures.</p>
<p>Why should you use a generator library for such a simple thing as output generation? Programmers have been using printf, std::stream formatting, or boost::format for quite some time. The answer is - yes, for simple output formatting tasks those familiar tools might be a quick solution. But experience shows: as soon as the formatting requirements are becoming more complex output generation is getting more and more challenging in terms of readability, maintainability, and flexibility of the code. Last, but not least, it turns out that code using Spirit.Karma runs much faster than equivalent code using either of the ‘straight’ methods mentioned above.</p>
<p>In terms of development simplicity and ease in deployment, the same is true for Spirit.Karma as has been described elsewhere in this documentation for Spirit.Qi: the entire library consists of only header files, with no libraries to link against or build. Just put the spirit distribution in your include path, compile and run. Code size? Very tight, essentially comparable to hand written code.</p>
<h3 id="Examples-1"><a href="#Examples-1" class="headerlink" title="Examples"></a>Examples</h3><h4 id="Trivial-Example-Generating-a-number"><a href="#Trivial-Example-Generating-a-number" class="headerlink" title="Trivial Example Generating a number"></a>Trivial Example Generating a number</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">double_</span><br></pre></td></tr></table></figure>
<h4 id="Generating-two-numbers"><a href="#Generating-two-numbers" class="headerlink" title="Generating two numbers"></a>Generating two numbers</h4><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">double_</span> &lt;&lt; double_</span><br></pre></td></tr></table></figure>
<h4 id="Generating-one-or-more-numbers"><a href="#Generating-one-or-more-numbers" class="headerlink" title="Generating one or more numbers"></a>Generating one or more numbers</h4><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">*double_</span></span><br></pre></td></tr></table></figure>
<h4 id="Generating-a-comma-delimited-list-of-numbers"><a href="#Generating-a-comma-delimited-list-of-numbers" class="headerlink" title="Generating a comma-delimited list of numbers"></a>Generating a comma-delimited list of numbers</h4><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">double_ &lt;&lt; *(<span class="name">lit</span>(',')) &lt;&lt; double_</span><br></pre></td></tr></table></figure>
<h4 id="Let’s-generate"><a href="#Let’s-generate" class="headerlink" title="Let’s generate"></a>Let’s generate</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> OutputIterator&gt;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">generate_numbers</span><span class="params">(OutputIterator&amp; sink,<span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="keyword">double</span>&gt; <span class="keyword">const</span>&amp; v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> karma::double_;</span><br><span class="line">    <span class="keyword">using</span> karma::generate_delimited;</span><br><span class="line">    <span class="keyword">using</span> ascii::space;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">bool</span> r = genated_delimited(</span><br><span class="line">        sink,</span><br><span class="line">        double_ &lt;&lt; *(<span class="string">','</span> &lt;&lt; double_),</span><br><span class="line">        v</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    
    
    

    

    
      <div>
        <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
  <div>Donate</div>
  <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
    <span>打赏</span>
  </button>
  <div id="QR" style="display: none;">

    
      <div id="wechat" style="display: inline-block">
        <img id="wechat_qr" src="/images/wechatpay.png" alt="carbo06@163.com 微信支付"/>
        <p>微信支付</p>
      </div>
    

    
      <div id="alipay" style="display: inline-block">
        <img id="alipay_qr" src="/images/alipay.png" alt="carbo06@163.com 支付宝"/>
        <p>支付宝</p>
      </div>
    

    

  </div>
</div>

      </div>
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Boost/" rel="tag"># Boost</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/03/28/OpenMp-Tutorial/" rel="next" title="OpenMp Tutorial">
                <i class="fa fa-chevron-left"></i> OpenMp Tutorial
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/03/29/C-Thread-Pool-使用解析/" rel="prev" title="C++ Thread Pool 使用解析">
                C++ Thread Pool 使用解析 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
      
        <div id="gitment-container"></div>
      
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.png"
                alt="carbo06@163.com" />
            
              <p class="site-author-name" itemprop="name">carbo06@163.com</p>
              <p class="site-description motion-element" itemprop="description">About Linux C++ and routing algorithms.</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">45</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">5</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">18</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/ce39906" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:ce39906@163.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-block">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                Friends
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="https://lambdae.github.io/" title="DingliYang" target="_blank">DingliYang</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://zsirkg.github.io/" title="SongZhang" target="_blank">SongZhang</a>
                  </li>
                
              </ul>
            </div>
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#What-is-boost-spirit"><span class="nav-number">1.</span> <span class="nav-text">What is boost spirit</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Qi-Writing-Parsers"><span class="nav-number">1.1.</span> <span class="nav-text">Qi- Writing Parsers</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Examples"><span class="nav-number">1.1.1.</span> <span class="nav-text">Examples</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Example-1-parsing-a-number"><span class="nav-number">1.1.1.1.</span> <span class="nav-text">Example #1 parsing a number</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Example-2-parsing-2-numbers"><span class="nav-number">1.1.1.2.</span> <span class="nav-text">Example #2  parsing 2 numbers</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Example-3-parsing-zero-or-more-numbers"><span class="nav-number">1.1.1.3.</span> <span class="nav-text">Example #3 parsing zero or more numbers</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Example-4-parsing-a-comma-delimited-list-of-numbers"><span class="nav-number">1.1.1.4.</span> <span class="nav-text">Example #4 parsing a comma-delimited list of numbers</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Let’s-Parse"><span class="nav-number">1.1.1.5.</span> <span class="nav-text">Let’s Parse</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Parser-Semantic-Actions"><span class="nav-number">1.1.2.</span> <span class="nav-text">Parser Semantic Actions</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Example-of-Semantic-Actions"><span class="nav-number">1.1.2.1.</span> <span class="nav-text">Example of Semantic Actions</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Phoenix"><span class="nav-number">1.1.2.2.</span> <span class="nav-text">Phoenix</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Complex-Our-first-complex-parser"><span class="nav-number">1.1.3.</span> <span class="nav-text">Complex - Our first complex parser</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Sum-adding-numbers"><span class="nav-number">1.1.4.</span> <span class="nav-text">Sum - adding numbers</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Number-List-stuffing-numbers-into-a-std-vector"><span class="nav-number">1.1.5.</span> <span class="nav-text">Number List - stuffing numbers into a std::vector</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Number-List-Redux-list-syntax"><span class="nav-number">1.1.6.</span> <span class="nav-text">Number List Redux - list syntax</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Number-List-Attribute-one-more-with-style"><span class="nav-number">1.1.7.</span> <span class="nav-text">Number List Attribute - one more,with style</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Roman-Numerals"><span class="nav-number">1.1.8.</span> <span class="nav-text">Roman Numerals</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Symbol-table"><span class="nav-number">1.1.8.1.</span> <span class="nav-text">Symbol table</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Rules"><span class="nav-number">1.1.8.2.</span> <span class="nav-text">Rules</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Grammars"><span class="nav-number">1.1.8.3.</span> <span class="nav-text">Grammars</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Employee-Pasing-into-structs"><span class="nav-number">1.1.9.</span> <span class="nav-text">Employee - Pasing into structs</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Lexeme"><span class="nav-number">1.1.9.1.</span> <span class="nav-text">Lexeme</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Sequence-Attribute"><span class="nav-number">1.1.9.2.</span> <span class="nav-text">Sequence Attribute</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Auto-Rules"><span class="nav-number">1.1.9.3.</span> <span class="nav-text">Auto Rules</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Karma-Writing-Generators"><span class="nav-number">1.2.</span> <span class="nav-text">Karma - Writing Generators</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Spirit-Karma-what’s-that"><span class="nav-number">1.2.1.</span> <span class="nav-text">Spirit.Karma - what’s that?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Examples-1"><span class="nav-number">1.2.2.</span> <span class="nav-text">Examples</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Trivial-Example-Generating-a-number"><span class="nav-number">1.2.2.1.</span> <span class="nav-text">Trivial Example Generating a number</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Generating-two-numbers"><span class="nav-number">1.2.2.2.</span> <span class="nav-text">Generating two numbers</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Generating-one-or-more-numbers"><span class="nav-number">1.2.2.3.</span> <span class="nav-text">Generating one or more numbers</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Generating-a-comma-delimited-list-of-numbers"><span class="nav-number">1.2.2.4.</span> <span class="nav-text">Generating a comma-delimited list of numbers</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Let’s-generate"><span class="nav-number">1.2.2.5.</span> <span class="nav-text">Let’s generate</span></a></li></ol></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">carbo06@163.com</span>

  
</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
          <span id="scrollpercent"><span>0</span>%</span>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  







<!-- LOCAL: You can save these files to your site and update links -->
    
        
        <link rel="stylesheet" href="https://aimingoo.github.io/gitmint/style/default.css">
        <script src="https://aimingoo.github.io/gitmint/dist/gitmint.browser.js"></script>
    
<!-- END LOCAL -->

    
      <style>
        a.gitment-editor-footer-tip { display: none; }
        .gitment-container.gitment-footer-container { display: none; }
      </style>
    

    
      <script type="text/javascript">
      function renderGitment(){
        var gitment = new Gitmint({
            id: decodeURI(window.location.pathname).substring(0,20), 
            owner: 'carbo06',
            repo: 'gitment',
            
            lang: "" || navigator.language || navigator.systemLanguage || navigator.userLanguage,
            
            oauth: {
            
            
                client_secret: 'cb86e5ac2c3dba18be1c7815742a4f761de98fe7',
            
                client_id: '70728960b33c81e406d0'
            }});
        gitment.render('gitment-container');
      }

      
      renderGitment();
      
      </script>
    







  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

<script type="text/javascript" src="/live2d/script.js"></script>
<canvas id="live2dcanvas" width="300" height="400" class="live2d"></canvas>
<style>
  #live2dcanvas {
    position: fixed;
    left: 0px;
    z-index: 999;
    pointer-events: none;
    bottom: -50px;
  }
</style>
<script>loadlive2d("live2dcanvas"
,"/live2d/models/tororo.model.json",0.5)</script><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config("");
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="custom_mathjax_source">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->

</body>
</html>
