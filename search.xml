<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Tensorflow 解决路况状态分类问题]]></title>
    <url>%2F2018%2F09%2F03%2FTensorflow-%E8%A7%A3%E5%86%B3%E8%B7%AF%E5%86%B5%E7%8A%B6%E6%80%81%E5%88%86%E7%B1%BB%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[背景路况在地图渲染时候，会针对不同的拥堵情况选择不同颜色。一般来讲，道路拥堵情况分为三个状态，畅通，拥堵，缓行，分别用绿色，黄色，红色来渲染。我们面临的问题是，已知道路属性以及通行速度，需要对路况状态进行分类。解决方案是依据第三方路况提供的路况状态以及抓取的高德路况状态来训练一个三分类模型。 特征处理应用的特征如下 feature description speed 路况速度 maxspeed 道路最大速度 highway_level 道路等级,共有17种可能，使用one-hot-encoding lanes 车道数 oneway 是否是单向路，使用one-hot-encoding 路况状态使用 0-1-2 分别表示畅通-拥堵-缓行处理好的特征使用\t分割的文本处理，最后一列代表路况状态。 模型训练模型使用TensorFlow 提供的DNN分类器。代码如下123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146#-*- coding: utf-8 -*-"""File Name: traffic_status_classifier.pyAuthor: ce39906mail: ce39906@163.comCreated Time: 2018-09-03 19:11:57"""import sysimport timeimport numpy as npimport tensorflow as tfFEATURES = [ "speed", "maxspeed", "level_1", "level_2", "level_3", "level_4", "level_5", "level_6", "level_7", "level_8", "level_9", "level_10", "level_11", "level_12", "level_13", "level_14", "level_15", "level_16", "level_17", "lanes", "oneway_0", "oneway_1"]def usage(): print "python %s $&#123;train_data_file&#125;" % (sys.argv[0])def read_data(train_data_file): xy_list = [] with open(train_data_file, 'r') as f: for line in f: line = line.strip('\n') content = line.split('\t') xy = [int(float(x)) for x in content] xy_list.append(xy) # 80% as train data, 20% as test data train_xy = xy_list[ : int(len(xy_list) * 0.8)] test_xy = xy_list[int(len(xy_list) * 0.8) : ] train_x = [x[ : -1] for x in train_xy] train_y = [x[-1] for x in train_xy] test_x = [x[ : -1] for x in test_xy] test_y = [x[-1] for x in test_xy] return train_x, train_y, test_x, test_ydef list_2_tf_dataset(train_x, train_y, test_x, test_y): train_x = np.array(train_x) train_y_dataset = np.array(train_y) test_x = np.array(test_x) test_y_dataset = np.array(test_y) train_x_cols = [] for col in train_x.T: train_x_cols.append(col) train_x_dataset = &#123;&#125; for i in range(len(FEATURES)): train_x_dataset[FEATURES[i]] = train_x_cols[i] test_x_cols = [] for col in test_x.T: test_x_cols.append(col) test_x_dataset = &#123;&#125; for i in range(len(FEATURES)): test_x_dataset[FEATURES[i]] = test_x_cols[i] return train_x_dataset, train_y_dataset, test_x_dataset, test_y_datasetdef train_input_fn(features, labels, batch_size): dataset = tf.data.Dataset.from_tensor_slices((features, labels)) # Shuffle, repeat, and batch the examples. dataset = dataset.shuffle(1000).repeat().batch(batch_size) return datasetdef eval_input_fn(features, labels, batch_size): if labels is None: inputs = features else: inputs = (features, labels) dataset = tf.data.Dataset.from_tensor_slices(inputs) # batch the example dataset = dataset.batch(batch_size) return datasetdef main(): if len(sys.argv) != 2: usage() sys.exit() batch_size = 100 steps = 10000 train_data_file = sys.argv[1] # adapt to tensorflow format train_x_list, train_y_list, test_x_list, test_y_list = read_data(train_data_file) train_x, train_y, test_x, test_y = \ list_2_tf_dataset(train_x_list, train_y_list, test_x_list, test_y_list) feature_columns = [] for key in train_x.keys(): feature_columns.append(tf.feature_column.numeric_column(key = key)) start_time = time.time() classifier = tf.estimator.DNNClassifier( feature_columns = feature_columns, hidden_units = [10, 10], n_classes = 3) # train the model classifier.train( input_fn = lambda:train_input_fn(train_x, train_y, batch_size), steps = steps) end_time = time.time() print 'Train DNN Classifier cost %fs.' %(end_time - start_time) # evaluate the model eval_result = classifier.evaluate( input_fn = lambda:eval_input_fn(test_x, test_y, batch_size)) print('\nTest set accuracy: &#123;accuracy:0.3f&#125;\n'.format(**eval_result))if __name__ == '__main__': main() 输出如下 模型应用到C++工程TODO]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Tensorflow</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读书短评-《未来简史》]]></title>
    <url>%2F2018%2F08%2F25%2F%E8%AF%BB%E4%B9%A6%E7%9F%AD%E8%AF%84-%E3%80%8A%E6%9C%AA%E6%9D%A5%E7%AE%80%E5%8F%B2%E3%80%8B%2F</url>
    <content type="text"><![CDATA[断断续续花了三个月才读完，再次（上次是人类简史）惊叹于作者涉猎广阔，博学深刻。kindle上看到进度是90%的时候发现整书就结束了，剩下10%是参考文献。给跪了…书中前半部分一个核心观点是讲从生物角度来看人类与其他高级哺乳动物并无巨大差别，人类所以胜利是依靠出众的合作能力。另一个核心观点是未来人类的目标是追求快乐以及获得永生，这个目标即使可能实现也一定先在领导身上实现，那时死亡这唯一公平的事也不复存在，因此也就很可能引发大的社会危机。后半部分的核心观点是未来生物科技可能会让人变成超人类（当然也是领导先）。基于大量数据的人工智能算法在很多领域的表现会超过人类（包括艺术）。不管啥算法的实现都需要写代码的吧，基于此，我写写代码肯定是足够混口饭吃的。]]></content>
      <categories>
        <category>Reading</category>
      </categories>
      <tags>
        <tag>reading</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[g++ warn_unused_result]]></title>
    <url>%2F2018%2F08%2F24%2Fg-warn-unused-result%2F</url>
    <content type="text"><![CDATA[介绍在编程过程中，有的函数我们需要确保函数的返回值必须被使用。但是如果函数使用者直接调用函数且不使用函数的返回值的话，g++ 不会给出warning。这样可能会导致很难寻觅的bug。如调用realloc函数，函数调用者必须使用函数的返回值获得重新分配内存的指针。利用g++ common function attributes 中提供的warn_unused_result 可以保证函数的返回值在没有被使用的时候提示warning，如果在编译选项添加-Werror, 则在编译时就会提示编译错误。关于更多 g++ common function attributes 参见https://gcc.gnu.org/onlinedocs/gcc/Common-Function-Attributes.html 示例测试代码如下1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556/************************************************************************* &gt; File Name: warn_unused_result.cpp &gt; Author: ce39906 &gt; Mail: ce39906@163.com &gt; Created Time: 2018-08-24 14:04:00 ************************************************************************/__attribute__ ((warn_unused_result))int f(int x)&#123; return x / 2;&#125;__attribute__ ((warn_unused_result))double f1()&#123; return 0.;&#125;class EmptyClass&#123;&#125;;__attribute__ ((warn_unused_result))EmptyClass f2()&#123; return EmptyClass();&#125;class NotEmptyClass&#123; int a;&#125;;__attribute__ ((warn_unused_result))NotEmptyClass f3()&#123; return NotEmptyClass();&#125;int main()&#123; // cause unused_result warning f(3); // no unused_result warning int x = f(3); (void) x; // cause unused_result warning f1(); // cause unused_result warning f2(); // no unused_result warning. WHY?? f3(); return 0;&#125; 编译 g++ -Wall -Wextra warn_unused_result.cpp -o warn_unused_result 编译输出如下其中比较奇怪的现象是当函数返回一个非空的对象时，不会产生warning，比较诡异，至今没找到合理解释。]]></content>
      <categories>
        <category>Backend Development</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++11 智能指针]]></title>
    <url>%2F2018%2F08%2F08%2FC-11-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%2F</url>
    <content type="text"><![CDATA[智能指针的思想c++ 要求程序员自己管理内存，为程序员提供了更高自由度，但更高的自由度同时意味着更多责任。为了减少c++程序员在使用裸指针时可能带来的内存泄露，c++11 引入智能指针帮助程序员管理内存。智能指针背后的设计思想是RAII unique_ptrunique_ptr 设计的目的是保证指针变量只指向一个实体，避免出现有其他指针变量指向相同实体，或者此指针变量指向同类型的其他实体。可以理解为指针变量与实体之间是一对一的关系。为了实现上述设计目标，unique_ptr 的拷贝构造函数以及赋值构造函数都声明为deleted(c++11引入，和将拷贝构造函数以及赋值构造函数声明为private实现的效果一致)。所以unique_ptr 只允许使用裸指针初始化或者使用其他unique_ptr移动构造。比较特殊的是，一个新的unique_ptr变量可以从返回值为unique_ptr的函数构造。 12345678910111213unique_ptr&lt;int&gt; p(new int(2)); // allowedunique_ptr&lt;int&gt; p1(p); // not allowedunique_ptr&lt;int&gt; p2 = p; // not allowedunique_ptr&lt;int&gt; p3(std::move(p)); // allowedunique_ptr&lt;int&gt; p4 = std::move(p) // allowedunique_ptr&lt;int&gt; foo()&#123; unique_ptr&lt;int&gt; p(new int(2)); return p;&#125;unique_ptr&lt;int&gt; p5 = foo(); // allowed 在引入 unique_ptr 之前，存在一个叫做auto_ptr 的智能指针，auto_ptr 与 unique_ptr 不同点是auto_ptr没有禁止拷贝构造和赋值构造，并且在执行拷贝构造和赋值构造后，之前的指针变量指向null，再次解引用时会产生运行时错误，这就是auto_ptr被广为诟病的地方。unique_ptr只有在被显示移动的时候才会将实体的所有权交给其他变量。现auto_ptr已经弃用。 shared_ptrunique_ptr 实现指针变量与实体之前一一对应关系，但是在实际应用中，我们经常存在多个指针变量共同指向一个实体的场景，当所有指针变量的生命周期结束时再释放相应的资源。shared_ptr 就是为了解决此问题而引入。简单的来讲，shared_ptr 实现的原理是在内部使用一个引用计数，每当有一个新的指针变量绑定到实体上时内部的引用计数加一，如果有指针变量生命周期结束引用计数减一，当引用计数为0时，释放相应资源。shared_ptr 可以使用 use_count() 方法查看引用计数大小。在多线程的环境下使用shared_ptr的const成员方法不需要外部的同步机制，使用shared_ptr的非const方法时需要重载shared_ptr的原子方法防止数据竞争。需要注意的是，shared_ptr的引用计数内部的实现原理是一个原子变量，因此在多线程的环境下有大量的shared_ptr变量的复制以及销毁的话会带来比较大的性能损耗，所以如果新的shared_ptr 变量不需要改变指向的实体的内容时应该按照 const reference的方式使用。这个问题在我实际开发中遇到过，问题比较隐蔽，花费了大量时间才定位到。 weak_ptrweak_ptr 的定义weak_ptr 是为了配合shared_ptr而引入，weak_ptr 指向shared_ptr 管理的对象但是不会增加shared_ptr内部的引用计数，也就是说，不管是否有weak_ptr 指向对象，只要是shared_ptr的引用计数为0时，对象也会被销毁。weak_ptr 没有重载 * 以及 -&gt; 方法。weak_ptr 提供了use_count 查看观察的shared_ptr的引用计数，使用expired 方法判断shared_ptr 指向的对象是否被销毁，使用lock方法创建一个新的shared_ptr 变量。 shared_ptr 循环引用问题考虑以下代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;memory&gt;#include &lt;iostream&gt;class B;class A&#123; public: A() &#123; std::cout &lt;&lt; "A construct.\n"; &#125; ~A() &#123; std::cout &lt;&lt; "A destruct.\n"; &#125; std::shared_ptr&lt;B&gt; pb;&#125;;class B&#123; public: B() &#123; std::cout &lt;&lt; "B construct.\n"; &#125; ~B() &#123; std::cout &lt;&lt; "B destruct.\n"; &#125; std::shared_ptr&lt;A&gt; pa;&#125;;int main()&#123; std::shared_ptr&lt;A&gt; a(new A()); std::shared_ptr&lt;B&gt; b(new B()); a-&gt;pb = b; b-&gt;pa = a; return 0;&#125; 编译后执行结果如下 A construct.B construct. 可以看到，由于互相引用，shared_ptr a 以及 b 所管理的对象都没有释放。我们把上述代码中的类A 以及类B中成员变量都声明为weak_ptr 类型后重新编译运行后的结果如下 A construct.B construct.B destruct.A destruct. 由此可见，weak_ptr 不会增加shared_ptr 的互相引用的问题，可以保证shared_ptr所管理的资源可以正确释放。 weak_ptr 与观察者模式利用weak_ptr的特性，使用weak_ptr 以及shared_ptr配合可以实现观察者模式]]></content>
      <categories>
        <category>Backend Development</category>
      </categories>
      <tags>
        <tag>c++11</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Json library implemented by boost variant]]></title>
    <url>%2F2018%2F08%2F01%2FJson-library-implemented-by-boost-variant%2F</url>
    <content type="text"><![CDATA[boost variant 介绍boost variant 是一个不同union的泛型类，它用于存储和操作不同类型但在使用时存在&lt;相同泛型&gt;的对象。variant 在实现不同类型的泛型的同时，提供对其包含的具体类型的安全访问。基于此性质，boost variant 可以应用于创建json 这种数据结构，我们把json 中的Object, Array, String, Number, True, False, Null 统一当做同一种variant 类型。需要注意的是，json 中的Object 和 Array 类型是递归的variant 类型，在声明时需要使用 boost::recursive_wrapper 修饰。boost::recursivee_wrapper用于创建包含创建的variant类型的表达式。在访问varint 类型时，可以使用boost::get 以及 boost::apply_visitor 的形式。更多关于 boost variant 的介绍见:https://www.boost.org/doc/libs/1_62_0/doc/html/variant/reference.html json 数据结构json 的数据类型实现如下123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107/************************************************************************* &gt; File Name: json_type.hpp &gt; Author: ce39906 &gt; Mail: ce39906@163.com &gt; Created Time: 2018-07-31 16:25:59 ************************************************************************/#ifndef JSON_TYPE_HPP#define JSON_TYPE_HPP#include &lt;boost/variant.hpp&gt;#include &lt;string&gt;#include &lt;unordered_map&gt;#include &lt;vector&gt;namespace json&#123;struct Object;struct Array;struct String&#123; String() &#123;&#125; String(const char* value) : value&#123;value&#125; &#123;&#125; String(std::string value) : value&#123;std::move(value)&#125; &#123;&#125; std::string value;&#125;;struct Number&#123; Number() &#123;&#125;; Number(const double value) : value&#123;value&#125; &#123;&#125; double value;&#125;;struct True&#123;&#125;;struct False&#123;&#125;;struct Null&#123;&#125;;using Value = boost::variant&lt;String, Number, boost::recursive_wrapper&lt;Object&gt;, boost::recursive_wrapper&lt;Array&gt;, True, False, Null&gt;;struct Object&#123; bool isMember(const std::string&amp; key) const &#123; return values.count(key) != 0; &#125; const Value&amp; at(const std::string&amp; key) const &#123; return values.at(key); &#125; const Value&amp; operator[](const std::string&amp; key) const &#123; return values.at(key); &#125; std::unordered_map&lt;std::string, Value&gt; values;&#125;;struct Array&#123; const Value&amp; at(const size_t idx) const &#123; return values.at(idx); &#125; const Value&amp; operator[](const size_t idx) const &#123; return values.at(idx); &#125; size_t size() const &#123; return values.size(); &#125; const Value&amp; front() const &#123; return values.front(); &#125; const Value&amp; back() const &#123; return values.back(); &#125; std::vector&lt;Value&gt; values;&#125;;&#125; // ns json#endif json 数据访问本节只介绍使用boost::get 访问varint数据。boost::apply_visitor 的方式在序列化的部分介绍代码示例如下 123456789101112131415161718192021222324252627282930313233343536373839namespace access&#123;inline const Object&amp; asObject(const Value&amp; value)&#123; return boost::get&lt;Object&gt;(value);&#125;inline const Array&amp; asArray(const Value&amp; value)&#123; return boost::get&lt;Array&gt;(value);&#125;inline const String&amp; asString(const Value&amp; value)&#123; return boost::get&lt;String&gt;(value);&#125;inline const Number&amp; asNumber(const Value&amp; value)&#123; return boost::get&lt;Number&gt;(value);&#125;inline const True&amp; asTrue(const Value&amp; value)&#123; return boost::get&lt;True&gt;(value);&#125;inline const False&amp; asFalse(const Value&amp; value)&#123; return boost::get&lt;False&gt;(value);&#125;inline const Null&amp; asNull(const Value&amp; value)&#123; return boost::get&lt;Null&gt;(value);&#125;&#125; // ns access json 序列化json 序列化利用boost::apply_visitor. boost::apply_visitor需要实现一个visitor 函数对象，函数对象针对不同实际类型实现不同的序列化方式，针对Object以及Array 这两种类型需要递归调用visitor。示例代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164/************************************************************************* &gt; File Name: json_serialize.hpp &gt; Author: ce39906 &gt; Mail: ce39906@163.com &gt; Created Time: 2018-07-31 17:23:19 ************************************************************************/#ifndef JSON_SERIALIZE_HPP#define JSON_SERIALIZE_HPP#include "json_type.hpp"#include "json_util.hpp"#include &lt;vector&gt;#include &lt;ostream&gt;namespace json&#123;struct SerializeToOstream : boost::static_visitor&lt;void&gt;&#123; explicit SerializeToOstream (std::ostream&amp; out) : out(out) &#123;&#125; void operator() (const String&amp; string) const &#123; out &lt;&lt; "\""; out &lt;&lt; string.value; out &lt;&lt; "\""; &#125; void operator() (const Number&amp; number) const &#123; out &lt;&lt; util::cast::to_string_with_percision(number.value); &#125; void operator() (const Object&amp; object) const &#123; out &lt;&lt; "&#123;"; for (auto it = object.values.begin(); it != object.values.end();) &#123; out &lt;&lt; "\"" &lt;&lt; it-&gt;first &lt;&lt; "\":"; boost::apply_visitor(SerializeToOstream(out), it-&gt;second); if (++it != object.values.end()) &#123; out &lt;&lt; ","; &#125; &#125; out &lt;&lt; "&#125;"; &#125; void operator() (const Array&amp; array) const &#123; out &lt;&lt; "["; for (auto it = array.values.cbegin(); it != array.values.cend();) &#123; boost::apply_visitor(SerializeToOstream(out), *it); if (++it != array.values.cend()) &#123; out &lt;&lt; ","; &#125; &#125; out &lt;&lt; "]"; &#125; void operator() (const True&amp;) const &#123; out &lt;&lt; "ture"; &#125; void operator() (const False&amp;) const &#123; out &lt;&lt; "false"; &#125; void operator() (const Null&amp;) const &#123; out &lt;&lt; "null"; &#125; private: std::ostream&amp; out;&#125;;struct SerializeToString : boost::static_visitor&lt;void&gt;&#123; explicit SerializeToString (std::string&amp; out) : out(out) &#123;&#125; void operator() (const String&amp; string) const &#123; out.push_back('\"'); out.append(string.value); out.push_back('\"'); &#125; void operator() (const Number&amp; number) const &#123; const std::string number_str = util::cast::to_string_with_percision(number.value); out.append(std::move(number_str)); &#125; void operator() (const Object&amp; object) const &#123; out.push_back('&#123;'); for (auto it = object.values.begin(); it != object.values.end();) &#123; out.push_back('\"'); out.append(it-&gt;first); out.push_back('\"'); out.push_back(':'); boost::apply_visitor(SerializeToString(out), it-&gt;second); if (++it != object.values.end()) &#123; out.push_back(','); &#125; &#125; out.push_back('&#125;'); &#125; void operator() (const Array&amp; array) const &#123; out.push_back('['); for (auto it = array.values.cbegin(); it != array.values.cend();) &#123; boost::apply_visitor(SerializeToString(out), *it); if (++it != array.values.cend()) &#123; out.push_back(','); &#125; &#125; out.push_back(']'); &#125; void operator() (const True&amp;) const &#123; out.append("true"); &#125; void operator() (const False&amp;) const &#123; out.append("false"); &#125; void operator() (const Null&amp;) const &#123; out.append("null"); &#125; private: std::string&amp; out;&#125;;void serialize(std::ostream&amp; out, const Object&amp; object)&#123; Value value = object; boost::apply_visitor(SerializeToOstream(out), value);&#125;void serialize(std::string&amp; out, const Object&amp; object)&#123; Value value = object; boost::apply_visitor(SerializeToString(out), value);&#125;&#125; // ns json#endif 构造json 结构针对String,Number,True,False,Null 这类简单类型可以直接使用构造函数构造。Array 类型内部使用vector 类型，构造时使用vector 的 push_back, emplace_back 方法增加Array的元素。Object 类型内部使用unordered_map 类型，构造时可以使用 unordered_map 的内建方法。示例代码如下： 12345678910111213Object obj;obj.values["string"] = "v1";obj.values["bool"] = True();obj.values["null"] = Null();obj.values["number"] = Number(9);Array arr;arr.values.emplace_back(Number(1.02));arr.values.emplace_back(Number(2.2));arr.values.emplace_back(Number(3));arr.values.emplace_back(True());arr.values.emplace_back(False());obj.values["array"] = std::move(arr); 示例示例代码测试构建json对象，访问json对象，以及序列化json 对象。示例代码如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344/************************************************************************* &gt; File Name: test_json.cpp &gt; Author: ce39906 &gt; Mail: ce39906@163.com &gt; Created Time: 2018-07-31 19:26:17 ************************************************************************/#include &lt;iostream&gt;#include "json.hpp"using namespace json;int main()&#123; Object obj; obj.values["string"] = "v1"; obj.values["bool"] = True(); obj.values["null"] = Null(); obj.values["number"] = Number(9); Array arr; arr.values.emplace_back(Number(1.02)); arr.values.emplace_back(Number(2.2)); arr.values.emplace_back(Number(3)); arr.values.emplace_back(True()); arr.values.emplace_back(False()); obj.values["array"] = std::move(arr); // json access std::cout &lt;&lt; "Test json access.\n"; const auto&amp; arr1 = access::asArray(obj["array"]); std::cout &lt;&lt; "first number in arr is " &lt;&lt; access::asNumber(arr1.front()).value &lt;&lt; std::endl; // json serialize to ostream std::cout &lt;&lt; "Test serialize to ostream.\n"; serialize(std::cout, obj); std::cout &lt;&lt; std::endl; // json serialize to string std::cout &lt;&lt; "Test serialize to string.\n"; std::string str; serialize(str, obj); std::cout &lt;&lt; str &lt;&lt; std::endl; return 0;&#125; 编译 g++ –std=c++11 test_json.cpp -o test_json 执行执行结果如下 TODO使用boost spirit 实现json反序列化 完整代码https://github.com/ce39906/self-practices/tree/master/cppcode/variant_json]]></content>
      <categories>
        <category>Backend Development</category>
      </categories>
      <tags>
        <tag>Boost</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c++11 右值引用,移动构造函数,emplace_back 解析]]></title>
    <url>%2F2018%2F07%2F26%2Fc-11-%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8-%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0-emplace-back-%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[右值引用C++11 引入了右值引用的概念，使用&amp;&amp;表示。首先简单介绍右值的概念，简单的将，所有赋值语句右侧的都是右值，或者说所有没有名字的变量都是右值。例如 1int a = 2; a 中就是一个左值，相对的，2 就是一个右值。关于右值更详细严谨的介绍见https://en.cppreference.com/w/cpp/language/value_category 移动构造函数在c++11 之前，类包括构造函数，析构函数，拷贝构造函数，赋值构造函数。对于存在指针变量的类来讲，其拷贝构造函数，赋值构造函数必须实现指针变量的深拷贝，这可能会涉及到比较耗时的操作(比如string 类存储了一个超长字符串，在调用其拷贝构造或赋值构造时需要超长字符串的拷贝)。移动构造函数相对拷贝构造函数和赋值构造函数而言不会进行成员变量的深拷贝而是交换其所有权，这样就避免的拷贝时带来的性能损耗。移动构造的函数声明如下 1class_name ( class_name &amp;&amp; )； emplace_backc++11 容器新增了 emplace_back, emplace等方法向容器中加入新的元素。以 vector 的emplace_back 为例，其函数声明如下 12template&lt; class... Args &gt;void emplace_back( Args&amp;&amp;... args ); emplcae_back 接收一个右值引用，调用其移动构造函数，将对象移动到容器中，而之前的push_back 是调用一次对象的拷贝构造函数， 容器中存储的是拷贝后的副本。 std::movestd::move 的作用是将左值转为右值引用类型。 示例示例代码测试了 移动构造函数，emplace_back, push_back, std::move 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586/************************************************************************* &gt; File Name: emplace.cpp &gt; Author: ce39906 &gt; Mail: ce39906@163.com &gt; Created Time: 2018-07-26 15:03:11 ************************************************************************/#include &lt;vector&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;class A&#123; public: A (const int size) : size(size) &#123; if (size) &#123; data = new char[size]; &#125; std::cout &lt;&lt; "I'm constructor.\n"; &#125; A (const A&amp; other) &#123; size = other.size; data = new char[size]; memcpy(data, other.data, size * sizeof(char)); std::cout &lt;&lt; "I'm copy constructor.\n"; &#125; A (A&amp;&amp; other) &#123; size = other.size; data = other.data; other.size = 0; other.data = nullptr; std::cout &lt;&lt; "I'm move constructor.\n"; &#125; private: int size; char* data = nullptr;&#125;;int main()&#123; std::vector&lt;A&gt; vec; vec.reserve(1024); A tmp(5); std::cout &lt;&lt; "push_back a left value.\n"; vec.push_back(tmp); std::cout &lt;&lt; "push_back a right value with std::move.\n"; vec.push_back(std::move(tmp)); std::cout &lt;&lt; "emplace_back a left value.\n"; vec.emplace_back(tmp); std::cout &lt;&lt; "emplace_back a right value with std::move.\n"; vec.emplace_back(std::move(tmp)); std::cout &lt;&lt; "emplace_back in place.\n"; vec.emplace_back(5); std::cout &lt;&lt; "=========================================\n"; std::cout &lt;&lt; "test with buildin string move and emplace_back\n"; std::cout &lt;&lt; "=========================================\n"; std::vector&lt;std::string&gt; str_vec; str_vec.reserve(1024); std::string str = "I'd like to be inserted to a container"; std::cout &lt;&lt; "before emplace_back to vec, str is:\n"; std::cout &lt;&lt; str &lt;&lt; std::endl; std::cout &lt;&lt; "c_str address is " &lt;&lt; (void*) str.c_str() &lt;&lt; std::endl; str_vec.emplace_back(std::move(str)); std::cout &lt;&lt; "after emplace_back to vec, str is:\n"; std::cout &lt;&lt; str &lt;&lt; std::endl; std::cout &lt;&lt; "c_str address is " &lt;&lt; (void*) str.c_str() &lt;&lt; std::endl; std::cout &lt;&lt; "c_str address of the string in container is " &lt;&lt; (void*) str_vec.front().c_str() &lt;&lt; std::endl;&#125; 编译代码 g++ –std=c++11 emplace.cpp -o emplace 执行，输出结果如下 从执行结果中，我们可以得出以下结论 push_back 可以接收左值也可以接受右值，接收左值时使用拷贝构造，接收右值时使用移动构造 emplace_back 接收右值时调用类的移动构造 emplace_back 接收左值时，实际上的执行效果是先对传入的参数进行拷贝构造，然后使用拷贝构造后的副本，也就是说，emplace_back在接收一个左值的时候其效果和push_back一致！所以在使用emplace_back 时需要确保传入的参数是一个右值引用，如果不是，请使用std::move()进行转换 emplace_back 接收多个参数时，可以调用匹配的构造函数实现在容器内的原地构造 使用string 类验证了移动构造函数式对类成员所有权的传递，从上图中看到string 在插入前c_str的地址和使用emplace_back 移动到容器后的c_str的地址一致。并且移动后字符串c_str 的地址指向其他位置。]]></content>
      <categories>
        <category>Backend Development</category>
      </categories>
      <tags>
        <tag>c++11</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Trie C++ 实现与解析]]></title>
    <url>%2F2018%2F07%2F20%2FTrie-C-%E5%AE%9E%E7%8E%B0%E4%B8%8E%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[Trie tree 介绍trie 源自 retrieval ,中文称为前缀树或字典树。具体介绍见wiki trie C++ 实现以下trie实现支持任何语言(Chinese,English,Janpanse…)。主要包括以下三个接口 123456// 使用一组词初始化trie.void Init(const std::vector&lt;std::string&gt;&amp; dict);// 在trie 中查找word是否存在.bool Lookup(const std::string&amp; word);// 返回在trie中所有以word为前缀的词.std::vector&lt;std::string&gt; Suggest(const std::string&amp; word); 具体代码实现如下trie.hpp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566/************************************************************************* &gt; File Name: trie.hpp &gt; Author: ce39906 &gt; Mail: ce39906@163.com &gt; Created Time: 2018-07-19 11:12:09 ************************************************************************/#ifndef TRIE_HPP#define TRIE_HPP#include &lt;vector&gt;#include &lt;string&gt;namespace trie&#123;class Trie&#123; static constexpr size_t kAsciiCount = 256; struct TrieNode &#123; TrieNode(const char val) : val(val), is_end(false), childrens(kAsciiCount, nullptr) &#123; &#125; char val; bool is_end; std::vector&lt;TrieNode*&gt; childrens; &#125;; public: Trie() &#123; root = new TrieNode('0'); &#125; ~Trie() &#123; ReleaseTrie(root); &#125; Trie(const Trie&amp;) = delete; Trie&amp; operator = (const Trie&amp;) = delete; void Init(const std::vector&lt;std::string&gt;&amp; dict); bool Lookup(const std::string&amp; word) const; std::vector&lt;std::string&gt; Suggest(const std::string&amp; word) const; void PrintSuggs(const std::string&amp; word) const; private: void Insert(const std::string&amp; word); bool Search(const TrieNode* parent, const std::string&amp; word, const size_t idx) const; void Dfs(const TrieNode* cur, std::string&amp; word, std::vector&lt;std::string&gt;&amp; suggs) const; void ReleaseTrie(const TrieNode* root); TrieNode* root;&#125;;&#125; // ns trie#endif trie.cpp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155/************************************************************************* &gt; File Name: trie.cpp &gt; Author: ce39906 &gt; Mail: ce39906@163.com &gt; Created Time: 2018-07-19 14:04:15 ************************************************************************/#include "trie.hpp"#include &lt;iostream&gt;namespace trie&#123;void Trie::Init(const std::vector&lt;std::string&gt;&amp; dict)&#123; for (const std::string&amp; word : dict) &#123; Insert(word); &#125;&#125;bool Trie::Lookup(const std::string&amp; word) const&#123; return Search(root, word, 0);&#125;std::vector&lt;std::string&gt; Trie::Suggest(const std::string&amp; word) const&#123; std::vector&lt;std::string&gt; suggs; if (word.empty()) &#123; return suggs; &#125; // find prefix TrieNode* cur = root; // unsigned char range : 0 ~ 255 for (const unsigned char c : word) &#123; const std::vector&lt;TrieNode*&gt;&amp; childrens = cur-&gt;childrens; if (!childrens[c]) &#123; return suggs; &#125; cur = childrens[c]; &#125; if (!cur) &#123; return suggs; &#125; std::string prefix(word.begin(), word.end() - 1); Dfs(cur, prefix, suggs); return suggs;&#125;void Trie::Insert(const std::string&amp; word)&#123; if (word.empty()) return; TrieNode* cur = root; // unsigned char range : 0 ~ 255 for (const unsigned char c : word) &#123; if (!cur-&gt;childrens[c]) &#123; cur-&gt;childrens[c] = new TrieNode(c); &#125; cur = cur-&gt;childrens[c]; &#125; cur-&gt;is_end = true;&#125;bool Trie::Search(const TrieNode* parent, const std::string&amp; word, const size_t idx) const&#123; if (word.empty()) &#123; return false; &#125; const std::vector&lt;TrieNode*&gt;&amp; childrens = parent-&gt;childrens; // explicitly cast to unsigned char is needed const unsigned char c = word[idx]; TrieNode* cur = childrens[c]; if (!cur) &#123; return false; &#125; if (idx == word.size() - 1) &#123; return cur-&gt;is_end; &#125; return Search(cur, word, idx + 1);&#125;void Trie::Dfs(const TrieNode* cur, std::string&amp; word, std::vector&lt;std::string&gt;&amp; suggs) const&#123; if (cur-&gt;is_end) &#123; suggs.emplace_back(word + cur-&gt;val); &#125; word.push_back(cur-&gt;val); const std::vector&lt;TrieNode*&gt;&amp; childrens = cur-&gt;childrens; for (const TrieNode* children : childrens) &#123; if (children) &#123; Dfs(children, word, suggs); &#125; &#125; word.pop_back();&#125;void Trie::ReleaseTrie(const TrieNode* root)&#123; if (!root) return; bool no_children = true; const std::vector&lt;TrieNode*&gt;&amp; childrens = root-&gt;childrens; for (const TrieNode* children : childrens) &#123; if (children) &#123; no_children = false; ReleaseTrie(children); &#125; &#125; if (no_children) &#123; delete root; &#125;&#125;void Trie::PrintSuggs(const std::string&amp; word) const&#123; const auto quoted_string = [] (const std::string str) &#123; return "\"" + str + "\""; &#125;; const std::vector&lt;std::string&gt;&amp; suggs = Suggest(word); if (suggs.empty()) &#123; std::cout &lt;&lt; "No suggs for " &lt;&lt; quoted_string(word) &lt;&lt; std::endl; return; &#125; std::cout &lt;&lt; "Suggs for " &lt;&lt; quoted_string(word) &lt;&lt; " are :\n"; for (const std::string&amp; sugg : suggs) &#123; std::cout &lt;&lt; quoted_string(sugg) &lt;&lt; " "; &#125; std::cout &lt;&lt; std::endl;&#125;&#125; // ns trie 测试测试数据测试数据如下，本例中存储在文件trie_data 中国人民中午中国人中国梦伟大复兴2020中国制造中国制造2020军工etf北京北京天安门天气天气预报北京天气预报beijingbeijing tiananmen汉语韩国人韩国韩范美国热东京热苍井空苍老师机器学习机器人机器猫机器狗美团网美团外卖美团平台美团地图美团酒旅美团生鲜美团大象美团liuce美团ce39906be搜搜 测试代码test_trie.cpp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960/************************************************************************* &gt; File Name: test_trie.cpp &gt; Author: ce39906 &gt; Mail: ce39906@163.com &gt; Created Time: 2018-07-19 19:53:22 ************************************************************************/#include "trie.hpp"#include &lt;iostream&gt;#include &lt;fstream&gt;#include &lt;cstdlib&gt;#define NDEBUG#include &lt;cassert&gt;using namespace trie;void usage(const char* bin)&#123; std::cout &lt;&lt; bin &lt;&lt; " : Need a filename as a parameter.\n"; std::exit(EXIT_FAILURE);&#125;void readFile2Vector(const std::string&amp; file, std::vector&lt;std::string&gt;&amp; vec)&#123; std::fstream infile(file, std::ios_base::in); std::string line; while(getline(infile, line, '\n')) &#123; vec.emplace_back(line); &#125;&#125;int main(int argc, char* argv[])&#123; if (argc &lt; 2) &#123; usage(argv[0]); &#125; const std::string data_file(argv[1]); std::vector&lt;std::string&gt; dict; readFile2Vector(data_file, dict); Trie trie; trie.Init(dict); // test trie lookup function for (const std::string&amp; word : dict) &#123; (void) word; assert(trie.Lookup(word) == true); &#125; trie.PrintSuggs("美"); trie.PrintSuggs("be"); trie.PrintSuggs("中"); trie.PrintSuggs("苍"); trie.PrintSuggs("null"); return 0;&#125; 编译 g++ –std=c++11 -O2 trie.cpp test_trie.cpp -o trie 测试结果执行 ./trie trie_data github 地址https://github.com/ce39906/self-practices/tree/master/cppcode/trie]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>trie</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Implement Rand10() Using Rand7()]]></title>
    <url>%2F2018%2F07%2F18%2FLeetCode-Implement-Rand10-Using-Rand7%2F</url>
    <content type="text"><![CDATA[题目描述Given a function rand7 which generates a uniform random integer in the range 1 to 7, write a function rand10 which generates a uniform random integer in the range 1 to 10. Do NOT use system’s Math.random(). Example 1: Input: 1Output: [7] Example 2: Input: 2Output: [8,4] Example 3: Input: 3Output: [8,1,10] Note: rand7 is predefined.Each testcase has one argument: n, the number of times that rand10 is called. rand7 返回均匀分布的1到7，要求根据rand7 实现一个rand10, 要求返回均匀分布的1到10。解决思路是先构建一个randN, N 要求是 10 的整数倍。由randN % 10 可以得到rand10。由rand7 可以得到 rand49 , rand49 通过过滤掉大于等于40 的可以得到 rand40, 进而可以得到rand10。综上，解决思路如下： rand7 -&gt; rand49 -&gt; rand40 -&gt; rand10 此解决方案可以推广到所有randN 生成randM (N &lt; M) 的场景。 C++ 实现123456789101112131415161718192021222324252627// The rand7() API is already defined for you.// int rand7();// @return a random integer in the range 1 to 7class Solution &#123;public: int rand10() &#123; const int num = rand40(); return num % 10 + 1; &#125;private: // return 0 ~ 48 randomly int rand49() &#123; return 7 * (rand7() - 1) + rand7() - 1; &#125; // return 0 ~ 39 randomly int rand40() &#123; int num = rand49(); while(num &gt;= 40) &#123; num = rand49(); &#125; return num; &#125;&#125;;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Reordered Power of 2]]></title>
    <url>%2F2018%2F07%2F17%2FLeetCode-Reordered-Power-of-2%2F</url>
    <content type="text"><![CDATA[题目描述Starting with a positive integer N, we reorder the digits in any order (including the original order) such that the leading digit is not zero. Return true if and only if we can do this in a way such that the resulting number is a power of 2. Example 1: Input: 1Output: true Example 2: Input: 10Output: false Example 3: Input: 16Output: true Example 4: Input: 24Output: false Example 5: Input: 46Output: true Note:1 &lt;= N &lt;= 10^9 输入是正整数，要求 求对数字排列后得到的数是否存在一个是2的整数次幂。解决思路是将N转为string,然后利用stl 提供的next_permutation 获得所有排列，遍历所有情况检查是否存在2的整数次幂。 C++ 实现123456789101112131415161718192021222324252627class Solution &#123;public: bool reorderedPowerOf2(int N) &#123; string str_num = to_string(N); // 使用next_permutation 之前应排序 sort(str_num.begin(), str_num.end()); do &#123; if (str_num.front() == '0') &#123; continue; &#125; if (isPowerOf2(stoi(str_num))) &#123; return true; &#125; &#125; while(next_permutation(str_num.begin(), str_num.end())); return false; &#125;private: bool isPowerOf2(const int num) const &#123; return (num &amp; num - 1) == 0; &#125;&#125;;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Split Linked List in Parts]]></title>
    <url>%2F2018%2F07%2F16%2FLeetCode-Split-Linked-List-in-Parts%2F</url>
    <content type="text"><![CDATA[题目描述Given a (singly) linked list with head node root, write a function to split the linked list into k consecutive linked list “parts”. The length of each part should be as equal as possible: no two parts should have a size differing by more than 1. This may lead to some parts being null. The parts should be in order of occurrence in the input list, and parts occurring earlier should always have a size greater than or equal parts occurring later. Return a List of ListNode’s representing the linked list parts that are formed. Examples 1-&gt;2-&gt;3-&gt;4, k = 5 // 5 equal parts [ [1], [2], [3], [4], null ]Example 1: Input:root = [1, 2, 3], k = 5Output: [[1],[2],[3],[],[]]Explanation:The input and each element of the output are ListNodes, not arrays.For example, the input root has root.val = 1, root.next.val = 2, \root.next.next.val = 3, and root.next.next.next = null.The first element output[0] has output[0].val = 1, output[0].next = null.The last element output[4] is null, but it’s string representation as a ListNode is []. Example 2: Input:root = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], k = 3Output: [[1, 2, 3, 4], [5, 6, 7], [8, 9, 10]]Explanation:The input has been split into consecutive parts with size difference at most 1, and earlier parts are a larger size than the later parts.Note: The length of root will be in the range [0, 1000].Each value of a node in the input will be an integer in the range [0, 999].k will be an integer in the range [1, 50].输入是一个链表，要求把链表尽量平分为k 份，如果不能完全平分，要求划分后的每部分最多相差不超过一个且size 更大的部分处于相对前面的位置。解题思路是遍历一遍求出链表的长度，然后求出每部分的长度以及不能平分的长度。顺序遍历链表，按照分组要求不断截断链表后插入。 C++ 实现12345678910111213141516171819202122232425262728293031323334353637383940/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;ListNode*&gt; splitListToParts(ListNode* root, int k) &#123; int size = 0; ListNode* x = root; while(x) &#123; size++; x = x-&gt;next; &#125; const int part_size = size / k; const int left = size % k; // 直接初始化大小为k的数组，这样不需要对part_size为0的情况进行特殊处理 vector&lt;ListNode*&gt; res(k); for (int i = 0; i &lt; k &amp;&amp; root; i++) &#123; res[i] = root; // 前面几个部分需要均摊掉left的部分，每部分消费一个 for (int j = 1; j &lt; part_size + (i &lt; left); j++) &#123; root = root-&gt;next; &#125; ListNode* next = root-&gt;next; // 截断链表 root-&gt;next = nullptr; // 更新游标位置 root = next; &#125; return res; &#125;&#125;;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Pyramid Transition Matrix]]></title>
    <url>%2F2018%2F07%2F13%2FLeetCode-Pyramid-Transition-Matrix%2F</url>
    <content type="text"><![CDATA[题目描述We are stacking blocks to form a pyramid. Each block has a color which is a one letter string, like &#39;Z&#39;. For every block of color C we place not in the bottom row, we are placing it on top of a left block of color A and right block of color B. We are allowed to place the block there only if (A, B, C) is an allowed triple. We start with a bottom row of bottom, represented as a single string. We also start with a list of allowed triples allowed. Each allowed triple is represented as a string of length 3. Return true if we can build the pyramid all the way to the top, otherwise false. Example 1:1234567891011Input: bottom = "XYZ", allowed = ["XYD", "YZE", "DEA", "FFF"]Output: trueExplanation:We can stack the pyramid like this: A / \ D E / \ / \X Y ZThis works because ('X', 'Y', 'D'), ('Y', 'Z', 'E'), and ('D', 'E', 'A') are allowed triples. Example 2:12345Input: bottom = "XXYX", allowed = ["XXX", "XXY", "XYX", "XYY", "YXZ"]Output: falseExplanation:We can't stack the pyramid to the top.Note that there could be allowed triples (A, B, C) and (A, B, D) with C != D. Note:bottom will be a string with length in range [2, 8].allowed will have length in range [0, 200].Letters in all strings will be chosen from the set {‘A’, ‘B’, ‘C’, ‘D’, ‘E’, ‘F’, ‘G’}. 输入是一个叫bottom 的字符串以及allowed 数组，bottom 字符串代表金字塔的最底层，allowed 数组给出了所有可能的金字塔的构建方法。给定这两个数组后判断是否能建成金字塔。解题思路是使用递归的方式，每次递归构建出上一层，递归的终止条件是当前层只有一个字符。需要注意的是，每次递归时需要使用dfs 搜索找出当前层所有可能的构造方式。具体见实现以及注释。 C++ 实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172class Solution &#123;public: bool pyramidTransition(string bottom, vector&lt;string&gt;&amp; allowed) &#123; // 构建allowed_map, hash_map 的key是小金子塔的底部，value 是所有允许的顶部的集合 for (const string&amp; str : allowed) &#123; const string&amp; key = str.substr(0, 2); const char value = str.back(); if (allowed_map.count(key)) &#123; allowed_map[key].insert(value); &#125; else &#123; allowed_map[key] = &#123;value&#125;; &#125; &#125; // 递归搜索 return dfs(bottom); &#125;private: unordered_map&lt;string, set&lt;char&gt;&gt; allowed_map; bool dfs(const string&amp; bottom) &#123; // 终止条件 if (bottom.size() == 1) return true; // 首先判断上一层无法构建的情况，如果无法构建直接return false for(size_t i = 0; i &lt; bottom.size() - 1; i++) &#123; if (!allowed_map.count(bottom.substr(i, 2))) &#123; return false; &#125; &#125; vector&lt;string&gt; candidates; candidates.reserve(bottom.size() - 1); string path; //使用dfs的方式找到上一层所有可能结果 getCandidates(bottom, 0, path, candidates); //遍历所有结果进行递归搜索 for(const string&amp; candidate : candidates) &#123; if (dfs(candidate)) &#123; return true; &#125; &#125; return false; &#125; // dfs的方式找到所有可能的上一层的结果 // 结果存储到 candidates 数组中 // cur 存储当前dfs的进度 void getCandidates(const string&amp; bottom, size_t idx, string&amp; cur, vector&lt;string&gt;&amp; candidates) &#123; if (idx == bottom.size() - 1) &#123; candidates.push_back(cur); return; &#125; for(const char c : allowed_map.at(bottom.substr(idx, 2))) &#123; cur += c; getCandidates(bottom, idx + 1, cur, candidates); cur.pop_back(); &#125; &#125;&#125;;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++ 将git提交信息编译到可执行文件]]></title>
    <url>%2F2018%2F07%2F12%2FC-%E5%B0%86git%E6%8F%90%E4%BA%A4%E4%BF%A1%E6%81%AF%E7%BC%96%E8%AF%91%E5%88%B0%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[在生产环境中经常需要查看在线上运行的程序对应git的哪次提交。我们可以在编译时获取git 最后一次提交信息GIT_SHA1 宏，C++ 程序通过访问GIT_SHA1宏可以输出和git仓库的提交信息。使用Makefile时，在Makefile 添加以下1CPPFLAGS+=-DGIT_SHA1="$(shell git log --format='[sha1]:%h [author]:%cn [time]:%ci [commit]:%s [branch]:%d' -1)" 使用cmake123456exec_program( "git" $&#123;CMAKE_CURRENT_SOURCE_DIR&#125; ARGS "log --format='[sha1]:%h [author]:%cn [time]:%ci [commit]:%s [branch]:%d' -1" OUTPUT_VARIABLE VERSION_SHA1 )add_definitions( -DGIT_SHA1="$&#123;VERSION_SHA1&#125;" ) 如果不想直接使用宏变量，可以使用cmake 提供的configure_file 访问CMakeLists.txt 中定义的各种变量.configure_file的功能是根据 xxx.hpp.in文件中定义的宏创建 xxx.hpp 文件。关于configure_file 的说明见 configure_file]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>compile</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Kth Smallest Element in a Sorted Matrix]]></title>
    <url>%2F2018%2F07%2F12%2FLeetCode-Kth-Smallest-Element-in-a-Sorted-Matrix%2F</url>
    <content type="text"><![CDATA[题目描述Given a n x n matrix where each of the rows and columns are sorted in ascending order, find the kth smallest element in the matrix. Note that it is the kth smallest element in the sorted order, not the kth distinct element. Example: matrix = [ [ 1, 5, 9], [10, 11, 13], [12, 13, 15]],k = 8,return 13. Note:You may assume k is always valid, 1 ≤ k ≤ n2.输入是一个二维矩阵，二维矩阵的每行每列都有序，要求求出矩阵所有数值的第k 小的数。解题思路是使用一个优先队列(堆)存储矩阵的数值，优先队列pop (k - 1) 次后，位于堆顶的值就是第k 小的数值。由于二维矩阵的每行每列都有序，因此我们使用矩阵的第一行或者第一列初始化堆，每pop 一个节点，将节点下侧(右侧)的数入堆。需要注意的是 c++ 中提供的priority_queue 默认是大根堆，需要重载节点的比较运算符实现小根堆的功能。 C++ 实现12345678910111213141516171819202122232425262728293031323334353637383940class Solution &#123;public: int kthSmallest(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int k) &#123; const size_t m = matrix.size(); if (matrix.empty()) return -1; const size_t n = matrix[0].size(); struct Node &#123; size_t x; size_t y; int val; bool operator &lt; (const Node&amp; other) const &#123; return val &gt;= other.val; &#125; &#125;; priority_queue&lt;Node&gt; pq; for (size_t j = 0; j &lt; n; j++) &#123; pq.push(&#123;0, j, matrix[0][j]&#125;); &#125; for (int i = 0; i &lt; k - 1; i++) &#123; const Node&amp; top = pq.top(); const size_t x = top.x; const size_t y = top.y; pq.pop(); if (x == m - 1) &#123; continue; &#125; pq.push(&#123;x + 1, y, matrix[x + 1][y]&#125;); &#125; return pq.top().val; &#125;&#125;;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[rundeck CentOS 部署以及配置]]></title>
    <url>%2F2018%2F07%2F11%2Frundeck-CentOS-%E9%83%A8%E7%BD%B2%E4%BB%A5%E5%8F%8A%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[简介rundeck 是一个在多机器环境下实现自动化执行以及调度任务的开源工具。rundeck 提供了web 界面，用户可以通过web 界面定制任务，调度，观察节点的执行情况。 安装与配置安装rundeck 的官网位置rundeckrundeck 运行依赖于java，因此需要首先安装并配置java1yum install java-1.8.0-openjdk java-1.8.0-openjdk-devel -y 在 /etc/profile.d 目录下创建 java.sh， 在java.sh 中写入12345#!/bin/bashJAVA_HOME=/usr/bin/javaPATH=$JAVA_HOME/bin:$PATHexport PATH JAVA_HOMEexport CLASSPATH=. 为java.sh 添加执行权限1chmod +x /etc/profile.d/java.sh 使java环境变量生效1source /etc/profile.d/java.sh 使用yum 安装rundeck12rpm -Uvh http://repo.rundeck.org/latest.rpmyum install rundeck 如果使用yum 安装失败，可以使用rpm 的方式安装。123wget http://download.rundeck.org/rpm/rundeck-2.11.5-1.56.GA.noarch.rpmwget http://download.rundeck.org/rpm/rundeck-config-2.11.5-1.56.GA.noarch.rpmrpm -i rundeck-2.11.5-1.56.GA.noarch.rpm rundeck-config-2.11.5-1.56.GA.noarch.rpm 启动rundeck 服务1/etc/init.d/rundeckd start 检查rundeck 是否启动12ps -ef | grep rundecknetstat -anp | grep 4440 配置更改默认用户名密码rundeck 默认用户名密码都是admin，可以更改/etc/rundeck/realm.properties 文件中相应位置。更改后重启rundeck 服务1service rundeckd restart 更改根url设置如果只在部署rundeck的机器访问rundeck web界面则不需要12vim /etc/rundeck/rundeck-config.propertiesvim /etc/rundeck/framework.properties 把这两个文件中所有的localhost 更改为本机的ip地址然后保存 添加node节点 在下面示例中展示 示例在浏览器中输入rundeck 地址，以我部署的服务为例http://10.4.227.26:4440/默认输入 admin admin 登录, 登录后新建一个project输入新建project 的名称以及描述其他按照默认选择，以test 为例，滚动到页面最后点击create 创建下一步继续按照默认配置保存新建工程后，我们查看工程下的node 节点可以看到默认情况工程下只有server node 节点。为了添加其他节点,我们进入到 /var/rundeck/projects/test/etc 路径，编辑resources.xml 文件，默认情况resources.xml 下只有server node， 如下图12345&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project&gt; &lt;node name="10.4.227.26" description="Rundeck server node" tags="" hostname="10.4.227.26" osArch="amd64" osFamily="unix" osName="Linux" osVersion="3.10.0-123.el7.x86_64" username="rundeck"/&gt;&lt;/project&gt; 以10.4.227.21为例，添加node节点，添加client node 节点后配置如下123456&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project&gt; &lt;node name="10.4.227.26" description="Rundeck server node" tags="" hostname="10.4.227.26" osArch="amd64" osFamily="unix" osName="Linux" osVersion="3.10.0-123.el7.x86_64" username="rundeck"/&gt; &lt;node name="10.4.227.21" description="Rundeck client node" tags="" hostname="10.4.227.21" osArch="amd64" osFamily="unix" osName="Linux" osVersion="3.10.0-123.el7.x86_64" username="ce39906"/&gt;&lt;/project&gt; 新增的hostname username 需要配置正确。完成配置后，刷新web 界面，可以看到新增的10.4.227.21仅仅在rundeck server 添加如下配置不能实现rundeck server 到client 的无密码连接。因此，我们登录到rundeck client机器(10.4.227.21)，将 rundeck server(10.4.227.26) /var/lib/rundeck/.ssh/id_rsa.pub 的内容追加到 client 机器中的 ~/.ssh/authorized_keys以上就完成rundeck node 节点的添加。下面我们测试通过web 界面配置在指定的node 节点上执行命令选择所有节点后，我们以执行 ls /tmp 为例点击右上角的执行，执行结果如下除了简单的命令，rundeck job 支持实现更加复杂的任务。我们以执行脚本为例进行说明。首先新建一个job配置job 的名称以及描述在step 中选择执行脚本任务点击后编辑脚本并保存选择执行job 的node, 这里我们选择client node(10.4.227.21) 执行其他使用默认配置，点击创建，创建完成后执行job执行结果如下可以看到在rundeck client 上执行了job 指定的脚本(执行 whoami 以及 ifconfig) 思考rundeck 在完成初始配置后可以很方便用于在一组机器上执行各种任务，这种场景在生产环境以及日常运维中非常常见，类似的工具还有jenkins前段时间公司部门要求开发自动部署工具，全套使用脚本+ ssh 的方式，健壮性和稳定性都存在不少问题。类似的自动部署的功能完全可以使用rundeck 配置job 的方式执行而不需要重新造轮子再搞一套鸡肋的东西。]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>rundeck</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Smallest Subtree with all the Deepest Nodes]]></title>
    <url>%2F2018%2F07%2F09%2FLeetCode-Smallest-Subtree-with-all-the-Deepest-Nodes%2F</url>
    <content type="text"><![CDATA[题目描述Given a binary tree rooted at root, the depth of each node is the shortest distance to the root. A node is deepest if it has the largest depth possible among any node in the entire tree. The subtree of a node is that node, plus the set of all descendants of that node. Return the node with the largest depth such that it contains all the deepest nodes in it’s subtree. Example 1: Input: [3,5,1,6,2,0,8,null,null,7,4]Output: [2,7,4]Explanation:We return the node with value 2, colored in yellow in the diagram.The nodes colored in blue are the deepest nodes of the tree.The input “[3, 5, 1, 6, 2, 0, 8, null, null, 7, 4]” is a serialization of the given tree.The output “[2, 7, 4]” is a serialization of the subtree rooted at the node with value 2.Both the input and output have TreeNode type. 题目描述比较绕，其实实际意思比较直白，要求求出具有最高高度的子树的根节点，或者说是求具有最高高度的非叶子节点。解决方案可以使用dfs搜索，每次搜索返回当前的根节点以及当前最大深度，如果左右子树深度一样，则返回根节点且深度加一，如果左子树的深度更深，返回左子树的根并且深度加一。相应的，右子树的深度更深，返回右子树的根并且深度加一。 C++ 实现1234567891011121314151617181920212223242526/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: TreeNode* subtreeWithAllDeepest(TreeNode* root) &#123; const pair&lt;int, TreeNode*&gt; res = dfs(root); return res.second; &#125;private: pair&lt;int, TreeNode*&gt; dfs(TreeNode* root) &#123; if (!root) return &#123;0, NULL&#125;; const pair&lt;int, TreeNode*&gt; left = dfs(root-&gt;left); const pair&lt;int, TreeNode*&gt; right = dfs(root-&gt;right); if (left.first == right.first) return &#123;left.first + 1, root&#125;; if (left.first &lt; right.first) return &#123;right.first + 1, right.second&#125;; return &#123;left.first + 1, left.second&#125;; &#125;&#125;;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Implement Magic Dictionary]]></title>
    <url>%2F2018%2F07%2F06%2FLeetCode-Implement-Magic-Dictionary%2F</url>
    <content type="text"><![CDATA[题目描述Implement a magic directory with buildDict, and search methods. For the method buildDict, you’ll be given a list of non-repetitive words to build a dictionary. For the method search, you’ll be given a word, and judge whether if you modify exactly one character into another character in this word, the modified word is in the dictionary you just built. Example 1: Input: buildDict([“hello”, “leetcode”]), Output: NullInput: search(“hello”), Output: FalseInput: search(“hhllo”), Output: TrueInput: search(“hell”), Output: FalseInput: search(“leetcoded”), Output: False Note:You may assume that all the inputs are consist of lowercase letters a-z.For contest purpose, the test data is rather small by now. You could think about highly efficient algorithm after the contest.Please remember to RESET your class variables declared in class MagicDictionary, as static/class variables are persisted across multiple test cases. Please see here for more details. 题目要求建立一个字典，查找一个word 改变并且只改变一个字符后在字典中是否存在。解决思路是根据字符串的大小建立索引，如果字符串的大小在索引不存在则直接返回false, 如果存在则遍历字典中和待查询字符同样大小的字符串集合，查看是否有满足改变只改变一个字符后相等的字符串。 C++ 实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768class MagicDictionary &#123;public: /** Initialize your data structure here. */ MagicDictionary() &#123; &#125; /** Build a dictionary through a list of words */ void buildDict(vector&lt;string&gt; dict) &#123; for (const string&amp; str : dict) &#123; const size_t size = str.size(); if (size_2_strs.count(size)) &#123; size_2_strs[size].emplace_back(str); &#125; else &#123; size_2_strs[size] = vector&lt;string&gt;(1, str); &#125; &#125; &#125; /** Returns if there is any word in the trie that equals to the given word after modifying exactly one character */ bool search(string word) &#123; const size_t size = word.size(); if (!size_2_strs.count(size)) &#123; return false; &#125; const vector&lt;string&gt;&amp; strs = size_2_strs.at(size); for (const string&amp; str : strs) &#123; if (modifyOneEqual(str, word)) &#123; return true; &#125; &#125; return false; &#125;private: unordered_map&lt;size_t, vector&lt;string&gt;&gt; size_2_strs; bool modifyOneEqual(const string&amp; one, const string&amp; another) &#123; const size_t size = one.size(); int diff_num = 0; for (size_t i = 0; i &lt; size; i++) &#123; if (one[i] != another[i]) &#123; diff_num++; &#125; if (diff_num &gt; 1) &#123; return false; &#125; &#125; return diff_num == 1; &#125;&#125;;/** * Your MagicDictionary object will be instantiated and called as such: * MagicDictionary obj = new MagicDictionary(); * obj.buildDict(dict); * bool param_2 = obj.search(word); */ 该实现响应时间击败Leetcode 上其他100%]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] House Robber III]]></title>
    <url>%2F2018%2F07%2F05%2FLeetCode-House-Robber-III%2F</url>
    <content type="text"><![CDATA[题目描述The thief has found himself a new place for his thievery again. There is only one entrance to this area, called the “root.” Besides the root, each house has one and only one parent house. After a tour, the smart thief realized that “all houses in this place forms a binary tree”. It will automatically contact the police if two directly-linked houses were broken into on the same night. Determine the maximum amount of money the thief can rob tonight without alerting the police. Example 1:12345 3 / \2 3 \ \ 3 1 Maximum amount of money the thief can rob = 3 + 3 + 1 = 7.Example 2:12345 3 / \ 4 5 / \ \1 3 1 Maximum amount of money the thief can rob = 4 + 5 = 9.Credits:Special thanks to @dietpepsi for adding this problem and creating all test cases. 输入是一个二叉树，要求求出不具有父子关系的最大节点集合。解题思路如下最大值有以下两种可能 选择当前根节点： 当前节点数值 + 左子树最大值(不选择左子树的根节点) + 右子树最大值(不选择右子树的根节点) 不选择当前根节点: 左子树最大值 + 右子树最大值 我们可以使用递归的方式实现。每次递归运算返回两个值，一个代表选取当前根节点的最大值，一个代表不选取当前根节点的最大值。最后递归结束后，返回两个数值的最大值。 C++ 实现1234567891011121314151617181920212223242526272829303132/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: int rob(TreeNode* root) &#123; if (root == NULL) return 0; const pair&lt;int, int&gt; rob_or_not = robOrNot(root); return max(rob_or_not.first, rob_or_not.second); &#125;private: // pair.first 存储不选取当前根节点的结果 // pair.second 存储选取当前根节点的结果 pair&lt;int, int&gt; robOrNot(TreeNode* root) &#123; if (root == NULL) return &#123;0, 0&#125;; const pair&lt;int, int&gt; left = robOrNot(root-&gt;left); const pair&lt;int, int&gt; right = robOrNot(root-&gt;right); // 选择当前根节点的结果，由三部分组成 int rob_root = left.second + right.second + root-&gt;val; // 不选择当前根节点的结果，由两部分组成 int not_rob_root = max(left.first, left.second) + max(right.first, right.second); return &#123;rob_root, not_rob_root&#125;; &#125;&#125;;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Print Binary Tree]]></title>
    <url>%2F2018%2F07%2F04%2FLeetCode-Print-Binary-Tree%2F</url>
    <content type="text"><![CDATA[题目描述Print a binary tree in an m*n 2D string array following these rules: The row number m should be equal to the height of the given binary tree.The column number n should always be an odd number.The root node’s value (in string format) should be put in the exactly middle of the first row it can be put. The column and the row where the root node belongs will separate the rest space into two parts (left-bottom part and right-bottom part). You should print the left subtree in the left-bottom part and print the right subtree in the right-bottom part. The left-bottom part and the right-bottom part should have the same size. Even if one subtree is none while the other is not, you don’t need to print anything for the none subtree but still need to leave the space as large as that for the other subtree. However, if two subtrees are none, then you don’t need to leave space for both of them.Each unused space should contain an empty string “”.Print the subtrees following the same rules.Example 1:1234567Input: 1 / 2Output:[["", "1", ""], ["2", "", ""]] Example 2:12345678910Input: 1 / \ 2 3 \ 4Output:[["", "", "", "1", "", "", ""], ["", "2", "", "", "", "3", ""], ["", "", "4", "", "", "", ""]] Example 3:12345678910111213Input: 1 / \ 2 5 / 3 /4Output:[["", "", "", "", "", "", "", "1", "", "", "", "", "", "", ""] ["", "", "", "2", "", "", "", "", "", "", "", "5", "", "", ""] ["", "3", "", "", "", "", "", "", "", "", "", "", "", "", ""] ["4", "", "", "", "", "", "", "", "", "", "", "", "", "", ""]] Note: The height of binary tree is in the range of [1, 10].输入是一个二叉树，要求将二叉树的打印到一个二维数组中，二维数组每行对应二叉树的每行，二维数组行数对应二叉树的高度。解决思路是首先求得二叉树的高度，提前分配出二维数组，然后递归二叉树在二维数组中位置填写数值。递归每向下一次，二维数组中的行的位置就加一，列的位置是每次区间的中间值。如果是递归左子树的话就是左半区间，如果递归右子树的话就是右半区间。 C++ 实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;vector&lt;string&gt;&gt; printTree(TreeNode* root) &#123; if (!root) &#123; return vector&lt;vector&lt;string&gt;&gt;&#123;&#125;; &#125; const size_t row = getTreeHeight(root); const size_t col = (1 &lt;&lt; row) - 1; vector&lt;vector&lt;string&gt;&gt; res(row, vector&lt;string&gt;(col, "")); populateTree(root, row, 0, 0, col - 1, res); return res; &#125;private: size_t getTreeHeight(const TreeNode* root) &#123; if (root == NULL) &#123; return 0; &#125; return 1 + max(getTreeHeight(root-&gt;left), getTreeHeight(root-&gt;right)); &#125; void populateTree(const TreeNode* root, const size_t max_row, const size_t row, const size_t left, const size_t right, vector&lt;vector&lt;string&gt;&gt;&amp; res) &#123; if (!root || row == max_row) &#123; return; &#125; res[row][(left + right) &gt;&gt; 1] = to_string(root-&gt;val); populateTree(root-&gt;left, max_row, row + 1, left, ((left + right) &gt;&gt; 1) - 1, res); populateTree(root-&gt;right, max_row, row + 1, ((left + right) &gt;&gt; 1) + 1, right, res); &#125;&#125;;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Lemonade Change]]></title>
    <url>%2F2018%2F07%2F02%2FLeetCode-Lemonade-Change%2F</url>
    <content type="text"><![CDATA[题目描述At a lemonade stand, each lemonade costs $5. Customers are standing in a queue to buy from you, and order one at a time (in the order specified by bills). Each customer will only buy one lemonade and pay with either a \$5, \$10, or \$20 bill. You must provide the correct change to each customer, so that the net transaction is that the customer pays \$5. Note that you don’t have any change in hand at first. Return true if and only if you can provide every customer with correct change. Example 1: Input: [5,5,5,10,20]Output: trueExplanation:From the first 3 customers, we collect three $5 bills in order.From the fourth customer, we collect a \$10 bill and give back a \$5.From the fifth customer, we give a \$10 bill and a \$5 bill.Since all customers got correct change, we output true. Example 2: Input: [5,5,10]Output: true Example 3: Input: [10,10]Output: false Example 4: Input: [5,5,10,10,20]Output: falseExplanation:From the first two customers in order, we collect two \$5 bills.For the next two customers in order, we collect a \$10 bill and give back a \$5 bill.For the last customer, we can’t give change of \$15 back because we only have two \$10 bills.Since not every customer received correct change, the answer is false. Note: 0 &lt;= bills.length &lt;= 10000bills[i] will be either 5, 10, or 20. 有一个柠檬水摊，每瓶柠檬水售价5刀，货主只接收 5，10，20 的现金，问题是摊主是否可以按照购买的顺序完成找零。解决思路是使用两个变量分别记录5元现金和10元现金的张数，每次交易的时候判断是否可以完成找零并更新现金数目 C++实现1234567891011121314151617181920212223242526272829303132333435363738394041class Solution &#123;public: bool lemonadeChange(vector&lt;int&gt;&amp; bills) &#123; unsigned five_cash_cnt = 0; unsigned ten_cash_cnt = 0; for (const int bill : bills) &#123; switch (bill) &#123; case 5: five_cash_cnt++; break; case 10: if (!five_cash_cnt) &#123; return false; &#125; five_cash_cnt--; ten_cash_cnt++; break; case 20: if (ten_cash_cnt &amp;&amp; five_cash_cnt) &#123; ten_cash_cnt--; five_cash_cnt--; &#125; else if (five_cash_cnt &gt; 2) &#123; five_cash_cnt -= 3; &#125; else &#123; return false; &#125; break; &#125; &#125; return true; &#125;&#125;;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++ cout打印uint8_t的正确方式]]></title>
    <url>%2F2018%2F06%2F29%2FC-cout%E6%89%93%E5%8D%B0uint8-t%E7%9A%84%E6%AD%A3%E7%A1%AE%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[问题现象编译运行以下代码123456789101112131415/************************************************************************* &gt; File Name: cout_uint8.cpp &gt; Author: ce39906 &gt; Mail: ce39906@163.com &gt; Created Time: 2018-06-29 13:50:53 ************************************************************************/#include &lt;cstdint&gt;#include &lt;iostream&gt;int main()&#123; std::uint8_t uint8_num = 10; std::cout &lt;&lt; "uint8_t num is " &lt;&lt; uint8_num &lt;&lt; std::endl; return 0;&#125; 编译1g++ cout_uint8.cpp --std=c++11 -o cout_uint8 运行得到的输出如下cout没有正确打印数字10产生这种情况的原因是很多c++ 实现中 uint8_t 是 unsigned char 的 typedef。因此cout 实际调用的函数是 ostream&amp; operator&lt;&lt;(ostream&amp;, unsigned char) ，因此实际的执行结果是打印对应的ASCII 码字符，而其字符是不可以打印的。 解决方案将uint8_t 转化为unsigned 类型使用一元运算符+(和- 运算符对应)测试代码如下12345678910111213141516171819/************************************************************************* &gt; File Name: cout_uint8.cpp &gt; Author: ce39906 &gt; Mail: ce39906@163.com &gt; Created Time: 2018-06-29 13:50:53 ************************************************************************/#include &lt;cstdint&gt;#include &lt;iostream&gt;#include &lt;typeinfo&gt;int main()&#123; std::uint8_t uint8_num = 10; std::cout &lt;&lt; "uint8_t num is " &lt;&lt; uint8_num &lt;&lt; std::endl; std::cout &lt;&lt; "after cast to unsigned, uint8_t num is " &lt;&lt; unsigned(uint8_num) &lt;&lt; std::endl; std::cout &lt;&lt; "with a unary + operator, uint8_t num is " &lt;&lt; +uint8_num &lt;&lt; std::endl; std::cout &lt;&lt; "type of '+uint8_num' is " &lt;&lt; typeid(+uint8_num).name() &lt;&lt; std::endl; return 0;&#125; 运行结果如下可见使用+运算符的原理也是进行类型转换(把uint8_t 转为 int)]]></content>
      <categories>
        <category>Backend Development</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Minimum Time Difference]]></title>
    <url>%2F2018%2F06%2F12%2FLeetCode-Minimum-Time-Difference%2F</url>
    <content type="text"><![CDATA[题目描述Given a list of 24-hour clock time points in “Hour:Minutes” format, find the minimum minutes difference between any two time points in the list.Example 1: Input: [“23:59”,”00:00”]Output: 1 Note:The number of time points in the given list is at least 2 and won’t exceed 20000.The input time is legal and ranges from 00:00 to 23:59.输入是一个时间的数组，要求求出最小的时间间隔。思路是对时间排序，然后求每相邻两个时间间隔的时间差与第一个时间与最后一个时间的时间差。比较得到最小的时间间隔。 C++ 实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061class Solution &#123;public: int findMinDifference(vector&lt;string&gt;&amp; timePoints) &#123; struct Time &#123; uint8_t hour; uint8_t min; Time(const uint8_t hour, const uint8_t min) : hour(hour), min(min) &#123; &#125; bool operator&lt;(const Time&amp; other) const &#123; if (hour &lt; other.hour) &#123; return true; &#125; else if (hour == other.hour) &#123; return min &lt; other.min; &#125; return false; &#125; int operator-(const Time&amp; other) const &#123; int hour_diff = hour - other.hour; int min_diff = min - other.min; return hour_diff * 60 + min_diff; &#125; &#125;; vector&lt;Time&gt; times; times.reserve(timePoints.size()); for (const string&amp; time_point : timePoints) &#123; const size_t idx = time_point.find(":"); const uint8_t hour = stoi(time_point.substr(0,idx)); const uint8_t min = stoi(time_point.substr(idx + 1,time_point.size() - idx)); times.emplace_back(Time&#123;hour,min&#125;); &#125; sort(times.begin(), times.end()); int res = INT_MAX; for (int i = 0; i &lt; times.size() - 1; i++) &#123; const Time&amp; t1 = times[i]; const Time&amp; t2 = times[i + 1]; res = min(t2 - t1, res); &#125; const Time first_t(times.front().hour + 24, times.front().min); const Time&amp; last_t = times.back(); res = min(first_t - last_t, res); return res; &#125;&#125;;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++利用宏实现统计运行时间工具]]></title>
    <url>%2F2018%2F06%2F05%2FC-%E5%88%A9%E7%94%A8%E5%AE%8F%E5%AE%9E%E7%8E%B0%E7%BB%9F%E8%AE%A1%E8%BF%90%E8%A1%8C%E6%97%B6%E9%97%B4%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"><![CDATA[背景OSRM backend 代码中有一个timing_util.hpp的头文件，其利用宏以及c++11 chrono 实现了统计代码运行时间的工具。在工程中统计代码运行时间非常常用，本文介绍OSRM timing_util的实现原理，并用示例来说明。 实现解析timing_util.hpp1234567891011121314151617181920212223242526272829303132333435#ifndef TIMING_UTIL_HPP#define TIMING_UTIL_HPP#include &lt;chrono&gt;#include &lt;cstdint&gt;namespace osrm&#123;namespace util&#123;// 用TIMER_START 定义一个变量记录开始的时间#define TIMER_START(_X) auto _X##_start = std::chrono::steady_clock::now(), _X##_stop = _X##_start// 用TIMER_STOP 定义一个变量记录结束的时间#define TIMER_STOP(_X) _X##_stop = std::chrono::steady_clock::now()// TIMER_NSEC 定义start到stop经历了多少纳秒#define TIMER_NSEC(_X) \ std::chrono::duration_cast&lt;std::chrono::nanoseconds&gt;(_X##_stop - _X##_start).count()// TIMER_USEC 定义start到stop历经多少微秒#define TIMER_USEC(_X) \ std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(_X##_stop - _X##_start).count()// TIMER_MSEC 定义start到stop经历多少毫秒#define TIMER_MSEC(_X) \ (0.000001 * \ std::chrono::duration_cast&lt;std::chrono::nanoseconds&gt;(_X##_stop - _X##_start).count())// TIMER_SEC 定义start到stop经历多少秒#define TIMER_SEC(_X) \ (0.000001 * \ std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(_X##_stop - _X##_start).count())// TIMER_MIN 定义start到stop经历多少分钟#define TIMER_MIN(_X) \ std::chrono::duration_cast&lt;std::chrono::minutes&gt;(_X##_stop - _X##_start).count()&#125;&#125;#endif // TIMING_UTIL_HPP timing_util在定义宏变量时使用 ##，##的作用是把宏参数和相邻的字符进行字符串连接，# 的作用是把宏参数当做一个字符串。以下是关于宏中# 以及## 用法的示例。 12345678910111213141516171819/************************************************************************* &gt; File Name: test_macro.cpp &gt; Author: ce39906 &gt; Mail: ce39906@163.com &gt; Created Time: 2018-06-05 17:38:01 ************************************************************************/#include &lt;iostream&gt;#define STR(s) #s#define CONS(a, b) int(a##e##b)int main()&#123; // 输出字符串abc std::cout &lt;&lt; STR(abc) &lt;&lt; std::endl; // 输出2000 (2e3 == 2000) std::cout &lt;&lt; CONS(2, 3) &lt;&lt; std::endl; return 0;&#125; TIMING_UTIL统计运行时间示例timing_util.cpp1234567891011121314151617181920212223242526272829/************************************************************************* &gt; File Name: timing_util.cpp &gt; Author: ce39906 &gt; Mail: ce39906@163.com &gt; Created Time: 2018-06-05 17:46:50 ************************************************************************/#include "timing_util.hpp"#include &lt;iostream&gt;using namespace osrm::util;int main()&#123; TIMER_START(x); for (int i = 0; i &lt; 10000; i++) &#123; for (int j = 0; j &lt; 10000; j++) &#123; int ij = i * j; &#125; &#125; TIMER_STOP(x); std::cout &lt;&lt; "Two Level Loop Cost " &lt;&lt; TIMER_NSEC(x) &lt;&lt; " ns.\n"; std::cout &lt;&lt; "Two Level Loop Cost " &lt;&lt; TIMER_USEC(x) &lt;&lt; " us.\n"; std::cout &lt;&lt; "Two Level Loop Cost " &lt;&lt; TIMER_MSEC(x) &lt;&lt; " ms.\n"; std::cout &lt;&lt; "Two Level Loop Cost " &lt;&lt; TIMER_SEC(x) &lt;&lt; " s.\n"; std::cout &lt;&lt; "Two Level Loop Cost " &lt;&lt; TIMER_MIN(x) &lt;&lt; " min.\n"; return 0;&#125; 编译 1g++ timing_util.cpp -o timing_util --std=c++11 运行1./timing_util 运行结果如下]]></content>
      <categories>
        <category>Backend Development</category>
      </categories>
      <tags>
        <tag>tool</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux cmake 静态链接boost]]></title>
    <url>%2F2018%2F06%2F05%2FLinux-cmake-%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5boost%2F</url>
    <content type="text"><![CDATA[背景使用动态链接编译的二进制程序在执行时要求开发环境与生产环境严格一致，因此我们更倾向于使用静态链接的方式链接第三方库。本文介绍如何在Linux 环境下使用cmake 静态链接Boost 库。 示例我们将编译好boost静态库.a 文件和头文件放入third_party 目录，在CMakeLists.txt 中使用find_package 方法查找boost静态库。我自己在CentOS 6.6 编译的boost 1.63.0 静态库以及头文件 boost static library12345678910// 加入boost头文件路径INCLUDE_DIRECTORIES($&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/third_party/boost_1_63_0/include)// 设置boost使用静态链接set(Boost_USE_STATIC_LIBS ON)// 设置需要的boost 组件set(BOOST_COMPONENTS date_time chrono filesystem iostreams program_options regex system thread unit_test_framework)// 使用cmake find_package 查找boost库位置find_package(Boost REQUIRED COMPONENTS $&#123;BOOST_COMPONENTS&#125;)// 编译的bin 文件链接boost 库TARGET_LINK_LIBRARIES(your_bin_name $&#123;Boost_LIBRARIES&#125;) 需要注意的是，仅在CMakeLists.txt 中这样设置的话cmake find_package 无法找到boost 静态库的位置。在cmake 前加入如下参数123# 需要指定boost静态库的绝对路径cmake -DBOOST_INCLUDEDIR=$(workspace)/third_party/boost_1_63_0/include \ -DBOOST_LIBRARYDIR=$(workspace)/third_party/boost_1_63_0/lib .. 编译helloboost 程序静态链接boost库的完整示例如下。helloboost.cpp12345678910111213141516171819202122/************************************************************************* &gt; File Name: helloboost.cpp &gt; Author: ce39906 &gt; Mail: ce39906@163.com &gt; Created Time: 2018-06-05 16:02:08 ************************************************************************/#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;// test boost split#include &lt;boost/algorithm/string.hpp&gt;// include other boost header file you need.int main()&#123; std::string s("1;2;3;4"); std::vector&lt;std::string&gt; v; std::cout &lt;&lt; "Before boost split, size of v is " &lt;&lt; v.size() &lt;&lt; std::endl; boost::split(v, s, boost::is_any_of(";")); std::cout &lt;&lt; "After boost split, size of v is " &lt;&lt; v.size() &lt;&lt; std::endl; return 0;&#125; CmakeLists.txt12345678910111213141516cmake_minimum_required(VERSION 2.6)project(helloboost C CXX)SET(CMAKE_CXX_FLAGS "-g -w -O2")#default binary and lib pathSET(EXECUTABLE_OUTPUT_PATH $&#123;CMAKE_SOURCE_DIR&#125;)#begin to set boost static libraryINCLUDE_DIRECTORIES($&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/third_party/boost_1_63_0/include)set(Boost_USE_STATIC_LIBS ON)set(BOOST_COMPONENTS date_time chrono filesystem iostreams program_options regex system thread unit_test_framework)find_package(Boost REQUIRED COMPONENTS $&#123;BOOST_COMPONENTS&#125;)ADD_EXECUTABLE(helloboost helloboost.cpp)TARGET_LINK_LIBRARIES(helloboost $&#123;Boost_LIBRARIES&#125;) install.sh12345678#!/bin/bashworkspace=$(pwd)mkdir -p buildcd buildcmake -DBOOST_INCLUDEDIR=$&#123;workspace&#125;/third_party/boost_1_63_0/include \ -DBOOST_LIBRARYDIR=$&#123;workspace&#125;/third_party/boost_1_63_0/lib ..make 编译并执行12./install.sh./helloboost 执行结果如下]]></content>
      <categories>
        <category>Backend Development</category>
      </categories>
      <tags>
        <tag>Boost</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Linked List Components]]></title>
    <url>%2F2018%2F05%2F31%2FLeetCode-Linked-List-Components%2F</url>
    <content type="text"><![CDATA[题目描述We are given head, the head node of a linked list containing unique integer values. We are also given the list G, a subset of the values in the linked list. Return the number of connected components in G, where two values are connected if they appear consecutively in the linked list. Example 1: Input:head: 0-&gt;1-&gt;2-&gt;3G = [0, 1, 3]Output: 2Explanation:0 and 1 are connected, so [0, 1] and [3] are the two connected components. Example 2: Input:head: 0-&gt;1-&gt;2-&gt;3-&gt;4G = [0, 3, 1, 4]Output: 2Explanation:0 and 1 are connected, 3 and 4 are connected, so [0, 1] and [3, 4] are the two connected components. Note: If N is the length of the linked list given by head, 1 &lt;= N &lt;= 10000.The value of each node in the linked list will be in the range [0, N - 1].1 &lt;= G.length &lt;= 10000.G is a subset of all values in the linked list. 输入包括一个单链表以及一个数组，单链表中的节点不重复。数组存储图的所有节点，要求求出单链表中有多少个连通分量。此题可以使用hash table存储图的所有节点，顺序遍历单链表，如果单链表连续几个节点都是图中的节点，则继续向前遍历查找。在找到第一不是图节点的时候，统计连通图数的变量加一。 C++ 实现1234567891011121314151617181920212223242526272829303132333435/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: int numComponents(ListNode* head, vector&lt;int&gt;&amp; G) &#123; unordered_set&lt;int&gt; g(G.begin(), G.end()); int res = 0; while(head) &#123; int component_size = 0; while (head &amp;&amp; g.count(head-&gt;val)) &#123; component_size++; head = head-&gt;next; &#125; if (component_size &gt; 0) &#123; res++; &#125; if (head) &#123; head = head-&gt;next; &#125; &#125; return res; &#125;&#125;;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Max Increase to Keep City Skyline]]></title>
    <url>%2F2018%2F05%2F30%2FLeetCode-Max-Increase-to-Keep-City-Skyline%2F</url>
    <content type="text"><![CDATA[题目描述In a 2 dimensional array grid, each value grid[i][j] represents the height of a building located there. We are allowed to increase the height of any number of buildings, by any amount (the amounts can be different for different buildings). Height 0 is considered to be a building as well. At the end, the “skyline” when viewed from all four directions of the grid, i.e. top, bottom, left, and right, must be the same as the skyline of the original grid. A city’s skyline is the outer contour of the rectangles formed by all the buildings when viewed from a distance. See the following example. What is the maximum total sum that the height of the buildings can be increased? Example: Input: grid = [[3,0,8,4],[2,4,5,7],[9,2,6,3],[0,3,1,0]]Output: 35Explanation:The grid is:[ [3, 0, 8, 4], [2, 4, 5, 7], [9, 2, 6, 3], [0, 3, 1, 0] ]The skyline viewed from top or bottom is: [9, 4, 8, 7]The skyline viewed from left or right is: [8, 7, 9, 3]The grid after increasing the height of buildings without affecting skylines is:gridNew = [ [8, 4, 8, 7], [7, 4, 7, 7], [9, 4, 8, 7], [3, 3, 3, 3] ] Notes: 1 &lt; grid.length = grid[0].length &lt;= 50.All heights grid[i][j] are in the range [0, 100].All buildings in grid[i][j] occupy the entire grid cell: that is, they are a 1 x 1 x grid[i][j] rectangular prism.二维数组存储楼房的高度，从左到右或从上到下都有最大值。要求对于每个节点尽可能升高高度，要求升高之后之前从左到右以及从上到下的最大值依然最大。要求返回最高的升高高度。思路是遍历二维数组，求出从左到右以及从上到下的最高楼房高度，然后在遍历一遍二维数组中的所有值，当前可以到达的最高高度是当前位置从左到右和从上到下的较小值，不断累加得到最后结果。 C++ 实现1234567891011121314151617181920212223242526272829303132class Solution &#123;public: int maxIncreaseKeepingSkyline(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123; int row_size = grid.size(); if (row_size == 0) return 0; int col_size = grid[0].size(); vector&lt;int&gt; top_2_bottom(row_size); vector&lt;int&gt; left_2_right(col_size); for (int i = 0; i &lt; row_size; i++) &#123; top_2_bottom[i] = *max_element(grid[i].begin(), grid[i].end()); &#125; for (int j = 0; j &lt; col_size; j++) &#123; int max_element = grid[0][j]; for (int i = 1; i &lt; row_size; i++) &#123; max_element = max(max_element, grid[i][j]); &#125; left_2_right[j] = max_element; &#125; int res = 0; for (int i = 0; i &lt; row_size; i++) &#123; for (int j = 0; j &lt; col_size; j++) &#123; res += min(top_2_bottom[i], left_2_right[j]) - grid[i][j]; &#125; &#125; return res; &#125;&#125;;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Keys and Rooms]]></title>
    <url>%2F2018%2F05%2F30%2FLeetCode-Keys-and-Rooms%2F</url>
    <content type="text"><![CDATA[题目描述There are N rooms and you start in room 0. Each room has a distinct number in 0, 1, 2, …, N-1, and each room may have some keys to access the next room. Formally, each room i has a list of keys rooms[i], and each key rooms[i][j] is an integer in [0, 1, …, N-1] where N = rooms.length. A key rooms[i][j] = v opens the room with number v. Initially, all the rooms start locked (except for room 0). You can walk back and forth between rooms freely. Return true if and only if you can enter every room. Example 1: Input: [[1],[2],[3],[]]Output: trueExplanation:We start in room 0, and pick up key 1.We then go to room 1, and pick up key 2.We then go to room 2, and pick up key 3.We then go to room 3. Since we were able to go to every room, we return true. Example 2: Input: [[1,3],[3,0,1],[2],[0]]Output: falseExplanation: We can’t enter the room with number 2. Note: 1 &lt;= rooms.length &lt;= 10000 &lt;= rooms[i].length &lt;= 1000The number of keys in all rooms combined is at most 3000. 给定一个二维数组，数组的每一行代表从当前房间可以进入的房间列表。从room-0 出发，要求求出是否可以进入到所有的房间。本题中给定的数组可以认为是一个图，此问题就转换为从图的特定节点出发能否遍历全图的问题。可以使用bfs或者dfs 搜索解决。 C++ 实现bfs 版本1234567891011121314151617181920212223242526272829303132333435363738class Solution &#123;public: bool canVisitAllRooms(vector&lt;vector&lt;int&gt;&gt;&amp; rooms) &#123; int size = rooms.size(); vector&lt;bool&gt; visited(size, false); visited[0] = true; for (const int room : rooms.front()) &#123; bfs(room, rooms, visited); &#125; for (const bool v : visited) &#123; if (!v) return false; &#125; return true; &#125; void bfs(const int start, const vector&lt;vector&lt;int&gt;&gt;&amp; rooms, vector&lt;bool&gt;&amp; visited) &#123; queue&lt;int&gt; que; que.push(start); while(!que.empty()) &#123; int front = que.front(); visited[front] = true; que.pop(); for (const int room : rooms[front]) &#123; if (!visited[room]) &#123; que.push(room); &#125; &#125; &#125; &#125;&#125;; dfs 版本12345678910111213141516171819202122232425262728293031class Solution &#123;public: bool canVisitAllRooms(vector&lt;vector&lt;int&gt;&gt;&amp; rooms) &#123; int size = rooms.size(); vector&lt;bool&gt; visited(size, false); visited[0] = true; for (const int room : rooms.front()) &#123; dfs(room, rooms, visited); &#125; for (const bool v : visited) &#123; if (!v) return false; &#125; return true; &#125; void dfs(const int start, const vector&lt;vector&lt;int&gt;&gt;&amp; rooms, vector&lt;bool&gt;&amp; visited) &#123; visited[start] = true; for (const int room : rooms[start]) &#123; if (!visited[room]) &#123; dfs(room, rooms, visited); &#125; &#125; &#125;&#125;;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] 01 Matrix]]></title>
    <url>%2F2018%2F05%2F29%2FLeetCode-01-Matrix%2F</url>
    <content type="text"><![CDATA[题目描述Given a matrix consists of 0 and 1, find the distance of the nearest 0 for each cell. The distance between two adjacent cells is 1.Example 1: Input:0 0 00 1 00 0 0Output:0 0 00 1 00 0 0 Example 2: Input:0 0 00 1 01 1 1Output:0 0 00 1 01 2 1 Note:The number of elements of the given matrix will not exceed 10,000.There are at least one 0 in the given matrix.The cells are adjacent in only four directions: up, down, left and right.输入是一个只包含0 1 的矩阵，要求输出每个元素和矩阵中0最近距离。 C++ 代码实现动态规划版本，按照从上到下，从左到右的顺序遍历可以考虑到从左边以及上边到达的最短路径情况。然后再按照从下到上，从右到左的顺序遍历可以考虑到从右边以及下边到达的最短路径。因此动态规划需要一次正序遍历，一次逆序遍历。12345678910111213141516171819202122232425262728293031323334353637383940414243444546class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; updateMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123; int row_size = matrix.size(); if (row_size == 0) return vector&lt;vector&lt;int&gt;&gt;(); int col_size = matrix[0].size(); vector&lt;vector&lt;int&gt;&gt; res(row_size,vector&lt;int&gt;(col_size)); // forward loop for (int i = 0; i &lt; row_size; i++) &#123; for (int j = 0; j &lt; col_size; j++) &#123; if (matrix[i][j] == 0) &#123; res[i][j] = 0; &#125; else &#123; int left = INT_MAX - 1; int top = INT_MAX - 1; if (i - 1 &gt;= 0) top = res[i - 1][j]; if (j - 1 &gt;= 0) left = res[i][j - 1]; res[i][j] = min(INT_MAX - 1, min(left,top) + 1); &#125; &#125; &#125; // reverse loop for (int i = row_size - 1; i &gt;= 0; i--) &#123; for (int j = col_size - 1; j &gt;= 0; j--) &#123; if (res[i][j] != 0 &amp;&amp; res[i][j] != 1) &#123; int down = INT_MAX - 1; int right = INT_MAX - 1; if (i + 1 &lt; row_size) down = res[i + 1][j]; if (j + 1 &lt; col_size) right = res[i][j + 1]; res[i][j] = min(res[i][j], min(down,right) + 1); &#125; &#125; &#125; return res; &#125;&#125;; BFS 的解法如下123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; updateMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123; int row_size = matrix.size(); int col_size = matrix[0].size(); queue&lt;pair&lt;int,int&gt;&gt; queue; for (int i = 0; i &lt; row_size; i++) &#123; for (int j = 0; j &lt; col_size; j++) &#123; if (matrix[i][j] == 0) &#123; queue.push(&#123;i, j&#125;); &#125; else &#123; matrix[i][j] = INT_MAX; &#125; &#125; &#125; vector&lt;pair&lt;int,int&gt;&gt; directions = &#123;&#123;0,1&#125;,&#123;1,0&#125;,&#123;0,-1&#125;,&#123;-1,0&#125;&#125;; while(!queue.empty()) &#123; const auto front = queue.front(); queue.pop(); int x = front.first; int y = front.second; for (const auto direction : directions) &#123; int newx = x + direction.first; int newy = y + direction.second; if ( newx &lt; 0 || newy &lt; 0 || newx &gt;= row_size || newy &gt;= col_size || matrix[newx][newy] &lt;= matrix[x][y] + 1) &#123; continue; &#125; matrix[newx][newy] = matrix[x][y] + 1; queue.push(&#123;newx, newy&#125;); &#125; &#125; return matrix; &#125;&#125;;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Add One Row to Tree]]></title>
    <url>%2F2018%2F05%2F29%2FLeetCode-Add-One-Row-to-Tree%2F</url>
    <content type="text"><![CDATA[题目描述Given the root of a binary tree, then value v and depth d, you need to add a row of nodes with value v at the given depth d. The root node is at depth 1. The adding rule is: given a positive integer depth d, for each NOT null tree nodes N in depth d-1, create two tree nodes with value v as N’s left subtree root and right subtree root. And N’s original left subtree should be the left subtree of the new left subtree root, its original right subtree should be the right subtree of the new right subtree root. If depth d is 1 that means there is no depth d-1 at all, then create a tree node with value v as the new root of the whole original tree, and the original tree is the new root’s left subtree. Example 1: Input:A binary tree as following:12345 4 / \ 2 6 / \ /3 1 5 v = 1d = 2Output:1234567 4 / \ 1 1 / \ 2 6 / \ /3 1 5 Example 2: Input:A binary tree as following:12345 4 / 2 / \3 1 v = 1d = 3Output:1234567 4 / 2 / \ 1 1 / \3 1 Note:The given d is in range [1, maximum depth of the given tree + 1].The given binary tree has at least one tree node.输入是一个二叉树，要求在指定的行插入新的一行后返回新的二叉树。 解题思路典型的二叉树的层序遍历，遍历到指定的深度的时候，返回该层的所有node,执行插入操作。需要注意的是，题目认为树根的level 是1，需要对要求在level 1 插入的情况进行特殊处理。在使用queue 进行树的层序遍历时，每次while循环都记录queue的大小,当前queue存储当前层的所有节点。 C++ 实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657class Solution &#123;public: TreeNode* addOneRow(TreeNode* root, int v, int d) &#123; // 处理level 1 的特殊情况 if (d == 1) &#123; TreeNode* new_root = new TreeNode(v); new_root-&gt;left = root; return new_root; &#125; // 开始层序遍历 int depth = 2; queue&lt;TreeNode*&gt; que; que.push(root); while (depth &lt; d) &#123; // 使用queue 的size 记录当前level 的节点个数 // 每次while循环处理一层 int size = que.size(); for (int i = 0; i &lt; size; i++) &#123; const TreeNode* front = que.front(); que.pop(); if (front-&gt;left) &#123; que.push(front-&gt;left); &#125; if (front-&gt;right) &#123; que.push(front-&gt;right); &#125; &#125; // 处理完一层，计数++ depth++; &#125; // 退出循环后 queue中存储的插入的节点 // 遍历queue 中所有节点，执行插入 while (!que.empty()) &#123; TreeNode* const node = que.front(); que.pop(); TreeNode* left = node-&gt;left; TreeNode* right = node-&gt;right; TreeNode* new_node = new TreeNode(v); node-&gt;left = new_node; new_node-&gt;left = left; new_node = new TreeNode(v); node-&gt;right = new_node; new_node-&gt;right = right; &#125; return root; &#125;&#125;;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] Accounts Merge]]></title>
    <url>%2F2018%2F05%2F29%2FLeetCode-Accounts-Merge%2F</url>
    <content type="text"><![CDATA[题目描述Given a list accounts, each element accounts[i] is a list of strings, where the first element accounts[i][0] is a name, and the rest of the elements are emails representing emails of the account. Now, we would like to merge these accounts. Two accounts definitely belong to the same person if there is some email that is common to both accounts. Note that even if two accounts have the same name, they may belong to different people as people could have the same name. A person can have any number of accounts initially, but all of their accounts definitely have the same name. After merging the accounts, return the accounts in the following format: the first element of each account is the name, and the rest of the elements are emails in sorted order. The accounts themselves can be returned in any order. Example 1: Input:accounts = [[“John”, “johnsmith@mail.com“, “john00@mail.com“], [“John”, “johnnybravo@mail.com“], [“John”, “johnsmith@mail.com“, “john_newyork@mail.com“], [“Mary”, “mary@mail.com“]]Output: [[“John”, &#39;john00@mail.com‘, &#39;john_newyork@mail.com‘, &#39;johnsmith@mail.com‘], [“John”, “johnnybravo@mail.com“], [“Mary”, “mary@mail.com“]]Explanation:The first and third John’s are the same person as they have the common email “johnsmith@mail.com“.The second John and Mary are different people as none of their email addresses are used by other accounts.We could return these lists in any order, for example the answer [[‘Mary’, &#39;mary@mail.com‘], [‘John’, &#39;johnnybravo@mail.com‘],[‘John’, &#39;john00@mail.com‘, &#39;john_newyork@mail.com‘, &#39;johnsmith@mail.com‘]] would still be accepted. Note: The length of accounts will be in the range [1, 1000].The length of accounts[i] will be in the range [1, 10].The length of accounts[i][j] will be in the range [1, 30]. 输入是string 型的二维数组，数组的每一行代表账户信息，其中每一行的第一个元素代表用户名称，其他元素代表邮箱。认为有相同邮箱的账户属于同一账户。要求把所有属于同一账户的信息合并起来。解决此题的思路是遍历数组构建树，把相同的email 连接起来，然后针对每个email 使用bfs 搜索找到属于同一用户的全部email并存储到set中。 C++ 实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576class Solution &#123;public: vector&lt;vector&lt;string&gt;&gt; accountsMerge(vector&lt;vector&lt;string&gt;&gt;&amp; accounts) &#123; unordered_map&lt;string,vector&lt;int&gt;&gt; email_2_indices; for (int i = 0; i &lt; accounts.size(); i++) &#123; for (int j = 1; j &lt; accounts[i].size(); j++) &#123; if (email_2_indices.count(accounts[i][j])) &#123; email_2_indices[accounts[i][j]].push_back(i); &#125; else &#123; email_2_indices[accounts[i][j]] = &#123;i&#125;; &#125; &#125; &#125; vector&lt;vector&lt;string&gt;&gt; res; unordered_set&lt;string&gt; visited; for (const auto email_2_index : email_2_indices) &#123; const auto&amp; email = email_2_index.first; const auto&amp; index = email_2_index.second; const string&amp; name = accounts[index[0]].front(); vector&lt;string&gt; name_and_email; name_and_email.emplace_back(name); if(visited.count(email) == 0) &#123; for (const auto&amp; mail : bfs(accounts,email_2_indices,email,visited)) &#123; name_and_email.emplace_back(mail); &#125; res.emplace_back(name_and_email); &#125; &#125; return res; &#125;private: set&lt;string&gt; bfs(const vector&lt;vector&lt;string&gt;&gt;&amp; accounts, const unordered_map&lt;string,vector&lt;int&gt;&gt;&amp; email_2_indices, const string&amp; email, unordered_set&lt;string&gt;&amp; visited) const &#123; set&lt;string&gt; res; queue&lt;string&gt; que; que.push(email); while(!que.empty()) &#123; const string front = que.front(); res.insert(front); que.pop(); if (visited.count(front) == 0) &#123; const vector&lt;int&gt;&amp; indices = email_2_indices.at(front); for (const int index : indices) &#123; for (int i = 1; i &lt; accounts[index].size(); i++) &#123; if (visited.count(accounts[index][i]) == 0) &#123; que.push(accounts[index][i]); &#125; &#125; &#125; &#125; visited.insert(front); &#125; return res; &#125;&#125;;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CRP算法以及OSRM实现]]></title>
    <url>%2F2018%2F05%2F22%2FCRP%E7%AE%97%E6%B3%95%E4%BB%A5%E5%8F%8AOSRM%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>Routing Algorithm</category>
      </categories>
      <tags>
        <tag>routing</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GCC __buildin_except 解析]]></title>
    <url>%2F2018%2F05%2F10%2FGCC-buildin-except-%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[概念摘自gcc的官方文档OtherBuildinFunction. —Built-in Function: long builtin_expect (long exp, long c)You may use builtin_expect to provide the compiler with branch prediction information. In general, you should prefer to use actual profile feedback for this (-fprofile-arcs), as programmers are notoriously bad at predicting how their programs actually perform. However, there are applications in which this data is hard to collect. The return value is the value of exp, which should be an integral expression. The value of c must be a compile-time constant. The semantics of the built-in are that it is expected that exp == c. For example: if (__builtin_expect (x, 0)) foo (); would indicate that we do not expect to call foo, since we expect x to be zero. Since you are limited to integral expressions for exp, you should use constructions such as if (__builtin_expect (ptr != NULL, 1)) error (); when testing pointer or floating-point values.我们可以使用 __buildin_except 向编译器提供分支预测信息，从而帮助编译器进行代码优化。 引入原因CPU 流水线技术可以提高CPU执行效率，但是程序中的跳转指令会打乱CPU流水线。因此，跳转次数少的程序拥有更高的执行效率。 示例使用__buildin_except 定义LIKELY和UNLIKELY宏，分别代表bool型变量或表达式有很大可能性为真或者很大可能性为假。以下是测试代码。123456789101112131415161718192021222324252627282930313233343536373839404142434445// 两个感叹号的作用是将所有的非零值转化为1#define LIKELY(x) __builtin_expect(!!(x), 1)#define UNLIKELY(x) __builtin_expect(!!(x), 0)int likely(int x)&#123; if(LIKELY(x)) &#123; x = 5; &#125; else &#123; x = 6; &#125; return x;&#125;int unlikely(int x)&#123; if(UNLIKELY(x)) &#123; x = 5; &#125; else &#123; x = 6; &#125; return x;&#125;int normal(int x)&#123; if(x) &#123; x = 5; &#125; else &#123; x = 6; &#125; return x;&#125; 编译出.o文件，并使用objdump查看汇编代码12gcc -O2 -fprofile-arcs -c test_builtin_except.cppobjdump -d test_builtin_except.o 结果以及解释如下图 总结Linux 内核中大量使用LIKELY UNLIKELY宏提升程序运行效率，在C/C++工程可以引入此宏提供分支预测提示编译器进行代码优化。比如在工程中经常会存在处理程序错误的分支，但是出错分支又是不经常进入，这种场景下可以使用__build_except进行代码优化。]]></content>
      <categories>
        <category>Backend Development</category>
      </categories>
      <tags>
        <tag>High performance programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leveldb LRUCache 解析]]></title>
    <url>%2F2018%2F05%2F09%2FLeveldb-LRUCache-%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[LRU原理LRU 是一种经典的缓存淘汰策略，其原理以及实现可以查看我之前的博客LRU Cache 解析及实现。本文主要解析Leveldb LRU Cache。 Leveldb 实现Leveldb 实现的LRUCache 使用自己实现的简单hashtable存储键值对，循环双链表记录每个元素的访问时间，为了提升多线程环境下的读写性能，Leveldb 内部使用LRUCache 数组对外提供服务。 Cache Entry123456789101112131415161718192021222324252627struct LRUHandle &#123; void* value; void (*deleter)(const Slice&amp;, void* value); // next_hash 代表在hash桶中下一个元素的位置 LRUHandle* next_hash; // 双链表中下个元素的位置 LRUHandle* next; // 双链表中上个元素的位置 LRUHandle* prev; size_t charge; // TODO(opt): Only allow uint32_t? size_t key_length; // 使用次数 uint32_t refs; // key 的hash值用于在LRUCache数组以及hash表中定位 uint32_t hash; // Hash of key(); used for fast sharding and comparisons char key_data[1]; // Beginning of key Slice key() const &#123; // For cheaper lookups, we allow a temporary Handle object // to store a pointer to a key in "value". if (next == this) &#123; return *(reinterpret_cast&lt;Slice*&gt;(value)); &#125; else &#123; return Slice(key_data, key_length); &#125; &#125;&#125;; 简单hash表Leveldb LRU Cache 实现了线程安全的拉链式的hashtable12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788class HandleTable &#123; public: HandleTable() : length_(0), elems_(0), list_(NULL) &#123; Resize(); &#125; ~HandleTable() &#123; delete[] list_; &#125; // 查找，直接调用FindPointer方法 LRUHandle* Lookup(const Slice&amp; key, uint32_t hash) &#123; return *FindPointer(key, hash); &#125; // 插入，使用FindPointer方法找到插入位置，在hashtable 对位位置插入，当hashtable 中的元素个数大于桶的个数时候触发hashtable 的扩容 LRUHandle* Insert(LRUHandle* h) &#123; LRUHandle** ptr = FindPointer(h-&gt;key(), h-&gt;hash); LRUHandle* old = *ptr; h-&gt;next_hash = (old == NULL ? NULL : old-&gt;next_hash); *ptr = h; if (old == NULL) &#123; ++elems_; if (elems_ &gt; length_) &#123; // Since each cache entry is fairly large, we aim for a small // average linked list length (&lt;= 1). Resize(); &#125; &#125; return old; &#125;// 删除hashtable中的元素，同样使用FindPointer方法定位到在hashtable 中的位置 LRUHandle* Remove(const Slice&amp; key, uint32_t hash) &#123; LRUHandle** ptr = FindPointer(key, hash); LRUHandle* result = *ptr; if (result != NULL) &#123; *ptr = result-&gt;next_hash; --elems_; &#125; return result; &#125; private: // The table consists of an array of buckets where each bucket is // a linked list of cache entries that hash into the bucket. uint32_t length_; uint32_t elems_; LRUHandle** list_; // Return a pointer to slot that points to a cache entry that // matches key/hash. If there is no such cache entry, return a // pointer to the trailing slot in the corresponding linked list. // 找到hash 元素的地址 LRUHandle** FindPointer(const Slice&amp; key, uint32_t hash) &#123; //找到hash 桶的位置，由于length_是2的指数次幂，所以使用 按位与替换mod操作进行加速 LRUHandle** ptr = &amp;list_[hash &amp; (length_ - 1)]; // 遍历hash桶中的单链表直到找到相应节点或单链表结束 while (*ptr != NULL &amp;&amp; ((*ptr)-&gt;hash != hash || key != (*ptr)-&gt;key())) &#123; ptr = &amp;(*ptr)-&gt;next_hash; &#125; return ptr; &#125; // hash 表扩容 void Resize() &#123; // 每次扩容都是翻倍，保证hash桶的个数是2的指数次幂 uint32_t new_length = 4; while (new_length &lt; elems_) &#123; new_length *= 2; &#125; // 创建一个新的hashtable LRUHandle** new_list = new LRUHandle*[new_length]; memset(new_list, 0, sizeof(new_list[0]) * new_length); uint32_t count = 0; // 逐个桶迁移到新的hashtable for (uint32_t i = 0; i &lt; length_; i++) &#123; LRUHandle* h = list_[i]; while (h != NULL) &#123; LRUHandle* next = h-&gt;next_hash; uint32_t hash = h-&gt;hash; LRUHandle** ptr = &amp;new_list[hash &amp; (new_length - 1)]; h-&gt;next_hash = *ptr; *ptr = h; h = next; count++; &#125; &#125; assert(elems_ == count); // 释放掉老的hashtable delete[] list_; // 替换为新的hashtable list_ = new_list; length_ = new_length; &#125;&#125;; 单个LRUCache实现LRUCache 类声明1234567891011121314151617181920212223242526272829303132333435363738394041class LRUCache &#123; public: LRUCache(); ~LRUCache(); // Separate from constructor so caller can easily make an array of LRUCache void SetCapacity(size_t capacity) &#123; capacity_ = capacity; &#125; // Like Cache methods, but with an extra "hash" parameter. Cache::Handle* Insert(const Slice&amp; key, uint32_t hash, void* value, size_t charge, void (*deleter)(const Slice&amp; key, void* value)); Cache::Handle* Lookup(const Slice&amp; key, uint32_t hash); void Release(Cache::Handle* handle); void Erase(const Slice&amp; key, uint32_t hash); void Prune(); size_t TotalCharge() const &#123; MutexLock l(&amp;mutex_); return usage_; &#125; private: void LRU_Remove(LRUHandle* e); void LRU_Append(LRUHandle* e); void Unref(LRUHandle* e); // Initialized before use. // LRUCache 存储的元素个数，超过此个数触发淘汰机制 size_t capacity_; // mutex_ protects the following state. mutable port::Mutex mutex_; size_t usage_; // Dummy head of LRU list. // lru.prev is newest entry, lru.next is oldest entry. // 按照访问时间顺序存储的双向循环链表 LRUHandle lru_; // 自己实现的拉链式的hash table HandleTable table_;&#125;; LRUCache 插入12345678910111213141516171819202122232425262728293031323334353637Cache::Handle* LRUCache::Insert( const Slice&amp; key, uint32_t hash, void* value, size_t charge, void (*deleter)(const Slice&amp; key, void* value)) &#123; MutexLock l(&amp;mutex_); // 构造一个新的LRUHandle 对象 LRUHandle* e = reinterpret_cast&lt;LRUHandle*&gt;( malloc(sizeof(LRUHandle)-1 + key.size())); e-&gt;value = value; e-&gt;deleter = deleter; e-&gt;charge = charge; e-&gt;key_length = key.size(); e-&gt;hash = hash; e-&gt;refs = 2; // One from LRUCache, one for the returned handle memcpy(e-&gt;key_data, key.data(), key.size()); // 插入到双向链表表头的位置 LRU_Append(e); usage_ += charge; LRUHandle* old = table_.Insert(e); // 替换掉LRUCache中重复的元素 if (old != NULL) &#123; LRU_Remove(old); Unref(old); &#125; // 触发LRU 淘汰 while (usage_ &gt; capacity_ &amp;&amp; lru_.next != &amp;lru_) &#123; // 淘汰双向链表最后的元素 LRUHandle* old = lru_.next; // 删除双向链表中的元素 LRU_Remove(old); // 删除hashtable中的元素 table_.Remove(old-&gt;key(), old-&gt;hash); Unref(old); &#125; // 返回刚刚插入的Handle对象，此对象引用计数为2 return reinterpret_cast&lt;Cache::Handle*&gt;(e);&#125; LRUCache 删除12345678910void LRUCache::Erase(const Slice&amp; key, uint32_t hash) &#123; MutexLock l(&amp;mutex_); // 删除hashtable中对应的元素， // 如果该元素存在在hashtable中则在双向链表中进行删除 LRUHandle* e = table_.Remove(key, hash); if (e != NULL) &#123; LRU_Remove(e); Unref(e); &#125;&#125; LRUCache Prune删除LRUCache中ref为1 的元素，最初插入的元素的引用为2，外部消费者对使用结束的元素ref减一。LRUCache中ref 为1 的handle表示此元素只在LRUCache中出现，外部并不使用。此方法的作用就是删除这样的元素。123456789101112void LRUCache::Prune() &#123; MutexLock l(&amp;mutex_); for (LRUHandle* e = lru_.next; e != &amp;lru_; ) &#123; LRUHandle* next = e-&gt;next; if (e-&gt;refs == 1) &#123; table_.Remove(e-&gt;key(), e-&gt;hash); LRU_Remove(e); Unref(e); &#125; e = next; &#125;&#125; LRU_Remove删除双向链表中一个节点1234void LRUCache::LRU_Remove(LRUHandle* e) &#123; e-&gt;next-&gt;prev = e-&gt;prev; e-&gt;prev-&gt;next = e-&gt;next;&#125; LRU_Append插入到双向链表表头位置1234567void LRUCache::LRU_Append(LRUHandle* e) &#123; // Make "e" newest entry by inserting just before lru_ e-&gt;next = &amp;lru_; e-&gt;prev = lru_.prev; e-&gt;prev-&gt;next = e; e-&gt;next-&gt;prev = e;&#125; ShardedLRUCache12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970static const int kNumShardBits = 4;// 16个 lru cache，目的在多线程的环境下，每个线程的访问都会锁住缓冲区// 如果缓冲区比较大的话， 多线程情况下的性能比较差，// 所以使用hash 的方式将一块cache 缓冲区 划分为多个小块的缓冲区static const int kNumShards = 1 &lt;&lt; kNumShardBits;class ShardedLRUCache : public Cache &#123; private: // LRUCache 数组，每个LRUCache对象使用自己的锁 LRUCache shard_[kNumShards]; // 这个锁只保护id port::Mutex id_mutex_; uint64_t last_id_; static inline uint32_t HashSlice(const Slice&amp; s) &#123; return Hash(s.data(), s.size(), 0); &#125; // Shard 函数，根据key计算的hash 值定位LRUCache数组的位置 static uint32_t Shard(uint32_t hash) &#123; // 不需要使用mod运算，此数值一定是在0~kNumShards这个区间 return hash &gt;&gt; (32 - kNumShardBits); &#125; public: explicit ShardedLRUCache(size_t capacity) : last_id_(0) &#123; // 向上取整，为每个LRUCache 分配容量 const size_t per_shard = (capacity + (kNumShards - 1)) / kNumShards; for (int s = 0; s &lt; kNumShards; s++) &#123; shard_[s].SetCapacity(per_shard); &#125; &#125; virtual ~ShardedLRUCache() &#123; &#125; // 插入时，先使用Shard方法定位到相应的LRUCache virtual Handle* Insert(const Slice&amp; key, void* value, size_t charge, void (*deleter)(const Slice&amp; key, void* value)) &#123; const uint32_t hash = HashSlice(key); return shard_[Shard(hash)].Insert(key, hash, value, charge, deleter); &#125; virtual Handle* Lookup(const Slice&amp; key) &#123; const uint32_t hash = HashSlice(key); return shard_[Shard(hash)].Lookup(key, hash); &#125; virtual void Release(Handle* handle) &#123; LRUHandle* h = reinterpret_cast&lt;LRUHandle*&gt;(handle); shard_[Shard(h-&gt;hash)].Release(handle); &#125; virtual void Erase(const Slice&amp; key) &#123; const uint32_t hash = HashSlice(key); shard_[Shard(hash)].Erase(key, hash); &#125; virtual void* Value(Handle* handle) &#123; return reinterpret_cast&lt;LRUHandle*&gt;(handle)-&gt;value; &#125; virtual uint64_t NewId() &#123; MutexLock l(&amp;id_mutex_); return ++(last_id_); &#125; virtual void Prune() &#123; for (int s = 0; s &lt; kNumShards; s++) &#123; shard_[s].Prune(); &#125; &#125; virtual size_t TotalCharge() const &#123; size_t total = 0; for (int s = 0; s &lt; kNumShards; s++) &#123; total += shard_[s].TotalCharge(); &#125; return total; &#125;&#125;; 总结Leveldb 实现的LRUCahe 基于hashtable以及双向链表实现，为了提升性能以及保证跨平台特性，Leveldb 实现了一个线程安全的拉链式hashtable,此hashtable 的缺点是当触发扩容操作的时候需要将老hashtable 的全部元素复制到新的hashtable 中，这会期间会一直占用锁，此时多线程环境下的读写会阻塞。这一点Memcached 中实现的hashtable是有一个线程专门负责扩展，每次只扩展一个元素。Leveldb 为了提升多线程环境下的读写性能，将固定容量的Cache分摊到多个LRUCache，每个LRUCache保证自己的线程安全，这就降低了多线程环境下锁的竞争。这种做法与分段锁的思想类似。]]></content>
      <categories>
        <category>Backend Development</category>
      </categories>
      <tags>
        <tag>Leveldb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux shell 颜色输出]]></title>
    <url>%2F2018%2F05%2F09%2FLinux-shell-%E9%A2%9C%E8%89%B2%E8%BE%93%E5%87%BA%2F</url>
    <content type="text"><![CDATA[原理可以利用ANSI escape code 实现linux终端输出颜色文本。下面是几个ANSI escape code 对应的颜色。12345678Black 0;30 Dark Gray 1;30Red 0;31 Light Red 1;31Green 0;32 Light Green 1;32Brown/Orange 0;33 Yellow 1;33Blue 0;34 Light Blue 1;34Purple 0;35 Light Purple 1;35Cyan 0;36 Light Cyan 1;36Light Gray 0;37 White 1;37 示例以下是一个输出ANSI Rainbow 的示例。12345#!/bin/bashfor (( i = 30; i &lt; 38; i++ ))do echo -e "\033[0;"$i"m Normal: (0;$i); \033[1;"$i"m Light: (1;$i)";done 输出结果如下如果想设置固定区间的颜色，可以将’\033[0m’放在对应区间的结尾。如下示例123456#!/bin/bashNC='\033[0m' # No Colorfor (( i = 30; i &lt; 38; i++ ))do echo -e "I \033[0;$&#123;i&#125;mlove$&#123;NC&#125; Linux"done 输出结果如下]]></content>
      <categories>
        <category>Backend Development</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leveldb Arena解析]]></title>
    <url>%2F2018%2F05%2F03%2FLeveldb-Arena%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[简介Arena 是leveldb 实现的简单的内存池，以最小4096bytes 为单位申请block, 使用指针记录当前block 中空余内存起始位置以及当前block剩余空间。将所有的block 放到blocks_ 数组中。Arena 提供了分配内存以及分配对齐的内存的两种接口，没有释放内存的接口，当Arena 的生命周期结束时，由Arena 的析构函数统一释放内存。Arena 的主要结构如下图所示： Leveldb 代码实现leveldb arena 实现在util/arena.h 以及 util/arena.cc 接口以及成员1234567891011121314151617181920212223242526272829303132333435363738394041424344class Arena &#123; public: Arena(); ~Arena(); // Return a pointer to a newly allocated memory block of "bytes" bytes. // 分配指定大小的内存，并返回分配内存的首地址 char* Allocate(size_t bytes); // 分配指定大小并且对齐的内存 // Allocate memory with the normal alignment guarantees provided by malloc char* AllocateAligned(size_t bytes); // Returns an estimate of the total memory usage of data allocated // by the arena. // 统计使用了多少内存 size_t MemoryUsage() const &#123; return reinterpret_cast&lt;uintptr_t&gt;(memory_usage_.NoBarrier_Load()); &#125; private: // 分配内存，根据情况决定是否使用新的block char* AllocateFallback(size_t bytes); // 分配一个新的block char* AllocateNewBlock(size_t block_bytes); // Allocation state // 指向一个block中未被使用的内存首地址 char* alloc_ptr_; // 表示一个block还剩余多少空间 size_t alloc_bytes_remaining_; // Array of new[] allocated memory blocks // 内存池数组 std::vector&lt;char*&gt; blocks_; // Total memory usage of the arena. // 统计内存使用，原子变量 port::AtomicPointer memory_usage_; // No copying allowed // 将拷贝构造和赋值构造设置为私有 Arena(const Arena&amp;); void operator=(const Arena&amp;);&#125;; 分配指定bytes 的内存首先根据alloc_bytes_remaining_判断是否需要分配一个新的block ,如果不需要的话，则重新设置alloc_ptr_ 以及 alloc_bytes_remaining_，否则调用AllocFallback方法分配新的block,并且判断新的block 是否可以被复用。1234567891011121314inline char* Arena::Allocate(size_t bytes) &#123; // The semantics of what to return are a bit messy if we allow // 0-byte allocations, so we disallow them here (we don't need // them for our internal use). assert(bytes &gt; 0); // 判断是否有可被复用的block if (bytes &lt;= alloc_bytes_remaining_) &#123; char* result = alloc_ptr_; alloc_ptr_ += bytes; alloc_bytes_remaining_ -= bytes; return result; &#125; return AllocateFallback(bytes);&#125; 分配指定bytes 对齐的内存与上一个接口不同的地方在于，将传入的bytes 化为可对齐内存的大小123456789101112131415161718192021222324252627char* Arena::AllocateAligned(size_t bytes) &#123; // 获取当前系统指针大小 const int align = (sizeof(void*) &gt; 8) ? sizeof(void*) : 8; // 指针大小必须是2的整数次幂，2的整数次幂的二进制表示中 // 有且只有1位是1 assert((align &amp; (align-1)) == 0); // Pointer size should be a power of 2 // 判断bytes是不是align 的整数倍，由于align是2的 // 整数次幂，所以对align的取模运算可以转化为 // 对（align - 1）进行按位与 size_t current_mod = reinterpret_cast&lt;uintptr_t&gt;(alloc_ptr_) &amp; (align-1); // 为了对齐内存需要新增的大小 size_t slop = (current_mod == 0 ? 0 : align - current_mod); // needed 表示分配对齐的内存所需的大小 // 后面的逻辑同前 size_t needed = bytes + slop; char* result; if (needed &lt;= alloc_bytes_remaining_) &#123; result = alloc_ptr_ + slop; alloc_ptr_ += needed; alloc_bytes_remaining_ -= needed; &#125; else &#123; // AllocateFallback always returned aligned memory result = AllocateFallback(bytes); &#125; assert((reinterpret_cast&lt;uintptr_t&gt;(result) &amp; (align-1)) == 0); return result;&#125; AllocateFallback函数的作用是分配一个新的block。不同的是，如果bytes 小于blocksize 的四分之一，则此新分配的block 可以被继续复用。否则的话直接分配新的block, Arena 中可被复用的block 保持不变。1234567891011121314151617181920char* Arena::AllocateFallback(size_t bytes) &#123; // 分配的bytes较小，此新block可以被复用 if (bytes &gt; kBlockSize / 4) &#123; // Object is more than a quarter of our block size. Allocate it separately // to avoid wasting too much space in leftover bytes. char* result = AllocateNewBlock(bytes); return result; &#125; // We waste the remaining space in the current block. // 此新分配的block可以被复用，重新设置 // alloc_ptr_ 以及 alloc_bytes_remaining_ alloc_ptr_ = AllocateNewBlock(kBlockSize); alloc_bytes_remaining_ = kBlockSize; char* result = alloc_ptr_; alloc_ptr_ += bytes; alloc_bytes_remaining_ -= bytes; return result;&#125; AllocateNewBlock直接使用new分配符分配指定大小的内存，并且更新memory_usage_12345678910char* Arena::AllocateNewBlock(size_t block_bytes) &#123; // 分配空间 char* result = new char[block_bytes]; // 新的block 加入内存池 blocks_.push_back(result); // 更新memory_usage_ memory_usage_.NoBarrier_Store( reinterpret_cast&lt;void*&gt;(MemoryUsage() + block_bytes + sizeof(char*))); return result;&#125; 析构逐个释放内存池中的block12345Arena::~Arena() &#123; for (size_t i = 0; i &lt; blocks_.size(); i++) &#123; delete[] blocks_[i]; &#125;&#125; 总结Leveldb Arena 实现简单，Arena 的设计与leveldb 特定的应用场景相关，比如一个memtable 使用一个Arena对象统一获取内存，当memtable对象声明周期结束时，由Arena 统一释放内存，不需要消费者每次new一片内存就要自己delete 掉。]]></content>
      <categories>
        <category>Backend Development</category>
      </categories>
      <tags>
        <tag>Leveldb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leveldb BloomFilter 解析]]></title>
    <url>%2F2018%2F04%2F28%2FLeveldb-BloomFilter-%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[BloomFilter 原理布隆过滤器由巴顿布隆于1970年提出，由一个很长的bit数组以及一系列hash函数组成。bloomfilter可以用于检索一个元素是否出现在一个集合中，bloomfilter的优点是相比hash表拥有极大的空间效率，缺点是会出现一定的错误概率(False positive,一个不在集合中的元素被误认为处于集合中）。bloomfilter 的原理是，当一个元素在加入集合时，通过k个hash 函数映射到bit数组的k个位置，并将相应的位置置1。在查找一个元素是否存在于集合中时，使用相同的k个hash 函数查看bit数组中的位置是否为全为1，如果出现一个0，则该key 一定不存在集合中，否则有可能出现在集合中。 优点Bloomfilter 可以使用较少的空间存储大量数据的全集，并且存储的不是每个元素的原本的数值，只是设置对应的bit位，一定程度上实现了加密的效果。除空间效率之外，bloomfilter的时间效率都是常数级别O(k),其中k 代表使用的hash 函数个数，由于k个hash 函数式相互独立的性质，在进行k个hash 计算时可以并行计算进一步加速插入查找。 缺点Bloomfilter 的缺点是会出现False positive 的误判率，而且随着元素的增加，误算率也随之增加。因此尽可能降低误判率需要一些额外工作。 BloomFilter参数选择以下均参考wikipedia bloomfilter 中关于误差率的计算章节。直接说结论，当k(hash 函数个数)，m(bit数组大小)，n(插入元素个数)满足下式的时候，可以保证最低的误差率。$$k=\cfrac{m}{n}ln2$$下图(摘自wikipedia) 表示在最优hash函数个数的情况下，不同m,n之间误差率关系。 从上图可以看到当存储10亿个元素时使用4GB的存储空间可以保证不到1e-06的错误率。可以看到bloomfilter在实现高空间利用率的同时可以保证较低误差率。 Leveldb 实现leveldb bloomfilter 实现在util/bloom.cc 成员变量以及构造函数1234567891011121314151617class BloomFilterPolicy : public FilterPolicy &#123; private: // 平均每个key拥有的bit 数目 size_t bits_per_key_; // hash function 的个数 size_t k_; public: explicit BloomFilterPolicy(int bits_per_key) : bits_per_key_(bits_per_key) &#123; // We intentionally round down to reduce probing cost a little bit // 按照上面的公式设定hash函数的个数 k_ = static_cast&lt;size_t&gt;(bits_per_key * 0.69); // 0.69 =~ ln(2) if (k_ &lt; 1) k_ = 1; if (k_ &gt; 30) k_ = 30; &#125; &#125;; CreateFilter将传入的n个key 存储到bloomfilter 中，bloomfilter结果使用string存储。123456789101112131415161718192021222324252627282930313233343536virtual void CreateFilter(const Slice* keys, int n, std::string* dst) const &#123; // Compute bloom filter size (in both bits and bytes) // bloomfilter 需要多少bit size_t bits = n * bits_per_key_; // For small n, we can see a very high false positive rate. Fix it // by enforcing a minimum bloom filter length. if (bits &lt; 64) bits = 64; // 对齐,方便内存读写以及后续位置索引 size_t bytes = (bits + 7) / 8; bits = bytes * 8; // 在string 中分配空间 const size_t init_size = dst-&gt;size(); dst-&gt;resize(init_size + bytes, 0); // string 的最后一个byte存储使用的hash 函数的个数 dst-&gt;push_back(static_cast&lt;char&gt;(k_)); // Remember # of probes in filter // 获得string内部的char 型数组 char* array = &amp;(*dst)[init_size]; // 逐个将每个key 写入bloom fliter for (int i = 0; i &lt; n; i++) &#123; // Use double-hashing to generate a sequence of hash values. // See analysis in [Kirsch,Mitzenmacher 2006]. // leveldb 使用一个hash 函数，每次对hash值向右循环移位17个bit来模拟实现多个hash 函数的效果 uint32_t h = BloomHash(keys[i]); // 每次向右循环移位17个bit const uint32_t delta = (h &gt;&gt; 17) | (h &lt;&lt; 15); // Rotate right 17 bits for (size_t j = 0; j &lt; k_; j++) &#123; // 在整个bit 数组的位置 const uint32_t bitpos = h % bits; // 在char型数组的位置 array[bitpos/8] |= (1 &lt;&lt; (bitpos % 8)); // 更新获得一个新的hash 数值 h += delta; &#125; &#125; &#125; KeyMayMatch判断一个 key 在bloomfilter中是否存在。12345678910111213141516171819202122232425262728293031virtual bool KeyMayMatch(const Slice&amp; key, const Slice&amp; bloom_filter) const &#123; const size_t len = bloom_filter.size(); if (len &lt; 2) return false; const char* array = bloom_filter.data(); // 最后一个byte数值代表使用了多少hash函数 // 除最后一个byte之外代表bit数组 const size_t bits = (len - 1) * 8; // Use the encoded k so that we can read filters generated by // bloom filters created using different parameters. const size_t k = array[len-1]; if (k &gt; 30) &#123; // Reserved for potentially new encodings for short bloom filters. // Consider it a match. return true; &#125;// 使用相同的方法模拟多个hash函数计算的hash值 uint32_t h = BloomHash(key); const uint32_t delta = (h &gt;&gt; 17) | (h &lt;&lt; 15); // Rotate right 17 bits for (size_t j = 0; j &lt; k; j++) &#123; const uint32_t bitpos = h % bits; // 找到一个bit位置不匹配，提前返回false // 在bit数组中位置的索引和设置时的方法一致 if ((array[bitpos/8] &amp; (1 &lt;&lt; (bitpos % 8))) == 0) return false; // 更新获得下一个hash value h += delta; &#125; // 全部匹配return true return true; &#125; BloomFilter 应用场景由于其高效的空间效率，bloomfilter 可以应用于以下场景： 爬虫系统记录以经爬取过的url 垃圾邮件过滤 p2p 网络中查找资源操作: 使用一个bloomfilter 保存拥有此资源的网络通路 广播信息时检查某个ip是否发包 字典纠错：将所有单词存储到bloomfilter中，如果不存在则认为是一个错误拼写 CDN 代理缓存: 每个cache 服务器上使用bloomfilter 存储兄弟cache 服务器上是否有缓存关键字，如果没有则可以避免一次查找 总结Bloomfilter 是一种设计巧妙的数据结构，由于其良好的空间效率，可以用于判断一个元素是否包含于海量元素集合的场景。Leveldb 的实现的bloomfilter 可以灵活配置hash 函数的个数，使用一个hash 函数模拟任意多个hash 函数的场景，并将使用hash函数的个数存储到bloomfilter编码结果中。除此之外，leveldb bloomfilter 实现bit数组个数，hash函数个数以及存储元素个数的最优配置，保证最低的误差率。]]></content>
      <categories>
        <category>Backend Development</category>
      </categories>
      <tags>
        <tag>Leveldb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leveldb skiplist 实现以及解析]]></title>
    <url>%2F2018%2F04%2F27%2FLeveldb-skiplist-%E5%AE%9E%E7%8E%B0%E4%BB%A5%E5%8F%8A%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[skiplist 原理介绍skiplist 由William Pugh 在论文Skip Lists: A Probabilistic Alternative to Balanced Trees 中提出的一种数据结构，skiplist 是一种随机化存储的多层线性链表结构，插入，查找，删除的都是对数级别的时间复杂度。skiplist 和平衡树有相同的时间复杂度，但相比平衡树，skip实现起来更简单。 下图是wikipedia 上一个一个高度为4的skiplist 从垂直角度看，skiplist 的第0层以单链表的形式按照从小到大的顺序存储全部数据，越高层的链表的节点数越少，这样的特点实现了skiplist 在定位某个位置时，通过在高层较少的节点中查找就可以确定需要定位的位置处于哪个区间，从高层到低层不断缩小查找区间。以上图为例，比如我们需要在skiplist中查找2，查找过程如下，首先在最高层确定到2只可能处于1-&gt;NULL 这个区间，然后在第三层查找确定 2 只可能处于 1-&gt;4 这个区间，继续在第二层查找确定2 只可能处于1-3 这区间，最后在最底层1-&gt;3 这个区间查找可以确定2 是否存在于skiplist之中。下图是wikipedia上提供的表示skiplist插入过程的一张gif,此图形象的说明了skiplist 定位以及插入节点的过程。从水平角度来看，skiplist实现在链表开始的时候设置名为head 的哨兵节点，每一层链表的结束为止全部指向NULL。 leveldb 实现leveldb 实现的skiplist位于db/skiplist.h。 skiplist Node 类型定义123456789101112131415161718192021222324252627282930313233343536373839// Implementation details followtemplate&lt;typename Key, class Comparator&gt;struct SkipList&lt;Key,Comparator&gt;::Node &#123; explicit Node(const Key&amp; k) : key(k) &#123; &#125; // Node 存储的内容 Key const key; // Accessors/mutators for links. Wrapped in methods so we can // add the appropriate barriers as necessary. // 获取当前节点在指定level的下一个节点 Node* Next(int n) &#123; assert(n &gt;= 0); // Use an 'acquire load' so that we observe a fully initialized // version of the returned Node. return reinterpret_cast&lt;Node*&gt;(next_[n].Acquire_Load()); &#125; // 将当前节点在指定level的下一个节点设置为x void SetNext(int n, Node* x) &#123; assert(n &gt;= 0); // Use a 'release store' so that anybody who reads through this // pointer observes a fully initialized version of the inserted node. next_[n].Release_Store(x); &#125; // 无内存屏障版本set。关于leveldb 内存屏障在新一篇博客介绍 // No-barrier variants that can be safely used in a few locations. Node* NoBarrier_Next(int n) &#123; assert(n &gt;= 0); return reinterpret_cast&lt;Node*&gt;(next_[n].NoBarrier_Load()); &#125; void NoBarrier_SetNext(int n, Node* x) &#123; assert(n &gt;= 0); next_[n].NoBarrier_Store(x); &#125; private: // Array of length equal to the node height. next_[0] is lowest level link. // 当前节点的下一个节点数组 port::AtomicPointer next_[1];&#125;; skiplist 类成员变量12345678910111213141516private: // 使用枚举类型定义skiplist 最高高度 enum &#123; kMaxHeight = 12 &#125;; // Immutable after construction // 用户定制的比较器 Comparator const compare_; // leveldb 实现的简单的内存分配器 Arena* const arena_; // Arena used for allocations of nodes // skiplist 的前置哨兵节点 Node* const head_; // Modified only by Insert(). Read racily by readers, but stale // values are ok. // 记录当前skiplist使用的最高高度 port::AtomicPointer max_height_; // Height of the entire list skiplist 插入12345678910111213141516171819202122232425262728293031323334353637383940template&lt;typename Key, class Comparator&gt;void SkipList&lt;Key,Comparator&gt;::Insert(const Key&amp; key) &#123; // TODO(opt): We can use a barrier-free variant of FindGreaterOrEqual() // here since Insert() is externally synchronized. // 声明prev节点，代表插入位置的前一个节点 Node* prev[kMaxHeight]; // 使用FindGreaterOrEqual函数找到第一个大于等于插入key的位置 Node* x = FindGreaterOrEqual(key, prev); // Our data structure does not allow duplicate insertion assert(x == NULL || !Equal(key, x-&gt;key)); // 使用随机数获取该节点的插入高度 int height = RandomHeight(); if (height &gt; GetMaxHeight()) &#123; // 大于当前skiplist 最高高度的话，将多出的来的高度的prev 设置为哨兵节点 for (int i = GetMaxHeight(); i &lt; height; i++) &#123; prev[i] = head_; &#125; //fprintf(stderr, "Change height from %d to %d\n", max_height_, height); // It is ok to mutate max_height_ without any synchronization // with concurrent readers. A concurrent reader that observes // the new value of max_height_ will see either the old value of // new level pointers from head_ (NULL), or a new value set in // the loop below. In the former case the reader will // immediately drop to the next level since NULL sorts after all // keys. In the latter case the reader will use the new node.// 跟新max_height_ max_height_.NoBarrier_Store(reinterpret_cast&lt;void*&gt;(height)); &#125; // 创建要插入的节点对象 x = NewNode(key, height); for (int i = 0; i &lt; height; i++) &#123; // NoBarrier_SetNext() suffices since we will add a barrier when // we publish a pointer to "x" in prev[i]. // 首先将x的next 指向prev 的下一个节点 x-&gt;NoBarrier_SetNext(i, prev[i]-&gt;NoBarrier_Next(i)); // 将prev 指向x prev[i]-&gt;SetNext(i, x); &#125;&#125; skiplist 查找1234567891011template&lt;typename Key, class Comparator&gt;bool SkipList&lt;Key,Comparator&gt;::Contains(const Key&amp; key) const &#123; // 找到大于等于当前key的第一个node,然后判断node 的key // 和传入的key 是否相等 Node* x = FindGreaterOrEqual(key, NULL); if (x != NULL &amp;&amp; Equal(key, x-&gt;key)) &#123; return true; &#125; else &#123; return false; &#125;&#125; FindGreaterOrEqual函数的作用是找到第一个大于或等于指定的key 的node,以及该node的前一个node123456789101112131415161718192021222324252627template&lt;typename Key, class Comparator&gt;typename SkipList&lt;Key,Comparator&gt;::Node* SkipList&lt;Key,Comparator&gt;::FindGreaterOrEqual(const Key&amp; key, Node** prev) const &#123; Node* x = head_; // level 从0 开始编码 int level = GetMaxHeight() - 1; while (true) &#123; // 定位到当前level的下一个节点 Node* next = x-&gt;Next(level); // key 没有在当前区间 if (KeyIsAfterNode(key, next)) &#123; // Keep searching in this list x = next; &#125; else &#123; // key 在当前区间，在低level 继续查找， // 在查找的同时设置prev 节点 if (prev != NULL) prev[level] = x; // 在最低level找到相应位置 if (level == 0) &#123; return next; &#125; else &#123; // Switch to next list level--; &#125; &#125; &#125;&#125; RandomHeight利用随机数实现每次有4分之一的概率增长高度。123456789101112template&lt;typename Key, class Comparator&gt;int SkipList&lt;Key,Comparator&gt;::RandomHeight() &#123; // Increase height with probability 1 in kBranching static const unsigned int kBranching = 4; int height = 1; while (height &lt; kMaxHeight &amp;&amp; ((rnd_.Next() % kBranching) == 0)) &#123; height++; &#125; assert(height &gt; 0); assert(height &lt;= kMaxHeight); return height;&#125; FindLessThan123456789101112131415161718192021222324template&lt;typename Key, class Comparator&gt;typename SkipList&lt;Key,Comparator&gt;::Node*SkipList&lt;Key,Comparator&gt;::FindLessThan(const Key&amp; key) const &#123; Node* x = head_; int level = GetMaxHeight() - 1; while (true) &#123; assert(x == head_ || compare_(x-&gt;key, key) &lt; 0); \// 在当前level 查找 Node* next = x-&gt;Next(level); // if 分支为true 的时候表示需要查找的位置在当前区间 if (next == NULL || compare_(next-&gt;key, key) &gt;= 0) &#123; // 在最后一层停止查找 if (level == 0) &#123; return x; &#125; else &#123; // Switch to next list level--; &#125; &#125; else &#123; // 在当前level 就找到了比key 小的节点 x = next; &#125; &#125;&#125; 总结skiplist最底层单链表有序存储全部元素，利用多层有序链表的结构实现加速索引的功能，处于越高level 节点的链表越稀疏查找速度越快，在不断向下查找的过程中不断缩小查找空间。总的来说，skiplist 是一种设计巧妙的数据结构，leveldb 的实现可读性高，容易理解。]]></content>
      <categories>
        <category>Backend Development</category>
      </categories>
      <tags>
        <tag>Leveldb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++ 拼接长字符串]]></title>
    <url>%2F2018%2F04%2F26%2FC-%E6%8B%BC%E6%8E%A5%E9%95%BF%E5%AD%97%E7%AC%A6%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[C++ 拼接长字符串c++ string 类型提供 opearator+= 以及 append 方法进行字符串拼接，本文探讨c++拼接长字符串执行效率最高的方法。以下是四种实现方式。 实现方式operator +=使用 string 类提供重载 += 方法拼接字符串。示例： 1234567891011// length 参数代表拼接的字符串长度void composeLongstringWithOperator(const unsigned int length,std::string&amp; long_string)&#123; for (size_t i = 0; i &lt; length / 9; i++) &#123; char str[10]; // randStr 方法构造长度为9的随机字符串 long_string += (randStr(str,9)); &#125;&#125; append使用 string 类提供的append 方法拼接字符串。示例： 12345678void composeLongstringWithAppend(const unsigned int length,std::string&amp; long_string)&#123; for (size_t i = 0; i &lt; length / 9; i++) &#123; char str[10]; long_string.append(randStr(str,9)); &#125;&#125; reserve &amp;&amp; operator +=在拼接字符串之前为string 对象提前分配空间，然后使用 += 方法进行拼接，示例： 123456789void composeLongstringWithReserveAndOperator(const unsigned int length,std::string&amp; long_string)&#123; long_string.reserve(length); for (size_t i = 0; i &lt; length / 9; i++) &#123; char str[10]; long_string += (randStr(str,9)); &#125;&#125; reserve &amp;&amp; append在拼接字符串之前为string 对象提前分配空间，然后使用 append 方法进行拼接，示例： 12345678void composeLongstringWithAppend(const unsigned int length,std::string&amp; long_string)&#123; for (size_t i = 0; i &lt; length / 9; i++) &#123; char str[10]; long_string.append(randStr(str,9)); &#125;&#125; 性能测试测试方法进行10000次长字符串拼接，统计每种方式下耗时，示例代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;ctime&gt;#include &lt;chrono&gt;char* randStr(char* str,const int len)&#123; int i; for(i = 0; i &lt; len; ++i) &#123; str[i] = 'A' + rand() % 26; &#125; str[++i] = '\0'; return str;&#125;int main(int argc, char* argv[])&#123; (void) argc; // 第一个参数代表生成的字符串的长度 const unsigned int length = atoi(argv[1]); // 第二个参数代表使用哪种方法进行拼接 const unsigned int type = atoi(argv[2]); srand(time(NULL)); auto start = std::chrono::high_resolution_clock::now(); switch(type) &#123; case 1: std::cout &lt;&lt; "composeLongstringWithReserveAndAppend"; for(int i = 0; i &lt; 10000; i++) &#123; std::string long_string; composeLongstringWithReserveAndAppend(length,long_string); &#125; break; case 2: std::cout &lt;&lt; "composeLongstringWithReserveAndOperator"; for(int i = 0; i &lt; 10000; i++) &#123; std::string long_string; composeLongstringWithReserveAndOperator(length,long_string); &#125; break; case 3: std::cout &lt;&lt; "composeLongstringWithAppend"; for(int i = 0; i &lt; 10000; i++) &#123; std::string long_string; composeLongstringWithAppend(length,long_string); &#125; break; case 4: std::cout &lt;&lt; "composeLongstringWithOperator"; for(int i = 0; i &lt; 10000; i++) &#123; std::string long_string; composeLongstringWithOperator(length,long_string); &#125; break; default: return 0; &#125; auto end = std::chrono::high_resolution_clock::now(); std::chrono::duration&lt;double&gt; diff = end - start; std::cout &lt;&lt; " cost " &lt;&lt; 1000 * diff.count() &lt;&lt; " ms\n"; return 0;&#125; 编译1g++ -std=c++11 -O3 compose_long_string.cpp -o compose_long_string 性能表现长字符串长度为1000000，每种方法进行10000次拼接，四种方法的耗时如下： method cost (ms) reserve &amp;&amp; append 117304 reserve &amp;&amp; operator 122998 append 125682 operator 129071 结论 针对较短字符串，使用reserve提前分配空间对性能提升意义不大，当字符串的长度很长是，使用reserve方法提前分配空间可以带来比较大的性能提升。 operator+= 和 append 方法在进行字符串拼接时性能表现几乎一致。原因是stl 实现的operator+= 方式实际是直接调用了append 方法。 综上，拼接长字符串时最优方式是 reserve &amp;&amp; append。]]></content>
      <categories>
        <category>Backend Development</category>
      </categories>
      <tags>
        <tag>High performance programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读书短评]]></title>
    <url>%2F2018%2F04%2F19%2F%E8%AF%BB%E4%B9%A6%E7%9F%AD%E8%AF%84%2F</url>
    <content type="text"><![CDATA[2018-04-19《人类简史》现代社会建立在人类的重重假设，回到非洲大草原摘个野果子吃就很快乐~从物种繁衍的角度来看，小麦，家畜是比人要更成功的。但是物种繁衍的成功不等同于个体的快乐。有人可能会说小麦，家畜的一生都很短暂，但相对浩瀚宇宙来说，人的一生也是沧海一粟。都是匆匆过客，如果能更多卸下捆绑获得真正的快乐才是生活的真谛。 《活着》所有的困难都会过去，活着本身就是最大的意义。 《围城》很多现象都可以用围城思想来解释，里面的人想出去，外边的人想进去 《明朝那些事》除了朱元璋打天下，朱棣篡位，剩下大部分篇幅都在讲官场政治，当年明月本是公务员，写官场政治这些也非常熟悉，所以后面那几本叫《明朝官场那些事》可能更合适。 《解忧杂货店》高产如东野，可能写悬疑探案类更费精力，所以来碗鸡汤喂喂。书中所有故事都说明了影射一个道理，向别人寻求建议的时候，自己心理已经有答案，只不过是希望别人加强一下自己的信念，如果建议和自己想的相反，你会找别的人再给你建议~ 《白鹿原》具有西北特色的低配百年孤独。读的过程中可以感受到西北作家的朴实的文风，稍微结合一点贵party的black历史就可以如此精彩！另外，读的过程中经常想吃羊肉泡馍~ 《苏东坡传》上学课本上说的伟大的文学家，书画家。而借用林语堂在前言中对苏东坡的描述: “苏东坡是一个无可救药的乐天派、一个伟大的人道主义者、一个百姓的朋友、一个大文豪、大书法家、创新的画家、造酒试验家、一个工程师、一个憎恨清教徒主义的人、一位瑜伽修行者佛教徒、巨儒政治家、一个皇帝的秘书、酒仙、厚道的法官、一位在政治上专唱反调的人。一个月夜徘徊者、一个诗人、一个小丑”,相比之下自己的生活单调了好多，所以应该在自己身上点更多天赋。不写了，中午吃东坡肉。 2018-04-20《天龙八部》乔峰，段誉，虚竹，慕容复所有主要角色无不苦难。众生皆苦，无欲则刚，修炼成佛的还是没几个。 《百年孤独》人生来孤独，所以需要把雕刻好小金鱼后融掉重新再雕，需要吃土排解孤独。随便拉出个人来，对他说“我想你才是真正的孤独吧！”他都会感到你是他的知音~ 《追风筝的人》“为你，千千万万遍” 对主人的忠诚和对友谊的坚持要有多深才能说出这样的话。 《鹿鼎记》“老子不干了” 在康熙皇帝和天地会之间脚踏两条船太累了！在这两个没法做决定的选择面前，干脆不选了，全都qtmd！ 《黄金时代》在混乱的年代，黄金时代年纪，有个人一起实践伟大革命友谊也很幸福吧！ 2018-04-25《万寿寺》万寿寺的主要作用之一是为了老佛爷乘船去颐和园游玩的途中休息一下。之所以老佛爷成为了老佛爷是因为咸丰帝从她身上爬起来时那条射过精的疲软的jb,王小波称之为历史的脐带(hahaha)。所以他在万寿寺搞一些历史的脐带考，领导很不喜欢！ 《了不起的盖茨比》对黛西的爱情是盖茨比先生的一道绿光，绿光指引他前行，我猜在他临死之前，绿光也不曾熄灭。 《指数基金投资指南》钉大的扫盲科普书籍，1 h 看完，后面继续有选择的抄E大和钉大的作业。 2018-05-02《笑傲江湖》金庸武侠里面政治色彩很重的一本，前面甚嚣尘土的左盟主还是被岳君子阴了。伪君子比真小人更可怕。 《神雕侠侣》侠之大者为国为民，杨过在最后领悟此道理，也解开了杀父之仇的心结。在经过无数挫折之后终于和小龙女走到一起，只是苦了那些“一见杨过误终身”的少女们~ 2018-05-03《月亮与六便士》“忘了是谁说过，为了让灵魂受益，每天应该做两件自己不喜欢的事情，说着这句话的是一个富有智慧的人，我把这句格言谨记在新，遵照行事，因此每天我醒来起床，每晚上床睡下” 毛姆这句话描述的境界是生活中所做的任何事都是自己发自肺腑开心的事，这比诗和远方的境界高多了。我承认自己不可能达到那种境界，只希望自己在低头捞便士的同时不要忘了抬头看一下明亮的月亮。 《1984》“Big brother is watching you.”,原本影射苏联的一书放在今日天朝也并无太多违和。修宪之后，海康威视大涨就让我想到1984中的场景，依据相同的逻辑，中证传媒一定不会有大发展，军工企业虽然垃圾，但会有很大机会。不知道这书啥时候成为禁书。 《寻找无双》王仙客在寻找无双的过程中困难重重，我们追寻的理想也同样如此吧，不过无所谓，重要的反而是追寻理想的过程吧！ 《革命时期的爱情》所有混乱的事情，如果是放在革命时期也就显得不那么难以解释。X海鹰作为先进青年在挽救堕落青年的王二的时候怎么可以动歪心思！ 《爱你就像爱生命》王小波李银河书信整理合集。李银河在书中表示说自己是回应了王小波热烈的感情，同时对他的爱也变得炽烈。最喜欢里面的两句活，“一想起你我这张丑脸上就泛起笑容”，“你好哇，李银河”。 2018-05-08《蒋介石与现代中国》讲述了委员长上位，完成中国形式上统一，抗日战争，国共内战，退守台湾五个阶段的大事。感受到那个动荡的时代波兰壮阔的历史，比历史课本中看到人物丰富立体。书中对抗日初期我党对抗日的态度，委员长对美玲的追求，退守台湾后两位大佬心照不宣共同薅美苏羊毛给我留下很深印象。最后留下在青岛花石楼里偶然看到的委员长一张诡异的微笑图。 《天才在左，疯子在右》初读之后非常震撼，每个人的精神世界都是非常奇妙，即使是本人无法完全洞悉自己的全部想法。所谓精神病的概念，更多的是说那帮人的想法和社会主流价值观所要求的不一致。心理学是如此奇妙。 《三体》印象最深的是第二部中黑暗丛林法则，这个原则放到现在的社会也不无道理。看书过程中不断为作者磅礴而又严谨的想象所感叹，科幻的同时还可以看到作者对人性的思考，很赞。 2018-05-15《霍乱时期的爱情》男主一生的主题就是对女主爱情的追求，在认识女主之后男主做的所有事情都是以赢得爱情为目标，和神雕侠侣里一见杨过毁终生的少女有些相似的感觉。书中描写了各种种类的爱情，读的同时还是感觉到和百年孤独类似的荒芜感，不同的是从这本书里还读到老爷子幽默的地方(比如女主从无限讨厌茄子，到无限热爱茄子，哈哈)。看到豆瓣里很有意思的一个书评，“屌丝战胜高帅富的方法就是活得比高帅富久，所以屌丝们赶紧锻炼身体去吧” 2018-05-22《谁在世界中心》书中一直在强调地缘政治的重要性，大部分篇幅都在讲现在是海权时代，海洋强国才是真的强国。感到新奇的一点是如果继续全球变暖，北冰洋加速融化，俄罗斯会成为另外一个海洋大国，地缘优势会大大增加，那时候老毛子会更跳~ 《精进》作为非常讨厌鸡汤以及成功学的我，在采铜的这本书中看到了超多的干货，里面很多思想和刘未鹏博客中的观点不谋而合。总之就是信息量超大的一本书。最近逛知乎看到采铜已经离开知乎了，这也并不奇怪，知乎现在已经是段子手和装逼犯集中的地方了，没那么多大佬了。 2018-05-25《送你一颗子弹》刘瑜老师才是真正文艺女青年，整本书大部分是刘瑜老师在06-08年的生活见闻，其中充满了对生活，爱情，政治，自由的思考，文笔朴实犀利又不乏幽默，很赞。相比起来，生活中大部分自诩文艺的女青年还是差距太大了，建议她们多读读马克思，少看些张小娴吧。 2018-06-01《撒哈拉的故事》上高中还是本科的时候看过一遍。感觉到三毛作为一个文艺女青年也是够燥够任性，好好的在西班牙享受现代资本主义的灯红酒绿突然要跑到撒哈拉沙漠去。到撒哈拉之后自力更生经营自己的生活，见识了好多的奇奇怪怪的习俗同时又冒了好多险。总的来说，再次读的过程中不断感受到这位文艺女青年强大的气场。 2018-07-06《小王子》小王子在各个星球旅行，遇到形形色色各式各样不能理解的大人。这对应到现实生活中也正是如此，我们做的大部分事情可能都是没啥实际意义或者说已经脱离原本的想法，拥有孩子的天真以及直接了当实在难能可贵。 《未来简史》 待续 《盗墓笔记》 待续]]></content>
      <categories>
        <category>Reading</category>
      </categories>
      <tags>
        <tag>reading</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leveldb varint 解析]]></title>
    <url>%2F2018%2F04%2F17%2FLeveldb-varint-%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[varint 介绍我们知道 uint32_t 类型占用4个byte，uint64_t 占用8个byte, 但是对于比较小的数字来说，使用uint32_t 或者uint64_t 存储会比较浪费，varint 的思想是根据数字所需大小使用unsigned char* 指针存储数据，节约内存。 leveldb 实现leveldb 中的varint实现原理简单，每个byte 使用最高bit的 0/1值代表此整数值是否结束，用剩下的7个bit 存储实际的数值。知道最后一个byte 的最高bit 是0 表示整数结束。因此小于128的数据都可以用一个byte 来表示，大于128的，比如说300，使用varint 编码的话需要两个字节10101100 0000 0010 leveldb 32位int变长编码实现正常情况下，32位int占用4个byte, varint 编码中每个byte 中的最高bit 用来表示该byte 是不是最后一个byte,所以针对大的数varint 编码可能需要5个byte才能表示。leveldb 实现中5个if 分支对应varint占用1到5个byte 的情况。123456789101112131415161718192021222324252627char* EncodeVarint32(char* dst, uint32_t v) &#123; // Operate on characters as unsigneds unsigned char* ptr = reinterpret_cast&lt;unsigned char*&gt;(dst); static const int B = 128; if (v &lt; (1&lt;&lt;7)) &#123; *(ptr++) = v; &#125; else if (v &lt; (1&lt;&lt;14)) &#123; *(ptr++) = v | B; *(ptr++) = v&gt;&gt;7; &#125; else if (v &lt; (1&lt;&lt;21)) &#123; *(ptr++) = v | B; *(ptr++) = (v&gt;&gt;7) | B; *(ptr++) = v&gt;&gt;14; &#125; else if (v &lt; (1&lt;&lt;28)) &#123; *(ptr++) = v | B; *(ptr++) = (v&gt;&gt;7) | B; *(ptr++) = (v&gt;&gt;14) | B; *(ptr++) = v&gt;&gt;21; &#125; else &#123; *(ptr++) = v | B; *(ptr++) = (v&gt;&gt;7) | B; *(ptr++) = (v&gt;&gt;14) | B; *(ptr++) = (v&gt;&gt;21) | B; *(ptr++) = v&gt;&gt;28; &#125; return reinterpret_cast&lt;char*&gt;(ptr);&#125; 对应的varint 解码的思路是从低byte 到高byte遍历，直到找到最后一个表示编码结束的byte(判断条件是 byte &amp; 128 == 1)，代码如下123456789101112131415161718192021222324252627282930313233// 针对一个byte情况直接处理，大于一个byte 时，// 使用 GetVarint32PtrFallback 处理inline const char* GetVarint32Ptr(const char* p, const char* limit, uint32_t* value) &#123; if (p &lt; limit) &#123; uint32_t result = *(reinterpret_cast&lt;const unsigned char*&gt;(p)); if ((result &amp; 128) == 0) &#123; *value = result; return p + 1; &#125; &#125; return GetVarint32PtrFallback(p, limit, value);&#125;const char* GetVarint32PtrFallback(const char* p, const char* limit, uint32_t* value) &#123; uint32_t result = 0; for (uint32_t shift = 0; shift &lt;= 28 &amp;&amp; p &lt; limit; shift += 7) &#123; uint32_t byte = *(reinterpret_cast&lt;const unsigned char*&gt;(p)); p++; if (byte &amp; 128) &#123; // More bytes are present result |= ((byte &amp; 127) &lt;&lt; shift); &#125; else &#123; result |= (byte &lt;&lt; shift); *value = result; return reinterpret_cast&lt;const char*&gt;(p); &#125; &#125; return NULL;&#125; 64位变长编码的实现64位整形最多需要(10 * 8 - 10 &gt; 64) 10个byte 来保存，类似于32位int的编码，需要写10个if-else 分支，针对64位整形的编码，leveldb 给出了更优雅的解决方案。12345678910char* EncodeVarint64(char* dst, uint64_t v) &#123; static const int B = 128; unsigned char* ptr = reinterpret_cast&lt;unsigned char*&gt;(dst); while (v &gt;= B) &#123; *(ptr++) = (v &amp; (B-1)) | B; v &gt;&gt;= 7; &#125; *(ptr++) = static_cast&lt;unsigned char&gt;(v); return reinterpret_cast&lt;char*&gt;(ptr);&#125; 针对64位整形的解码，leveldb 实现同样是类似的逻辑。也是从低位byte 开始向高位byte遍历判断编码是否结束。代码实现如下12345678910111213141516const char* GetVarint64Ptr(const char* p, const char* limit, uint64_t* value) &#123; uint64_t result = 0; for (uint32_t shift = 0; shift &lt;= 63 &amp;&amp; p &lt; limit; shift += 7) &#123; uint64_t byte = *(reinterpret_cast&lt;const unsigned char*&gt;(p)); p++; if (byte &amp; 128) &#123; // More bytes are present result |= ((byte &amp; 127) &lt;&lt; shift); &#125; else &#123; result |= (byte &lt;&lt; shift); *value = result; return reinterpret_cast&lt;const char*&gt;(p); &#125; &#125; return NULL;&#125; 总结varint 的思想是针对32位或者64位整形类型来说存储的大部分数据都是多余的，因此使用每个byte的最高位来标识编码是否结束，使用一个char 型指针存储编码的结果，针对很多情况可以节约存储空间。]]></content>
      <categories>
        <category>Backend Development</category>
      </categories>
      <tags>
        <tag>Leveldb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Memcached hashtable解析]]></title>
    <url>%2F2018%2F04%2F11%2FMemcached-hashtable%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[介绍Memcached中实现了高性能的hashtable。其解决hash冲突的方法采用拉链法。当hashtable 中存储的item个数大于容器大小的1.5倍的时候通知线程进行hashtable 扩容，为了保证在扩容期间的读写性能，扩容线程默认每次只迁移一个bucket。设置一个变量标识当前的迁移进度，在进行读写操作时根据此变量确定是去 old_hashtable 还是 primary_hashtable 进行操作。 代码解析主要接口初始化12345678910111213141516171819/*数组的大小都是2指数次幂，这样的好处是可以将 index % hashsize 变为 index &amp; hashmask*/#define hashsize(n) ((ub4)1&lt;&lt;(n))#define hashmask(n) (hashsize(n)-1)// 初始化函数的作用是为主表分配空间void assoc_init(const int hashtable_init) &#123; if (hashtable_init) &#123; hashpower = hashtable_init; &#125; primary_hashtable = calloc(hashsize(hashpower), sizeof(void *)); if (! primary_hashtable) &#123; fprintf(stderr, "Failed to init hashtable.\n"); exit(EXIT_FAILURE); &#125; STATS_LOCK(); stats_state.hash_power_level = hashpower; stats_state.hash_bytes = hashsize(hashpower) * sizeof(void *); STATS_UNLOCK();&#125; 查找hash 查找的逻辑是优先使用hash 预算定位到bucket,然后循环bucket 链表找到指定的key。需要理解的地方在于查找时可能存在hashtable 正在进行扩展，所以需要确定是在old_hashtable还是 primary_hashtable 进行查找。 123456789101112131415161718192021222324252627item *assoc_find(const char *key, const size_t nkey, const uint32_t hv) &#123; item *it; unsigned int oldbucket; /* expanding 标识扩展是否完成。 expand_bucket表示当前扩展的进度，使用位与操作查找bucket位置 */ if (expanding &amp;&amp; (oldbucket = (hv &amp; hashmask(hashpower - 1))) &gt;= expand_bucket) &#123; it = old_hashtable[oldbucket]; &#125; else &#123; it = primary_hashtable[hv &amp; hashmask(hashpower)]; &#125; item *ret = NULL; int depth = 0; // 循环单链表查找指定key while (it) &#123; if ((nkey == it-&gt;nkey) &amp;&amp; (memcmp(key, ITEM_key(it), nkey) == 0)) &#123; ret = it; break; &#125; it = it-&gt;h_next; ++depth; &#125; MEMCACHED_ASSOC_FIND(key, nkey, depth); return ret;&#125; 插入插入的主要逻辑是找到指定桶的位置，将当前插入的节点设置为桶中位置的链表头结点位置，并且重新设置桶中元素的value123456789101112131415161718int assoc_insert(item *it, const uint32_t hv) &#123; unsigned int oldbucket;// assert(assoc_find(ITEM_key(it), it-&gt;nkey) == 0); /* shouldn't have duplicately named things defined */ if (expanding &amp;&amp; (oldbucket = (hv &amp; hashmask(hashpower - 1))) &gt;= expand_bucket) &#123; it-&gt;h_next = old_hashtable[oldbucket]; old_hashtable[oldbucket] = it; &#125; else &#123; it-&gt;h_next = primary_hashtable[hv &amp; hashmask(hashpower)]; primary_hashtable[hv &amp; hashmask(hashpower)] = it; &#125; MEMCACHED_ASSOC_INSERT(ITEM_key(it), it-&gt;nkey); return 1;&#125; 删除删除接口的主要逻辑是使用_hashitem_before 函数找到要删除item前一个item指针位置，然后将此指针的位置直接指向被删除item 的下一个item 位置123456789101112131415161718void assoc_delete(const char *key, const size_t nkey, const uint32_t hv) &#123; item **before = _hashitem_before(key, nkey, hv); if (*before) &#123; item *nxt; /* The DTrace probe cannot be triggered as the last instruction * due to possible tail-optimization by the compiler */ MEMCACHED_ASSOC_DELETE(key, nkey); nxt = (*before)-&gt;h_next; (*before)-&gt;h_next = 0; /* probably pointless, but whatever. */ *before = nxt; return; &#125; /* Note: we never actually get here. the callers don't delete things they can't find. */ assert(*before != 0);&#125; 其他辅助函数_hashitem_before函数的作用是查找给定item的前一个节点的指针，在delete 接口中调用1234567891011121314151617static item** _hashitem_before (const char *key, const size_t nkey, const uint32_t hv) &#123; item **pos; unsigned int oldbucket; // 同理是确定是在old_hashtable 还是在primary_hashtable if (expanding &amp;&amp; (oldbucket = (hv &amp; hashmask(hashpower - 1))) &gt;= expand_bucket) &#123; pos = &amp;old_hashtable[oldbucket]; &#125; else &#123; pos = &amp;primary_hashtable[hv &amp; hashmask(hashpower)]; &#125; // 从头结点的位置开始顺序遍历单链表中的节点 while (*pos &amp;&amp; ((nkey != (*pos)-&gt;nkey) || memcmp(key, ITEM_key(*pos), nkey))) &#123; pos = &amp;(*pos)-&gt;h_next; &#125; return pos;&#125; assoc_expand函数的作用是执行hash表的扩容，执行的过程是将当前primary_hashtable 指定为old_hashtable, 为primary_hashtable 分配内存,primary_hashtable的大小是old_hashtable 的两倍，将标识是否在扩展的bool型变量 expanding 设置为true。将标识扩展进度的变量expand_bucket设置为0123456789101112131415161718192021/* grows the hashtable to the next power of 2. */static void assoc_expand(void) &#123; old_hashtable = primary_hashtable; primary_hashtable = calloc(hashsize(hashpower + 1), sizeof(void *)); if (primary_hashtable) &#123; if (settings.verbose &gt; 1) fprintf(stderr, "Hash table expansion starting\n"); hashpower++; expanding = true; expand_bucket = 0; STATS_LOCK(); stats_state.hash_power_level = hashpower; stats_state.hash_bytes += hashsize(hashpower) * sizeof(void *); stats_state.hash_is_expanding = true; STATS_UNLOCK(); &#125; else &#123; primary_hashtable = old_hashtable; /* Bad news, but we can keep running. */ &#125;&#125; assoc_start_expand函数的作用判断是否进行扩展，进行扩展的临界条件是hashtable 中item 个数大于hash 桶数的1.5倍。满足此临界条件时通知扩展线程进行扩展12345678910void assoc_start_expand(uint64_t curr_items) &#123; if (started_expanding) return; if (curr_items &gt; (hashsize(hashpower) * 3) / 2 &amp;&amp; hashpower &lt; HASHPOWER_MAX) &#123; started_expanding = true; pthread_cond_signal(&amp;maintenance_cond); &#125;&#125; start_assoc_maintenance_thread函数的作用是创建hash 扩展线程，可以根据用户指定的参数设置每次扩展多少个bucket。如果不指定此参数的话，默认每次只扩展一个bucket1234567891011121314151617int start_assoc_maintenance_thread() &#123; int ret; char *env = getenv("MEMCACHED_HASH_BULK_MOVE"); if (env != NULL) &#123; hash_bulk_move = atoi(env); if (hash_bulk_move == 0) &#123; hash_bulk_move = DEFAULT_HASH_BULK_MOVE; &#125; &#125; pthread_mutex_init(&amp;maintenance_lock, NULL); if ((ret = pthread_create(&amp;maintenance_tid, NULL, assoc_maintenance_thread, NULL)) != 0) &#123; fprintf(stderr, "Can't create thread: %s\n", strerror(ret)); return -1; &#125; return 0;&#125; assoc_maintenance_thread函数的作用是执行实际的bucket 扩展。具体解释见注释123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778static void *assoc_maintenance_thread(void *arg) &#123; mutex_lock(&amp;maintenance_lock); while (do_run_maintenance_thread) &#123; int ii = 0; /* There is only one expansion thread, so no need to global lock. */ // 循环每次扩展的全部bucket for (ii = 0; ii &lt; hash_bulk_move &amp;&amp; expanding; ++ii) &#123; item *it, *next; unsigned int bucket; void *item_lock = NULL; /* bucket = hv &amp; hashmask(hashpower) =&gt;the bucket of hash table * is the lowest N bits of the hv, and the bucket of item_locks is * also the lowest M bits of hv, and N is greater than M. * So we can process expanding with only one item_lock. cool! */ /* expand_bucket需要锁保护,由于处于同一个bucket 中的特性是这些item 的hv 的低N位是完全相同，对应的 item_lock 的位置靠hv 的低M位确定，由于item_lock 数组大小小于桶数组的大小，所以有 M &lt; N ,也就是说处 于同一个桶中的item拥有相同item_lock,所以在遍历桶中 所有的item 的时候不需要在额外获取item_lock。这里的 设计非常精妙~ */ if ((item_lock = item_trylock(expand_bucket))) &#123; /* 遍历bucket 中全部item,插入到 primary_hashtable 中相应bucket */ for (it = old_hashtable[expand_bucket]; NULL != it; it = next) &#123; next = it-&gt;h_next; bucket = hash(ITEM_key(it), it-&gt;nkey) &amp; hashmask(hashpower); it-&gt;h_next = primary_hashtable[bucket]; primary_hashtable[bucket] = it; &#125; // old_hashtable 中bucket 内容设置为空 old_hashtable[expand_bucket] = NULL; // 维护当前扩展的进度 expand_bucket++; /* 如果扩展已经全部完成则设置expanding为 false ,释放old_hashtable 的内存*/ if (expand_bucket == hashsize(hashpower - 1)) &#123; expanding = false; free(old_hashtable); STATS_LOCK(); stats_state.hash_bytes -= hashsize(hashpower - 1) * sizeof(void *); stats_state.hash_is_expanding = false; STATS_UNLOCK(); if (settings.verbose &gt; 1) fprintf(stderr, "Hash table expansion done\n"); &#125; &#125; else &#123; usleep(10*1000); &#125; // 释放资源 if (item_lock) &#123; item_trylock_unlock(item_lock); item_lock = NULL; &#125; &#125; // 如果不在进行扩展，则设置条件变量，等待被触发扩展 if (!expanding) &#123; /* We are done expanding.. just wait for next invocation */ started_expanding = false; pthread_cond_wait(&amp;maintenance_cond, &amp;maintenance_lock); /* assoc_expand() swaps out the hash table entirely, so we need * all threads to not hold any references related to the hash * table while this happens. * This is instead of a more complex, possibly slower algorithm to * allow dynamic hash table expansion without causing significant * wait times. */ pause_threads(PAUSE_ALL_THREADS); assoc_expand(); pause_threads(RESUME_ALL_THREADS); &#125; &#125; return NULL;&#125; 线程安全memcached 使用分段锁实现hashtable 线程安全，分段锁避免了hashtable 中全部的item公用一个锁，公用一个锁的会降低hashtable 的读写性能。下面部分代码是memcached 初始化分段锁数组的逻辑。1234567891011121314151617181920212223242526272829303132if (nthreads &lt; 3) &#123; power = 10;&#125; else if (nthreads &lt; 4) &#123; power = 11;&#125; else if (nthreads &lt; 5) &#123; power = 12;&#125; else if (nthreads &lt;= 10) &#123; power = 13;&#125; else if (nthreads &lt;= 20) &#123; power = 14;&#125; else &#123; /* 32k buckets. just under the hashpower default. */ power = 15;&#125;/* 保证分段锁的数目小于hashtable 桶的个数，这样设计的好处之一是在扩展的时候针对一个桶中的所有item 对应的是同一个item_lock*/if (power &gt;= hashpower) &#123; fprintf(stderr, "Hash table power size (%d) cannot be equal to or less than item lock table (%d)\n", hashpower, power); fprintf(stderr, "Item lock table grows with `-t N` (worker threadcount)\n"); fprintf(stderr, "Hash table grows with `-o hashpower=N` \n"); exit(1);&#125;item_lock_count = hashsize(power);item_lock_hashpower = power;// 分配分段锁数组item_locks = calloc(item_lock_count, sizeof(pthread_mutex_t));if (! item_locks) &#123; perror("Can't allocate item locks"); exit(1);&#125; 在对hashtable 进行多线程读写时，首先需要根据hash 算法计算出hv 值，然后根据hv 获取item_lock,获取到item_lock 之后再进行读写操作。这也从侧面解释了为什么memcached在扩展时默认每次只扩展一个bucket，因为在进行扩展的时候需要占有item_lock，每次执行扩展的bucket 数多会影响读写性能。 总结memcached 的hashtable是典型的拉链式hashtable,实现代码短小易读，使用一个线程进行hashtable的扩展以保证不会出现item增多导致哈希冲突激增降低读写性能的现象，除此之外使用分段锁来保证多线程的读写安全，相比全局锁也可以提升读写性能。memcached hashsize设置为2的整数次幂的设计非常精妙，首先这样可以将查找hash bucket索引的取余操作转化为对（hashsize-1）取按位与操作，在加上分段锁的数目大小小于hashsize 的设置可以保证一个bucket 中所有的item 对应于同一个分段锁，进而保证在扩展bucket中全部内容时只需要获取一次分段锁!]]></content>
      <categories>
        <category>Backend Development</category>
      </categories>
      <tags>
        <tag>Memcached hashtable</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++ 内存数据结构与二进制文件之间的序列化和反序列化]]></title>
    <url>%2F2018%2F04%2F10%2FC-%E5%86%85%E5%AD%98%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6%E4%B9%8B%E9%97%B4%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%2F</url>
    <content type="text"><![CDATA[应用场景许多后端检索server启动时候需要从文件加载到内存中构建索引，这个过程往往会消耗比较多的时间，这样会造成sever启动消耗比较多的时间，在存在多台服务器的时候会更加明显。我们可以将够构建索引的过程独立成一个单独的进程，此进程实现的功能是根据原始文件构建索引结构，并将索引结构序列化到本地二进制文件，Server在启动的时候只需要读取二进制文件就可以构造出索引结构，可以大大提高启动速度。 示例代码io.hpp ,对std::ifstream 以及std::ofstream 的封装，提供从vector序列化到二进制文件和从二进制文件反序列化到vector等接口123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122#ifndef IO_HPP#define IO_HPP#include &lt;string&gt;#include &lt;vector&gt;#include &lt;fstream&gt;class FileReader&#123; public: FileReader(const std::string&amp; filename) : input_stream(filename,std::ios::binary) &#123; &#125; /* Read count objects of type T into pointer dest */ template &lt;typename T&gt; void ReadInto(T *dest, const std::size_t count) &#123; static_assert(std::is_trivially_copyable&lt;T&gt;::value, "bytewise reading requires trivially copyable type"); if (count == 0) return; const auto &amp;result = input_stream.read(reinterpret_cast&lt;char *&gt;(dest), count * sizeof(T)); const std::size_t bytes_read = input_stream.gcount(); if (bytes_read != count * sizeof(T) &amp;&amp; !result) &#123; return; &#125; &#125; template &lt;typename T&gt; void ReadInto(std::vector&lt;T&gt; &amp;target) &#123; ReadInto(target.data(), target.size()); &#125; template &lt;typename T&gt; void ReadInto(T &amp;target) &#123; ReadInto(&amp;target, 1); &#125; template &lt;typename T&gt; T ReadOne() &#123; T tmp; ReadInto(tmp); return tmp; &#125; std::uint32_t ReadElementCount32() &#123; return ReadOne&lt;std::uint32_t&gt;(); &#125; std::uint64_t ReadElementCount64() &#123; return ReadOne&lt;std::uint64_t&gt;(); &#125; template &lt;typename T&gt; void DeserializeVector(std::vector&lt;T&gt; &amp;data) &#123; const auto count = ReadElementCount64(); data.resize(count); ReadInto(data.data(), count); &#125; private: std::ifstream input_stream;&#125;;class FileWriter&#123; public: FileWriter(const std::string&amp; filename) : output_stream(filename,std::ios::binary) &#123; &#125; /* Write count objects of type T from pointer src to output stream */ template &lt;typename T&gt; void WriteFrom(const T *src, const std::size_t count) &#123; static_assert(std::is_trivially_copyable&lt;T&gt;::value, "bytewise writing requires trivially copyable type"); if (count == 0) return; const auto &amp;result = output_stream.write(reinterpret_cast&lt;const char *&gt;(src), count * sizeof(T)); &#125; template &lt;typename T&gt; void WriteFrom(const T &amp;target) &#123; WriteFrom(&amp;target, 1); &#125; template &lt;typename T&gt; void WriteOne(const T tmp) &#123; WriteFrom(tmp); &#125; void WriteElementCount32(const std::uint32_t count) &#123; WriteOne&lt;std::uint32_t&gt;(count); &#125; void WriteElementCount64(const std::uint64_t count) &#123; WriteOne&lt;std::uint64_t&gt;(count); &#125; template &lt;typename T&gt; void SerializeVector(const std::vector&lt;T&gt; &amp;data) &#123; const auto count = data.size(); WriteElementCount64(count); return WriteFrom(data.data(), count); &#125; private: std::ofstream output_stream;&#125;;#endif binary_io.cpp12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include "io.hpp"#include &lt;iostream&gt;struct Data&#123; int a; double b; friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out,const Data&amp; data) &#123; out &lt;&lt; data.a &lt;&lt; "," &lt;&lt; data.b; return out; &#125;&#125;;template&lt;typename T&gt;void printData(const std::vector&lt;T&gt;&amp; data_vec)&#123; for (const auto data : data_vec) &#123; std::cout &lt;&lt; "&#123;" &lt;&lt; data &lt;&lt; "&#125; "; &#125; std::cout &lt;&lt; std::endl;&#125;template&lt;typename T&gt;void serializeVector(const std::string&amp; filename,const std::vector&lt;T&gt;&amp; data_vec)&#123; FileWriter file_writer(filename); file_writer.SerializeVector&lt;T&gt;(data_vec);&#125;template&lt;typename T&gt;void deserializeVector(const std::string&amp; filename,std::vector&lt;T&gt;&amp; data_vec)&#123; FileReader file_reader(filename); file_reader.DeserializeVector&lt;T&gt;(data_vec);&#125;int main()&#123; std::vector&lt;Data&gt; vec1 = &#123;&#123;1,1.1&#125;,&#123;2,2.2&#125;,&#123;3,3.3&#125;,&#123;4,4.4&#125;&#125;; std::cout &lt;&lt; "before write to binary file.\n"; printData(vec1); const std::string filename = "vector_data"; std::cout &lt;&lt; "serialize vector to binary file.\n"; serializeVector&lt;Data&gt;(filename,vec1); std::vector&lt;Data&gt; vec2; deserializeVector&lt;Data&gt;(filename,vec2); std::cout &lt;&lt; "vector read from binary file.\n"; printData(vec2); return 0;&#125; 编译代码1g++ -std=c++11 binary_io.cpp -o binary_io 执行程序1./binary_io 执行结果程序将内存中vector 数据写入二进制文件，并从二进制文件中反序列化到一个新的vector。可以看到序列化前和序列化后的结果一致。 注意序列化到文件的数据结构需要满足 is_trivially_copyable。std::is_trivially_copyable 在c++11 引入，TriviallyCopyable类型对象有以下性质 每个拷贝构造函数是trivial 或者是deleted 每个移动构造函数是trivial 或者是deleted 每个拷贝赋值运算符是trivial 或者是deleted 每个移动赋值运算符是trivial 或者是deleted 以上至少有一个是non-deleted 析构函数是trivial 并且non-deleted 对于is_trivially_copyable 类型对象的性质，解释如下 Objects of trivially-copyable types are the only C++ objects that may be safely copied with std::memcpy or serialized to/from binary files with std::ofstream::write()/std::ifstream::read(). In general, a trivially copyable type is any type for which the underlying bytes can be copied to an array of char or unsigned char and into a new object of the same type, and the resulting object would have the same value as the original 只有满足trivially-copyable的对象才可以保证序列化到二进制文件后， 从二进制文件反序列化到内存后的值保持不变。]]></content>
      <categories>
        <category>Backend Development</category>
      </categories>
      <tags>
        <tag>C++内存结构序列化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LRU Cache 解析及实现]]></title>
    <url>%2F2018%2F04%2F02%2FLRU-Cache-%E8%A7%A3%E6%9E%90%E5%8F%8A%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[LRU Cache 原理LRU是Least Recently Used 的缩写，是一种缓存替换算法，当系统中的缓存满时，通过删除最近最少使用的元素来填充新的内容。LRU 算法在操作系统中有广泛应用，如CPU与物理内存之间的Cache替换算法， 物理内存与硬盘之间Cache替换算法。 LRU Cache 实现我们可以使用一个双向链表和hash map 实现LRU Cache，其中hash map 存储缓存的内容，hash map 的value 存储指向双向链表节点的指针，双向链表存储缓存的内容，当有节点被加入时，该节点放到双向列表的头部，当访问已经存在的节点时，把该节点移动到双向链表头部，当双向链表满时，删除双向链表最后一个元素。简单的讲，双向链表的作用是记录缓存内容的使用顺序。 C++ 实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133/************************************************************************* &gt; File Name: lru_cache_template.hpp &gt; Author: ce39906 &gt; Mail: ce39906@163.com &gt; Created Time: 2018-04-02 16:44:58 ************************************************************************/#ifndef LRU_CACHE_TEMPLATE_HPP#define LRU_CACHE_TEMPLATE_HPP#include &lt;unordered_map&gt;template &lt;class Key,class Value&gt;struct Node&#123; Node(Key k,Value v) : key(k), value(v), prev(NULL), next(NULL) &#123; &#125; Node() &#123; &#125; Key key; Value value; Node* prev; Node* next;&#125;;template &lt;class Key, class Value&gt;class LruCache&#123; public: LruCache(int capacity) : size_(0), capacity_(capacity) &#123; head = new Node&lt;Key,Value&gt;; tail = new Node&lt;Key,Value&gt;; head-&gt;next = tail; head-&gt;prev = NULL; tail-&gt;next = NULL; tail-&gt;prev = head; container_.clear(); &#125;; ~LruCache() &#123; while(head) &#123; Node&lt;Key,Value&gt;* temp = head-&gt;next; delete head; head = temp; &#125; &#125;; void Put(Key key ,Value value) &#123; //insert if (container_.find(key) == container_.end()) &#123; //not full if (size_ != capacity_) &#123; Node&lt;Key,Value&gt;* data = new Node&lt;Key,Value&gt;(key,value); attach(data); container_.insert(std::make_pair(key,data)); size_++; &#125; else &#123; Node&lt;Key,Value&gt;* temp = tail-&gt;prev; container_.erase(temp-&gt;key); detach(temp); if (temp) delete temp; Node&lt;Key,Value&gt;* data = new Node&lt;Key,Value&gt;(key,value); attach(data); container_.insert(std::make_pair(key,data)); &#125; &#125; else //update &#123; Node&lt;Key,Value&gt;* data = container_[key]; detach(data); if (data) delete data; data = new Node&lt;Key,Value&gt;(key,value); container_[key] = data; attach(data); &#125; &#125; Value Get(Key key) &#123; //find if (container_.find(key) != container_.end()) &#123; Node&lt;Key,Value&gt;* data = container_[key]; detach(data); attach(data); return data-&gt;value; &#125; else // not find &#123; return Value(); &#125; &#125; private: int size_; int capacity_; std::unordered_map&lt;Key,Node&lt;Key,Value&gt;*&gt; container_; Node&lt;Key,Value&gt;* head; Node&lt;Key,Value&gt;* tail; void attach(Node&lt;Key,Value&gt;* node) &#123; Node&lt;Key,Value&gt;* temp = head-&gt;next; head-&gt;next = node; node-&gt;next = temp; node-&gt;prev = head; temp-&gt;prev = node; &#125; void detach(Node&lt;Key,Value&gt;* node) &#123; node-&gt;prev-&gt;next = node-&gt;next; node-&gt;next-&gt;prev = node-&gt;prev; &#125;&#125;;#endif]]></content>
      <categories>
        <category>Backend Development</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++ Thread Pool 使用解析]]></title>
    <url>%2F2018%2F03%2F29%2FC-Thread-Pool-%E4%BD%BF%E7%94%A8%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[boost::threadpool 按照boost标准开发的第三方库。下载地址在boost::threadpool 使用方法较为简单。例子如下123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;#include "boost/bind.hpp"#include "boost/threapool.hpp"using namespace std;using namespace threadpool;void first_task()&#123; cout &lt;&lt; "first task" &lt;&lt; endl;&#125;void second_task()&#123; cout &lt;&lt; "second task" &lt;&lt; endl;&#125;void task_with_parameter(int value,string str)&#123; cout &lt;&lt; "task with parameter,value is: " &lt;&lt; value &lt;&lt;",str is: " &lt;&lt; str;&#125;int main()&#123; // 声明线程池 pool thread_pool(2); // 向线程池中添加任务 thread_pool.schedule(&amp;first_task); // 等待线程函数执行完成 thread_pool.wait(); thread_pool.schedule(&amp;second_task); thread_pool.schedule(boost::bind(task_with_parameter,8,"hello")); thread_pool.wait(); return 0;&#125; boost::threadpool 添加任务，同步方式都相对简单，在添加多参数的任务时候需要注意 boost::bind() 传递的参数是按照拷贝的方式传递的。如果想使用引用的方式传递的话，需要使用boost::ref() 或者boost::cref()。还有需要注意的是boost::bind()最多接受九个参数boost::threadpool 是相对比较老的一个库,在2005-2008年间更新 boost::thread_group 以及io_service 例子12345678910111213141516171819202122232425262728#include &lt;boost/asio/io_service.hpp&gt;#include &lt;boost::bind.hpp&gt;#include &lt;boost::thread/thread_group.hpp&gt;boost::asio::io_service ioService;boost::thread_group threadpool;/*The work class is used to inform the io_service whenwork starts and finishes. This ensures that theio_service object's run() function will not exitwhile work is underway, and that it does exit whenthere is no unfinished work remaining*//* 声明一个ioService work 的原因是为了保证io service的run方法在这个work销毁之前不会退出*/boost::asio::io_service::work work(ioService);// 放在for循环中，根据线程池中线程中个数创建// ioService 可以理解为任务队列//Run the io_service object's event processing loop.threadpool.create_thread(boost::bind(&amp;boost::asio::ioservice::run,&amp;ioService));threadpool.create_thread(boost::bind(&amp;boost::asio::ioservice::run,&amp;ioService));// 向ioService 中提交任务ioService.post(boost::bind(myTask,"hello world"));ioService.post(boost::bind(myTask2,"clear"));...// ioService 在stop 之后，post到ioService中的task 都不会被执行ioService.stop();threadpool.join_all(); boost::ioservice 以及 boost::thread_pool 实现的thread pool没有提供wait() 方法，因此需要调用者主动判断所提交的任务有没有完成 基于c++11 实现的线程池主要步骤如下： 设定线程池中所提供的服务线程数 1int threads = thread::hardware_concurrency(); 每个线程都应该执行一个无限循环，无限循环中等待新任务到达，并执行任务 12345vector&lt;thread&gt; pool;for (int i = 0; i &lt; threads; i++)&#123; pool.push_back(thread(Infinite_loop_function));&#125; 无限循环function 12345678910while(true)&#123; &#123; unique_lock&lt;mutex&gt; lock(queue_mutex); condition.wait(lock,[]&#123;return !Queue.empty()&#125;); Task = Queue.front(); Queue.pop(); &#125; Task();&#125; 向任务队列中添加任务 12345678void enqueue(function&lt;void()&gt; new_task)&#123; &#123; unique_lock&lt;mutex&gt; lock(queue_mutex); Queue.push(new_task); &#125; condition.notify_one();&#125; 具体实现例子1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859class ThreadPool &#123;public: ThreadPool(size_t threads) : stop(false) &#123; for(size_t i = 0;i&lt;threads;++i) workers.emplace_back( [this] &#123; for(;;) &#123; std::function&lt;void()&gt; task; &#123; std::unique_lock&lt;std::mutex&gt; lock(this-&gt;queue_mutex); this-&gt;condition.wait(lock, [this]&#123; return this-&gt;stop || !this-&gt;tasks.empty(); &#125;); if(this-&gt;stop &amp;&amp; this-&gt;tasks.empty()) return; task = std::move(this-&gt;tasks.front()); this-&gt;tasks.pop(); &#125; task(); &#125; &#125; ); &#125; // add new work item to the pool void enqueue(std::function&lt;void()&gt;&amp; task) &#123; &#123; std::unique_lock&lt;std::mutex&gt; lock(queue_mutex); // don't allow enqueueing after stopping the pool if(stop) throw std::runtime_error("enqueue on stopped ThreadPool"); tasks.emplace(task); &#125; condition.notify_one(); &#125; ~ThreadPool() &#123; &#123; std::unique_lock&lt;std::mutex&gt; lock(queue_mutex); stop = true; &#125; condition.notify_all(); for(std::thread &amp;worker: workers) worker.join(); &#125;private: std::vector&lt; std::thread &gt; workers; // the task queue std::queue&lt; std::function&lt;void()&gt; &gt; tasks; // synchronization std::mutex queue_mutex; std::condition_variable condition; bool stop;&#125;; 总结从线程池的实现可以看到，线程在任务队列中获取任务以及向任务队列中提交任务都需要抢占队列的互斥锁，会造成时间损耗，尤其在任务数多，每个任务需要的时间不是很长的情况下，抢占任务队列互斥锁的时间损耗就显得更加明显。例如，在16核机器，线程池开启14个线程，向线程池中提交2000个task(每个task耗时1ms 左右)的情况下，向线程池提交任务所需时间约20ms。因此，线程池的方式更适合每个task消耗的时间比较长，任务数不是特别多的场景]]></content>
      <categories>
        <category>Backend Development</category>
      </categories>
      <tags>
        <tag>Parallel Programing</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Boost Spirit]]></title>
    <url>%2F2018%2F03%2F28%2FBoost-Spirit%2F</url>
    <content type="text"><![CDATA[What is boost spiritboost spirit is an object-oriented,recursive-descent parser and output generation library for C++.It allows you to write grammars and format descripting using a format similar to Extended Backs Naur Form(EBNF) directly in C++. The figure below shows the overall structure of Boost Spirit library. The three components Qi,Kama and Lex are designed to be used either stand alone or together. The general methodology is to use the token sequence generated by Lex as the input for a parser generated by Qi. On the opposite side of the equation,the hierarchical data structures generated by Qi are used for the output generators created using Kama. The place of Spirit.Qi and Spirit.Kama in a data transformation flow of a typical application. Qi- Writing ParsersSpirit.Qi is designed to be a practical parsing tool. Scanf ,boost::regex or boost::tokenizer do not scale well when we need to write more elaborate parsers. ExamplesExample #1 parsing a numberCreate a parser that will parse a floating-point number.1double_ Example #2 parsing 2 numbersCreate a parser that will accept a line consisting of 2 floating-point numbers.1double_ &gt;&gt; double_ Example #3 parsing zero or more numbersCreate a parser that will accept zero or more floating-point numbers.1*double_ Example #4 parsing a comma-delimited list of numbersThis example will create a parser that accepts a comma-delimited list of numbers.1double_ &gt;&gt; *(char_(',') &gt;&gt; double_) Notice char_(‘,’) is a literal charcter parser that can recognize the comma ‘,’. Let’s ParseWe are done with defining the parser.So the next step is invoking this parser to do its work.Here we will use phrase_parse function. One overload of this function accepts four arguments. iterator pointing to the start of the input. iterator pointing to the end of the input. parser object another parser called the skip parser 1234567891011121314151617template&lt;typename Iterator&gt;bool parse_numbers(Iterator first, Iterator last)&#123; using qi::double_; using qi::phrase_parse; using ascii::space; bool r = pharse_parse( first, last, double_ &gt;&gt; *(',' &gt;&gt; double_), space ); if (fisrt != last) return false; return r;&#125; Parser Semantic ActionsThe previous example was very simple.It only recognized data,but did noting with it.Now we want to extract information from what was parsed.Semantic actions may be attached to any point in the grammar specification. These functions are C++ functions or function objects that are called whenever a part of the parser successfully recognizes a portion of the input. Example of Semantic Actions using plain function pointer using simple function object using boost.bind with a plain function using boost.bind with a member function using boost.lambda Such as:1234567891011121314151617181920212223242526namespace client&#123; namespace qi = boost::qi; // A plain function void print(const int&amp; i) &#123; std::cout &lt;&lt; i &lt;&lt; std::endl; &#125; // A member function struct writer &#123; void print(const int&amp; i) const &#123; std::cout &lt;&lt; i &lt;&lt; std::endl; &#125; &#125;; // A function object struct print_action &#123; void operator()(const int&amp; i,qi::unset_type,qi::unset_type) const &#123; std::cout &lt;&lt; i &lt;&lt; std::endl; &#125; &#125;;&#125; All examples parse inputs of the form:1"&#123;integer&#125;" These below shows the usages 12345678910111213141516171819202122using boost::spirit::qi::int_;using boost::spirit::qi::parse;using client::print;using client::writer;using clinet::print_action;const char* fisrt = "&#123;43&#125;";const char* last = first + std::strlen(first);// example using plain functionparse(first,last,'&#123;'&gt;&gt;int_[&amp;print]&gt;&gt;'&#125;');// example using simple function objectparse(first,last,'&#123;'&gt;&gt;int_[print_action()]&gt;&gt;'&#125;');// example using boost bind with a plain functionparse(fisrt,last,'&#123;' &gt;&gt; int_[boost::bind(&amp;print,_1)]&gt;&gt;'&#125;');// example using boost bind with a member functionparse(first,last,'&#123;'&gt;&gt; int_[boost::bind(&amp;writer::print,&amp;w,_1)]&gt;&gt;'&#125;');// example using boost lambdanamespace lambda = boost::lambda;using lambda::_1;parse(first,last,'&#123;' &gt;&gt; int_[std::cout &lt;&lt; _1 &lt;&lt; '\n'] &gt;&gt; '&#125;'); PhoenixPhoenix , a companion library bundled with Spirit. is sepcifically suited for binding semantic actions. It is like Boost.lambad on sterodis, with spiecial custom featrues that make it easy to inergrate semantic action with Spirit. Complex - Our first complex parserA parser that parses complex numbers.This time we are using Phoenix to do the semantic actions.Here is a simple parser expression for complex numbers.12'(' &gt;&gt; double_ &gt;&gt; -(',' &gt;&gt; double_) &gt;&gt; ')' | double_ This parser can parse complex numbers of the form:123(123.22,2121.21)(213.33)212.33 This below shows example of action with phoniex 1234567891011121314151617181920212223242526272829namespace client&#123; template&lt;typename Iterator&gt; bool parse_complex(Iterator first,Iterator last,std::complex&lt;double&gt;&amp; c) &#123; using boost::spirit::qi::double_; using boost::spirit::qi::_1; using boost::spirit::qi::phrase_parse; using boost::spirit::ascii::space; using boost::phoenix::ref; double rN = 0.0; double iN = 0.0; bool r = phrase_parse( first, last, ( '(' &gt;&gt; double_[ref(rN) = _1] &gt;&gt; -(',' &gt;&gt; double_[ref(iN) = _1]) &gt;&gt; ')' | double_[ref(rN) = _1] ), space ); if (!r || first != last) return false; c = std::complex&lt;double&gt;(rN,iN); return r; &#125;&#125; Sum - adding numbersHere is a parser that sums a comma-separated list of numbers.123456789101112131415161718192021222324namespace qi = boost::spirit::qi;namespace ascii = boost::spirit::ascii;namespace phoenix = boost::spirit::phoenix;using qi::double_;using qi::_1;using ascii::space;using phoenix::ref;template&lt;typename Iterator&gt;bool adder(Iterator first,Iterator last,double&amp; n)&#123; bool r = qi::phrase_parse( first, last, ( double_[ref(n) = _1] &gt;&gt; *(',' &gt;&gt; double_[ref(n) += _1]) ), space ); if (fisrt != last) return false; return r;&#125; Number List - stuffing numbers into a std::vectorThis sample demonstrates a parser for a comma separated list of numbers. The numbers are inserted in a vector using phoenix.1234567891011121314151617181920212223template &lt;typename Iterator&gt;bool parse_numbers(Iterator fisrt,Iterator last,std::vector&lt;double&gt;&amp; v)&#123; using qi::double_; using qi::phrase_parse; using qi::_1; using ascii::space; using phoenix::push_back; using phoenix::ref; bool r = phrase_parse( first, last, ( double_[push_back(ref(v),_1)] &gt;&gt; *(',' &gt;&gt; double_[push_back(ref(v),_1)]) ), space ); if(first != last) return false; return r;&#125; Number List Redux - list syntaxSo far, we’ve been using the syntax:1double_ &gt;&gt; *(',' &gt;&gt; double_) to parse a comma-delimited list of numbers.Such lists are common in parsing and Spirit provides a simpler shortcut for them1double_ % ',' reads as a list of doubles separted by ‘,’.The last example could be done as this:1234567891011121314151617181920212223template&lt;typename Iterator&gt;bool parse_numbers(Iterator first,Iterator last,std::vector&lt;double&gt;&amp; v)&#123; using qi::double_; using qi::phrase_parse; using qi::_1; using ascii::space; using phoenix::push_back; using phoenix::ref; bool r = phrase_parse( first, last, ( double_[ref(v),_1] % ',' ), space ); if (first != last) return false; return r; &#125; Number List Attribute - one more,with styleAs we know,the double_ parser has a doubel attribute. All parsers have an attribute,even complex parsers. Our parser1doubel_ % ',' has an attribute of std::vector.So we can simply pass in a std::vector to our number of list parser.the overload of phrase_parse has five arguments: iterator pointing to start of the input iterator pointing to last of the input the parser object another parser called skip parser the parse’s attribute 123456789bool r = phrase_parse( first, last, ( double_ % ',' ), space, v); Roman NumeralsThis example demonstrates: symbol table rule grammar Symbol tableEach entry in a symbol table has an associated mutable data solt. In this regard, one can view the symbol table as an associative container of key-value pairs where the keys are strings. Here is a parser for roman hundreds(100..900) using the symbol table. Keep in mind that the data associated with each slot is the parser’s attribute(which is passed to attached semantic actions). 12345678910111213141516struct hundreds_ : qi::symbols&lt;char, unsigned&gt;&#123; hundreds_() &#123; add ("C",100) ("CC",200) ("CCC",300) ("CD",400) ("D", 500) ("DC", 600) ("DCC",700) ("DCCC",800) ("CM",900); &#125;&#125; hundreds; we also can define tens ones symbol table.They are all parsers. RulesUp until now,we have been inlining our parser expressions, passing them directly to the phrase_parse function. The expression evalutes into a temporary,unnamed parser which is passed into the phrase_parse function, used and then destroyed. This is fine for small parsers. When the expressions get complicated, you’d want to break the expressions into smaller easier-to-understand pieces, name them, and refer to them from other expressions by name. A parser expression can be assigned to what is called a “rule”.Threr are various ways to declare rules.The simplest form is :12345678rule&lt;Iterator&gt; r;// this rule cannot used by phrase_parse function,// it can only be used by parse function -- a version that does not do white space skipping.// If you want to have it skip white spaces,you need to pass in the type skip parser.rule&lt;Iterator,Skipper&gt; r;rule&lt;string::iterator,space_type&gt; r;// This type of rule can be used for both// phrase_parse and parse. There is one more rule form you should know about.1rule&lt;Iterator,Signature,Skipper&gt; r; The Signature specifies athe attributes of the rule. Recall that the double_ parser has an attribute of double. To be precise, these are synthesized attributes.The parser “synthesized” the attribute value.Think of them as the function return value. There is another type of attribute called “inherited” attribute. You can think them as function arguments. And,rightly so, the rule signature is a function signature . After having declared a rule,you can now assign any parser expression to it. Example:1r = double_ &gt;&gt; *(',' &gt;&gt; double_); GrammarsA grammar encapsulates one or more rules.It has the same template parameters as the rule.You can declare a grammar by: deriving a struct from the grammar class template declare one or more rules as member variables initialize the base grammar class by giving it the start rule(its the first rule that gets called when the grammar starts parsing) initalize your rules in your constrctor. The rommon numeral grammar is a very nice and simple example of a grammar.123456789101112131415161718192021template&lt;typename Iterator&gt;struct roman :qi::grammar&lt;Iterator,unsigned()&gt;&#123; roman() : roman::base_type(start) &#123; using qi::eps; using qi::lit; using qi::_val; using qi::_1; using ascii::char_; start = eps [_val = 0] &gt;&gt; ( +lit('M') [_val += 1000] || hundreds [_val += _1] || tens [_val += _1] || ones [_val += _1] ) &#125; qi::rule&lt;Iterator,unsigned()&gt; start;&#125; the grammar and start rule sinature is unsigned() it has a synthesized attribute(return value) of type unsigned whith on inherited attributeds(argumnents). roman::base_type is a typedef for grammar&lt;Iterator,unsigned()&gt; _val is another Phoenix placeholder representing the rule’s synthesized attribute eps is a special spirit parser that consumes no input but is always successful. We use it to initialize _val,the rule’s synthesized attribute, to zero before anything else. Using eps this way is good for doing pre and post initializations. the example a || b reads, match a or b and in sequence.That is if both a and b match, it must be in sequence; this is equivalen to a &gt;&gt; -b | b,but more efficient. Usage123456bool r = parse(iter,end,roman_parser,result);if (r &amp;&amp; iter == end)&#123; std::cout &lt;&lt; "Parse success.\n"; std::cout &lt;&lt; "Result = " &lt;&lt; result &lt;&lt; std::endl;&#125; Employee - Pasing into structsThis section shows how to parse and place the reult into a C++ struct. fisrtly, let’s create a struct representing an employee.1234567struct employee&#123; int age; std::string surname; std::string forename; double salary;&#125;; now we will write a parser for our employee. Inputs will be of the form.1employee&#123; age,"surname","forename",salary &#125; 1234567891011121314151617181920212223242526template&lt;typename Iterator&gt;struct employee_parser : qi::grammar&lt;Iterator,employee(),ascii::space_type&gt;&#123; employee_parser():employee_parser::base_type(start) &#123; using qi::int_; using qi::lit; using qi::double_; using qi::lexeme; using ascii::char_; quoted_string %= lexeme['"' &gt;&gt; +(char_ - '"') &gt;&gt; '"']; start %= lit("employee") &gt;&gt; '&#123;' &gt;&gt; int_ &gt;&gt; ',' &gt;&gt; quoted_string &gt;&gt; ',' &gt;&gt; quoted_string &gt;&gt; ',' &gt;&gt; double_ &gt;&gt; '&#125;' ; &#125; qi::rule&lt;Iterator,std::string(),ascii::space_type&gt; quoted_string; qi::rule&lt;Iterator,employee(),ascii::space_type&gt; start;&#125;; Lexeme1lexeme['"' &gt;&gt;(char_ - '"') &gt;&gt; '"'] lexeme inhibits sapce skipping from the open brace to the closing space.The expression parses quoted strings.1+(char_ - '"') parses one or more chars,except the double quote. It stops when it sees a double quote. +a matches one or more,its attribute is a std::vector where A is the attribute of a . Sequence Attributenow what’s the attribute of1'"' &gt;&gt; (char_ - '"') &gt;&gt;'"' 123a &gt;&gt; b &gt;&gt; c fusion::vector&lt;A,B,C&gt;// is a tuple Some parser,especially those very little parsers like ‘“‘ do not have attributes.Nodes without attributes are disregarded.so, ‘“‘ &gt;&gt; (char_ - ‘“‘) &gt;&gt;’”‘ ‘s attribue is1fusion::vector&lt;std::vector&lt;char&gt;&gt; but there is one more collpase rule.if the attribute is followed by a single element fusion::vector, The element is stripped naked from its container. so the attribute come to this1std::vector&lt;char&gt; Auto Rulesit is typical to see rules like1r = p[_val = _1] if you have a rule definiton such as the above,where the attribute of the right hand side of the rule is compitable with the left hand side.then you can rewrite is as:1r %= p; so1quoted_string %= lexeme['"' &gt;&gt; +( char_ -'"') &gt;&gt; '"']; is simple version of1quoted_string = lexeme['"' &gt;&gt; + (char_ - '"') &gt;&gt; '"'][_val = _1]; Note: r %= p and r = p are equivalent if there are no semantic actions associated with p. In case you are wondering, lit(“employee”) is the same as “employee”. We had to wrap it inside lit because immediately after it is &gt;&gt; ‘{‘. You can’t right-shift a char[] and a char - you know, C++ syntax rules. Karma - Writing GeneratorsSpirit.Karma - what’s that?Spirit.Karma is the counterpart to spirit.qi.Some people say it’s the Yin to Spirit.Qi’s Yang. Spirit.karma is generating byte sequences from internal data structures as Spirit.Qi is parsing byte sequences into those internal data structures. Why should you use a generator library for such a simple thing as output generation? Programmers have been using printf, std::stream formatting, or boost::format for quite some time. The answer is - yes, for simple output formatting tasks those familiar tools might be a quick solution. But experience shows: as soon as the formatting requirements are becoming more complex output generation is getting more and more challenging in terms of readability, maintainability, and flexibility of the code. Last, but not least, it turns out that code using Spirit.Karma runs much faster than equivalent code using either of the ‘straight’ methods mentioned above. In terms of development simplicity and ease in deployment, the same is true for Spirit.Karma as has been described elsewhere in this documentation for Spirit.Qi: the entire library consists of only header files, with no libraries to link against or build. Just put the spirit distribution in your include path, compile and run. Code size? Very tight, essentially comparable to hand written code. ExamplesTrivial Example Generating a number1double_ Generating two numbers1double_ &lt;&lt; double_ Generating one or more numbers1*double_ Generating a comma-delimited list of numbers1double_ &lt;&lt; *(lit(',')) &lt;&lt; double_ Let’s generate1234567891011121314template&lt;typename OutputIterator&gt;bool generate_numbers(OutputIterator&amp; sink,std::list&lt;double&gt; const&amp; v)&#123; using karma::double_; using karma::generate_delimited; using ascii::space; bool r = genated_delimited( sink, double_ &lt;&lt; *(',' &lt;&lt; double_), v ); return r;&#125;]]></content>
      <categories>
        <category>Backend Development</category>
      </categories>
      <tags>
        <tag>Boost</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OpenMp Tutorial]]></title>
    <url>%2F2018%2F03%2F28%2FOpenMp-Tutorial%2F</url>
    <content type="text"><![CDATA[What is openmpeasy multithreading programing for c++. it is a simple C/C++/Fortran complier extension that allows to add parallelism into existing source code without significantly having to rewrite it. Exampleexample for init an array12345678910111213#include&lt;iostream&gt;#include&lt;vector&gt;int main()&#123; vector&lt;int&gt; arr; arr.reserve(1000); #pargma omp parallel for for(int i=0;i&lt;1000;i++) &#123; arr[i] = i * 2; &#125; return 0;&#125; you can compile it like this g++ tmp.cpp -fopenmp if you remove the #pragma lines,the result is still a valid C++ program that runs and dose the expected thing.if the compiler encounters a #pragma that it dose not support,it will ignore it. The syntaxthe parallel constructit creates a team of N threads(where N is the number of CPU cores by default) . after the statement, the threads join back into one.12345#pragma omp parallel&#123; // code inside thie region runs in parallel printf("Hello\n");&#125; Loop construct: forthe for construct splits the for-loop so that each thread in the current team handles a different portion of the loop12345#pragma omp forfor(int n=0;n&lt;10;++n)&#123; printf(" %d",n);&#125; Note:#pragma omp for onlt delegates portions of the loop for different threads in current team. a team is the group of threads excuting the program.At program start,the team only consists the main thread.To create a new team of threads,you need to specify the parallel keyword12345#pragma omp parallel&#123; #pragma omp for for(int n=0;n&lt;10;n++) printf(" %d",n)&#125; or use1#pragma omp parallel for you can explicitly specify the number of threads to be created in the team. using num_threads1#pragma omp parallel for num_threads(3) schedulingThe scheduling algorithm for the for-loop can explicity controlled default1#pargma omp for schedule(static) in the dynamic schedule,each thread ask the omp runtime library for an iteration number,then handles it.the chunk size can also be specified to lessen the number of calls to the runtime library1#pargma omp parallel for schedule(dynamic,3) the ordered clauseit is possible to force that certain events within the loop happen in a predicted order, using ordered clause1234567#pargma omp parallel for ordered shcedule(dynamic)for(int n = 0;i &lt; 100;i++)&#123; files[n].compress(); #pragma omp ordered send(files[n]);&#125; the collapse clausewhen you have nested loops.you can use collapse12345678#pargma omp parallel for collapse(2)for(int i = 0;i &lt; 10;i++)&#123; for(int j = 0;j &lt; 10;j++) &#123; doSth(); &#125;&#125; sectionsometimes,it is handy to indicate that “this and this can run in parallel” the sectiongs is just for that123456789101112131415#pragma omp parallel sections&#123; &#123; work1(); &#125; #pragma omp section &#123; work2(); work3(); &#125; #pragma omp section &#123; work4(); &#125;&#125; This code indicates that any of tasks work1,work2+work3,work4 can run in parallel. Thread-safetyAtomicity12#pragma omp atomiccouter += value; the atomic keyword in OpenMP specifies that denoted action happens atomically. atomic read expression12#pragma omp atomic readvar = x; atomic write expression12#pragma omp atomic writex = expr; atomic update expression123#pragma omp atomic update++x;--x;x++;x--;+=,-= ... atomic capture expressioncapture expression combine the read and update features12#pragma omp atomic capturevar = x++; the critical constructthe critical construct restricts the execution of the associated statement / block to a single thread at a time1234#pragma omp critical&#123; doSth();&#125; Note:the critical section names are global to the entire program. locksThe openmp runtime library provides a lock type,omp_lock_t in omp.hthe lock type has five manipulator functions omp_init_lock : initializes the lockomp_destory_lock : the lock must be unset before the callomp_set_lock: get the lockomp_unset_lock: release the lockomp_test_lock: attempts to set the lock.if the lock is already set by another thread it returns 0;if it managed to set the lock,it return 1 the flush directiveEven when variables used by threads are supposed to be shared,the compiler may take liberties and optimize them as register variables. This can skew concurrent observations of variable. The flush directive can be used to forbid this.123456789101112131415/*first thread*/b=1;#pragma omp flush(a,b)if(a == 0)&#123; /* critical section*/&#125;/*second thread*/a = 1;#pragma omp flush(a,b)if(b==0)&#123; /* critical section*/&#125; Controlling which data to share between threads1234567int a,b =0;#pragma omp parallel for private(a) shared(b)for(a=0;a&lt;50;++a)&#123; #pragma omp atomic b += a;&#125; a is private(each thread has their own copy of it) and b is shared(each thread accesses the same variable) the difference between private and firstprivateprivate does not copy the value of the variable that was in the surrounding context.1234567891011121314151617181920212223#include&lt;string&gt;#include&lt;iostream&gt;int main()&#123; std::string a = "x",b="y"; #pragma omp parallel private(a,c) shared(b) num_threads(2) &#123; a+="k"; c+= 7; std::cout &lt;&lt; "A is " &lt;&lt; a &lt;&lt;", b is "&lt;&lt; b; &#125;&#125;// eaquls this below OpenMP_thread_fork(2); &#123; // Start new scope std::string a; // Note: It is a new local variable. int c; // This too. a += "k"; c += 7; std::cout &lt;&lt; "A becomes (" &lt;&lt; a &lt;&lt; "), b is (" &lt;&lt; b &lt;&lt; ")\n"; &#125; // End of scope for the local variables OpenMP_join(); If you actually need a copy of the original value, use the firstprivate clause instead.123456789101112131415#include &lt;string&gt;#include &lt;iostream&gt;int main()&#123; std::string a = "x", b = "y"; int c = 3; #pragma omp parallel firstprivate(a,c) shared(b) num_threads(2) &#123; a += "k"; c += 7; std::cout &lt;&lt; "A becomes (" &lt;&lt; a &lt;&lt; "), b is (" &lt;&lt; b &lt;&lt; ")\n"; &#125;&#125; Execution synchronizationthe barrier directive and the nowait clauseThe barrier directive causes threads encoutering the barrier to wait until all the other threads in the same team have encountered the barrier.12345678#pragma omp parrllel&#123; // all threads execute this SomeCode(); #pragma omp barrier // all threads execute this,but not before all threads have finished executing SomeCode() SomeMoreCode();&#125; Note:there is an implicit barrier at the end of each parallel block,at the end of each section for statement 12345678910111213141516171819202122232425#pragma omp parallel&#123; #pragma omp for for(int n=0; n&lt;10; ++n) Work(); // This line is not reached before the for-loop is completely finished SomeMoreCode();&#125;// This line is reached only after all threads from// the previous parallel block are finished.CodeContinues();#pragma omp parallel&#123; #pragma omp for nowait for(int n=0; n&lt;10; ++n) Work(); // This line may be reached while some threads are still executing the for-loop. SomeMoreCode();&#125;// This line is reached only after all threads from// the previous parallel block are finished.CodeContinues(); the single and master constructsThe single construct specifies that the given statement/block is executed by only one thread. It is unspecified which thread. Other threads skip the statement/block and wait at an implicit barrier at the end of the construct.123456789#pragma omp parallel&#123; Work1(); #pragma omp single &#123; Work2(); &#125; Work3();&#125; The master construct is similar, except that the statement/block is run by the master thread, and there is no implied barrier; other threads skip the construct without waiting.12345678910111213141516171819202122232425static const char* FindAnyNeedle(const char* haystack, size_t size, char needle)&#123; const char* result = haystack+size; #pragma omp parallel &#123; unsigned num_iterations=0; #pragma omp for for(size_t p = 0; p &lt; size; ++p) &#123; ++num_iterations; if(haystack[p] == needle) &#123; #pragma omp atomic write result = haystack+p; // Signal cancellation. #pragma omp cancel for &#125; // Check for cancellations signalled by other threads: #pragma omp cancellation point for &#125; // All threads reach here eventually; sooner if the cancellation was signalled. printf("Thread %u: %u iterations completed\n", omp_get_thread_num(), num_iterations); &#125; return result;&#125; Loop nestingthis code will not do the excepted thing123456789#pragma omp parallel forfor(int y=0; y&lt;25; ++y)&#123; #pragma omp parallel for for(int x=0; x&lt;80; ++x) &#123; tick(x,y); &#125;&#125; solution12345678#pragma omp parallel for collapse(2)for(int y=0; y&lt;25; ++y)&#123; for(int x=0; x&lt;80; ++x) &#123; tick(x,y); &#125;&#125; Readmorehttp://www.openmp.org/wp-content/uploads/openmp-4.5.pdfhttps://en.wikipedia.org/wiki/OpenMP]]></content>
      <categories>
        <category>Backend Development</category>
      </categories>
      <tags>
        <tag>Parallel Programing</tag>
      </tags>
  </entry>
</search>
