<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/cat-32x32.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/cat-32x32.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/cat-16x16.png?v=5.1.4">


  <link rel="mask-icon" href="/images/cat-32x32.png?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="About Linux C++ and routing algorithms.">
<meta name="keywords" content="Linux C++ Routing">
<meta property="og:type" content="website">
<meta property="og:title" content="Carbon&#39;s Blog">
<meta property="og:url" content="https://carbo06.github.io/page/4/index.html">
<meta property="og:site_name" content="Carbon&#39;s Blog">
<meta property="og:description" content="About Linux C++ and routing algorithms.">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Carbon&#39;s Blog">
<meta name="twitter:description" content="About Linux C++ and routing algorithms.">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"always","offset":12,"b2t":false,"scrollpercent":true,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://carbo06.github.io/page/4/"/>





  <title>Carbon's Blog</title><!-- hexo-inject:begin --><!-- hexo-inject:end -->
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Carbon's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">以梦为马 不负韶华</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://carbo06.github.io/2018/05/10/GCC-buildin-except-解析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="carbo06@163.com">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Carbon's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/10/GCC-buildin-except-解析/" itemprop="url">GCC __buildin_except 解析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-10T15:52:27+08:00">
                2018-05-10
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于&#58;</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2018-05-10T16:03:49+08:00">
                2018-05-10
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Backend-Development/" itemprop="url" rel="index">
                    <span itemprop="name">Backend Development</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>摘自gcc的官方文档<a href="https://gcc.gnu.org/onlinedocs/gcc-4.1.2/gcc/Other-Builtins.html" target="_blank" rel="noopener">OtherBuildinFunction</a>.</p>
<blockquote>
<p>—Built-in Function: long <strong>builtin_expect (long exp, long c)<br>You may use </strong>builtin_expect to provide the compiler with branch prediction information. In general, you should prefer to use actual profile feedback for this (-fprofile-arcs), as programmers are notoriously bad at predicting how their programs actually perform. However, there are applications in which this data is hard to collect.</p>
</blockquote>
<blockquote>
<p>The return value is the value of exp, which should be an integral expression. The value of c must be a compile-time constant. The semantics of the built-in are that it is expected that exp == c. For example:</p>
</blockquote>
<pre><code>if (__builtin_expect (x, 0))
  foo ();
</code></pre><blockquote>
<p>would indicate that we do not expect to call foo, since we expect x to be zero. Since you are limited to integral expressions for exp, you should use constructions such as</p>
</blockquote>
<pre><code>if (__builtin_expect (ptr != NULL, 1))
  error ();
</code></pre><blockquote>
<p>when testing pointer or floating-point values.<br>我们可以使用 __buildin_except 向编译器提供分支预测信息，从而帮助编译器进行代码优化。</p>
</blockquote>
<h2 id="引入原因"><a href="#引入原因" class="headerlink" title="引入原因"></a>引入原因</h2><p>CPU 流水线技术可以提高CPU执行效率，但是程序中的跳转指令会打乱CPU流水线。因此，跳转次数少的程序拥有更高的执行效率。</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>使用__buildin_except 定义<strong>LIKELY</strong>和<strong>UNLIKELY</strong>宏，分别代表bool型变量或表达式有很大可能性为真或者很大可能性为假。以下是测试代码。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 两个感叹号的作用是将所有的非零值转化为1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LIKELY(x) __builtin_expect(!!(x), 1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UNLIKELY(x) __builtin_expect(!!(x), 0)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">likely</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(LIKELY(x))</span><br><span class="line">    &#123;</span><br><span class="line">        x = <span class="number">5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        x = <span class="number">6</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">unlikely</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(UNLIKELY(x))</span><br><span class="line">    &#123;</span><br><span class="line">        x = <span class="number">5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        x = <span class="number">6</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">normal</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x)</span><br><span class="line">    &#123;</span><br><span class="line">        x = <span class="number">5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        x = <span class="number">6</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>编译出.o文件，并使用objdump查看汇编代码<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">gcc</span> <span class="selector-tag">-O2</span> <span class="selector-tag">-fprofile-arcs</span> <span class="selector-tag">-c</span> <span class="selector-tag">test_builtin_except</span><span class="selector-class">.cpp</span></span><br><span class="line"><span class="selector-tag">objdump</span> <span class="selector-tag">-d</span> <span class="selector-tag">test_builtin_except</span><span class="selector-class">.o</span></span><br></pre></td></tr></table></figure></p>
<p>结果以及解释如下图<br><img src="https://myblog-1256683296.cos.ap-beijing.myqcloud.com/__buildin_except_edit.jpg" alt="avatar"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Linux 内核中大量使用<strong>LIKELY UNLIKELY</strong>宏提升程序运行效率，在C/C++工程可以引入此宏提供分支预测提示编译器进行代码优化。比如在工程中经常会存在处理程序错误的分支，但是出错分支又是不经常进入，这种场景下可以使用<strong>__build_except</strong>进行代码优化。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://carbo06.github.io/2018/05/09/Leveldb-LRUCache-解析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="carbo06@163.com">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Carbon's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/09/Leveldb-LRUCache-解析/" itemprop="url">Leveldb LRUCache 解析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-09T17:00:21+08:00">
                2018-05-09
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于&#58;</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2018-09-04T14:05:48+08:00">
                2018-09-04
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Backend-Development/" itemprop="url" rel="index">
                    <span itemprop="name">Backend Development</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="LRU原理"><a href="#LRU原理" class="headerlink" title="LRU原理"></a>LRU原理</h2><p>LRU 是一种经典的缓存淘汰策略，其原理以及实现可以查看我之前的博客<a href="https://carbo06.github.io/2018/04/02/LRU-Cache-%E8%A7%A3%E6%9E%90%E5%8F%8A%E5%AE%9E%E7%8E%B0/">LRU Cache 解析及实现</a>。本文主要解析Leveldb LRU Cache。</p>
<h2 id="Leveldb-实现"><a href="#Leveldb-实现" class="headerlink" title="Leveldb 实现"></a>Leveldb 实现</h2><p>Leveldb 实现的LRUCache 使用自己实现的简单hashtable存储键值对，循环双链表记录每个元素的访问时间，为了提升多线程环境下的读写性能，Leveldb 内部使用LRUCache 数组对外提供服务。</p>
<h3 id="Cache-Entry"><a href="#Cache-Entry" class="headerlink" title="Cache Entry"></a>Cache Entry</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LRUHandle</span> &#123;</span></span><br><span class="line">  <span class="keyword">void</span>* value;</span><br><span class="line">  <span class="keyword">void</span> (*deleter)(<span class="keyword">const</span> Slice&amp;, <span class="keyword">void</span>* value);</span><br><span class="line">  <span class="comment">// next_hash 代表在hash桶中下一个元素的位置</span></span><br><span class="line">  LRUHandle* next_hash;</span><br><span class="line">  <span class="comment">// 双链表中下个元素的位置</span></span><br><span class="line">  LRUHandle* next;</span><br><span class="line">  <span class="comment">// 双链表中上个元素的位置</span></span><br><span class="line">  LRUHandle* prev;</span><br><span class="line">  <span class="keyword">size_t</span> charge;      <span class="comment">// TODO(opt): Only allow uint32_t?</span></span><br><span class="line">  <span class="keyword">size_t</span> key_length;</span><br><span class="line">  <span class="comment">// 使用次数</span></span><br><span class="line">  <span class="keyword">uint32_t</span> refs;</span><br><span class="line">  <span class="comment">// key 的hash值用于在LRUCache数组以及hash表中定位</span></span><br><span class="line">  <span class="keyword">uint32_t</span> hash;      <span class="comment">// Hash of key(); used for fast sharding and comparisons</span></span><br><span class="line">  <span class="keyword">char</span> key_data[<span class="number">1</span>];   <span class="comment">// Beginning of key</span></span><br><span class="line"></span><br><span class="line">  <span class="function">Slice <span class="title">key</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="comment">// For cheaper lookups, we allow a temporary Handle object</span></span><br><span class="line">    <span class="comment">// to store a pointer to a key in "value".</span></span><br><span class="line">    <span class="keyword">if</span> (next == <span class="keyword">this</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> *(<span class="keyword">reinterpret_cast</span>&lt;Slice*&gt;(value));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> Slice(key_data, key_length);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="简单hash表"><a href="#简单hash表" class="headerlink" title="简单hash表"></a>简单hash表</h3><p>Leveldb LRU Cache 实现了线程安全的拉链式的hashtable<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HandleTable</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  HandleTable() : length_(<span class="number">0</span>), elems_(<span class="number">0</span>), list_(<span class="literal">NULL</span>) &#123; Resize(); &#125;</span><br><span class="line">  ~HandleTable() &#123; <span class="keyword">delete</span>[] list_; &#125;</span><br><span class="line">  <span class="comment">// 查找，直接调用FindPointer方法</span></span><br><span class="line">  <span class="function">LRUHandle* <span class="title">Lookup</span><span class="params">(<span class="keyword">const</span> Slice&amp; key, <span class="keyword">uint32_t</span> hash)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> *FindPointer(key, hash);</span><br><span class="line">  &#125;</span><br><span class="line"> <span class="comment">// 插入，使用FindPointer方法找到插入位置，在hashtable 对位位置插入，当hashtable 中的元素个数大于桶的个数时候触发hashtable 的扩容</span></span><br><span class="line">  <span class="function">LRUHandle* <span class="title">Insert</span><span class="params">(LRUHandle* h)</span> </span>&#123;</span><br><span class="line">    LRUHandle** ptr = FindPointer(h-&gt;key(), h-&gt;hash);</span><br><span class="line">    LRUHandle* old = *ptr;</span><br><span class="line">    h-&gt;next_hash = (old == <span class="literal">NULL</span> ? <span class="literal">NULL</span> : old-&gt;next_hash);</span><br><span class="line">    *ptr = h;</span><br><span class="line">    <span class="keyword">if</span> (old == <span class="literal">NULL</span>) &#123;</span><br><span class="line">      ++elems_;</span><br><span class="line">      <span class="keyword">if</span> (elems_ &gt; length_) &#123;</span><br><span class="line">        <span class="comment">// Since each cache entry is fairly large, we aim for a small</span></span><br><span class="line">        <span class="comment">// average linked list length (&lt;= 1).</span></span><br><span class="line">        Resize();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> old;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// 删除hashtable中的元素，同样使用FindPointer方法定位到在hashtable 中的位置</span></span><br><span class="line">  <span class="function">LRUHandle* <span class="title">Remove</span><span class="params">(<span class="keyword">const</span> Slice&amp; key, <span class="keyword">uint32_t</span> hash)</span> </span>&#123;</span><br><span class="line">    LRUHandle** ptr = FindPointer(key, hash);</span><br><span class="line">    LRUHandle* result = *ptr;</span><br><span class="line">    <span class="keyword">if</span> (result != <span class="literal">NULL</span>) &#123;</span><br><span class="line">      *ptr = result-&gt;next_hash;</span><br><span class="line">      --elems_;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">// The table consists of an array of buckets where each bucket is</span></span><br><span class="line">  <span class="comment">// a linked list of cache entries that hash into the bucket.</span></span><br><span class="line">  <span class="keyword">uint32_t</span> length_;</span><br><span class="line">  <span class="keyword">uint32_t</span> elems_;</span><br><span class="line">  LRUHandle** list_;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Return a pointer to slot that points to a cache entry that</span></span><br><span class="line">  <span class="comment">// matches key/hash.  If there is no such cache entry, return a</span></span><br><span class="line">  <span class="comment">// pointer to the trailing slot in the corresponding linked list.</span></span><br><span class="line">  <span class="comment">// 找到hash 元素的地址</span></span><br><span class="line">  <span class="function">LRUHandle** <span class="title">FindPointer</span><span class="params">(<span class="keyword">const</span> Slice&amp; key, <span class="keyword">uint32_t</span> hash)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//找到hash 桶的位置，由于length_是2的指数次幂，所以使用 按位与替换mod操作进行加速</span></span><br><span class="line">    LRUHandle** ptr = &amp;list_[hash &amp; (length_ - <span class="number">1</span>)];</span><br><span class="line">    <span class="comment">// 遍历hash桶中的单链表直到找到相应节点或单链表结束</span></span><br><span class="line">    <span class="keyword">while</span> (*ptr != <span class="literal">NULL</span> &amp;&amp;</span><br><span class="line">           ((*ptr)-&gt;hash != hash || key != (*ptr)-&gt;key())) &#123;</span><br><span class="line">      ptr = &amp;(*ptr)-&gt;next_hash;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ptr;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// hash 表扩容</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Resize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 每次扩容都是翻倍，保证hash桶的个数是2的指数次幂</span></span><br><span class="line">    <span class="keyword">uint32_t</span> new_length = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">while</span> (new_length &lt; elems_) &#123;</span><br><span class="line">      new_length *= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建一个新的hashtable</span></span><br><span class="line">    LRUHandle** new_list = <span class="keyword">new</span> LRUHandle*[new_length];</span><br><span class="line">    <span class="built_in">memset</span>(new_list, <span class="number">0</span>, <span class="keyword">sizeof</span>(new_list[<span class="number">0</span>]) * new_length);</span><br><span class="line">    <span class="keyword">uint32_t</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 逐个桶迁移到新的hashtable</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">uint32_t</span> i = <span class="number">0</span>; i &lt; length_; i++) &#123;</span><br><span class="line">      LRUHandle* h = list_[i];</span><br><span class="line">      <span class="keyword">while</span> (h != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        LRUHandle* next = h-&gt;next_hash;</span><br><span class="line">        <span class="keyword">uint32_t</span> hash = h-&gt;hash;</span><br><span class="line">        LRUHandle** ptr = &amp;new_list[hash &amp; (new_length - <span class="number">1</span>)];</span><br><span class="line">        h-&gt;next_hash = *ptr;</span><br><span class="line">        *ptr = h;</span><br><span class="line">        h = next;</span><br><span class="line">        count++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    assert(elems_ == count);</span><br><span class="line">    <span class="comment">// 释放掉老的hashtable</span></span><br><span class="line">    <span class="keyword">delete</span>[] list_;</span><br><span class="line">    <span class="comment">// 替换为新的hashtable</span></span><br><span class="line">    list_ = new_list;</span><br><span class="line">    length_ = new_length;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="单个LRUCache实现"><a href="#单个LRUCache实现" class="headerlink" title="单个LRUCache实现"></a>单个LRUCache实现</h3><h4 id="LRUCache-类声明"><a href="#LRUCache-类声明" class="headerlink" title="LRUCache 类声明"></a>LRUCache 类声明</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> </span>&#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  LRUCache();</span><br><span class="line">  ~LRUCache();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Separate from constructor so caller can easily make an array of LRUCache</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">SetCapacity</span><span class="params">(size_t capacity)</span> </span>&#123; capacity_ = capacity; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Like Cache methods, but with an extra "hash" parameter.</span></span><br><span class="line">  Cache::Handle* Insert(<span class="keyword">const</span> Slice&amp; key, uint32_t hash,</span><br><span class="line">                        <span class="keyword">void</span>* value, size_t charge,</span><br><span class="line">                        <span class="keyword">void</span> (*deleter)(<span class="keyword">const</span> Slice&amp; key, <span class="keyword">void</span>* value));</span><br><span class="line">  Cache::Handle* Lookup(<span class="keyword">const</span> Slice&amp; key, uint32_t hash);</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Release</span><span class="params">(Cache::Handle* handle)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Erase</span><span class="params">(<span class="keyword">const</span> Slice&amp; key, uint32_t hash)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Prune</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function">size_t <span class="title">TotalCharge</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="function">MutexLock <span class="title">l</span><span class="params">(&amp;mutex_)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> usage_;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">LRU_Remove</span><span class="params">(LRUHandle* e)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">LRU_Append</span><span class="params">(LRUHandle* e)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Unref</span><span class="params">(LRUHandle* e)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Initialized before use.</span></span><br><span class="line">  <span class="comment">// LRUCache 存储的元素个数，超过此个数触发淘汰机制</span></span><br><span class="line">  size_t capacity_;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// mutex_ protects the following state.</span></span><br><span class="line">  mutable port::Mutex mutex_;</span><br><span class="line">  size_t usage_;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Dummy head of LRU list.</span></span><br><span class="line">  <span class="comment">// lru.prev is newest entry, lru.next is oldest entry.</span></span><br><span class="line">  <span class="comment">// 按照访问时间顺序存储的双向循环链表</span></span><br><span class="line">  LRUHandle lru_;</span><br><span class="line">  <span class="comment">// 自己实现的拉链式的hash table</span></span><br><span class="line">  HandleTable table_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="LRUCache-插入"><a href="#LRUCache-插入" class="headerlink" title="LRUCache 插入"></a>LRUCache 插入</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">Cache::Handle* LRUCache::Insert(</span><br><span class="line">    <span class="keyword">const</span> Slice&amp; key, <span class="keyword">uint32_t</span> hash, <span class="keyword">void</span>* value, <span class="keyword">size_t</span> charge,</span><br><span class="line">    <span class="keyword">void</span> (*deleter)(<span class="keyword">const</span> Slice&amp; key, <span class="keyword">void</span>* value)) &#123;</span><br><span class="line">  <span class="function">MutexLock <span class="title">l</span><span class="params">(&amp;mutex_)</span></span>;</span><br><span class="line">  <span class="comment">// 构造一个新的LRUHandle 对象</span></span><br><span class="line">  LRUHandle* e = <span class="keyword">reinterpret_cast</span>&lt;LRUHandle*&gt;(</span><br><span class="line">      <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LRUHandle)<span class="number">-1</span> + key.size()));</span><br><span class="line">  e-&gt;value = value;</span><br><span class="line">  e-&gt;deleter = deleter;</span><br><span class="line">  e-&gt;charge = charge;</span><br><span class="line">  e-&gt;key_length = key.size();</span><br><span class="line">  e-&gt;hash = hash;</span><br><span class="line">  e-&gt;refs = <span class="number">2</span>;  <span class="comment">// One from LRUCache, one for the returned handle</span></span><br><span class="line">  <span class="built_in">memcpy</span>(e-&gt;key_data, key.data(), key.size());</span><br><span class="line">  <span class="comment">// 插入到双向链表表头的位置</span></span><br><span class="line">  LRU_Append(e);</span><br><span class="line">  usage_ += charge;</span><br><span class="line"></span><br><span class="line">  LRUHandle* old = table_.Insert(e);</span><br><span class="line">  <span class="comment">// 替换掉LRUCache中重复的元素</span></span><br><span class="line">  <span class="keyword">if</span> (old != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    LRU_Remove(old);</span><br><span class="line">    Unref(old);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 触发LRU 淘汰</span></span><br><span class="line">  <span class="keyword">while</span> (usage_ &gt; capacity_ &amp;&amp; lru_.next != &amp;lru_) &#123;</span><br><span class="line">    <span class="comment">// 淘汰双向链表最后的元素</span></span><br><span class="line">    LRUHandle* old = lru_.next;</span><br><span class="line">    <span class="comment">// 删除双向链表中的元素</span></span><br><span class="line">    LRU_Remove(old);</span><br><span class="line">    <span class="comment">// 删除hashtable中的元素</span></span><br><span class="line">    table_.Remove(old-&gt;key(), old-&gt;hash);</span><br><span class="line">    Unref(old);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 返回刚刚插入的Handle对象，此对象引用计数为2</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">reinterpret_cast</span>&lt;Cache::Handle*&gt;(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="LRUCache-删除"><a href="#LRUCache-删除" class="headerlink" title="LRUCache 删除"></a>LRUCache 删除</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> LRUCache::Erase(<span class="keyword">const</span> Slice&amp; key, <span class="keyword">uint32_t</span> hash) &#123;</span><br><span class="line">  <span class="function">MutexLock <span class="title">l</span><span class="params">(&amp;mutex_)</span></span>;</span><br><span class="line">  <span class="comment">// 删除hashtable中对应的元素，</span></span><br><span class="line">  <span class="comment">// 如果该元素存在在hashtable中则在双向链表中进行删除</span></span><br><span class="line">  LRUHandle* e = table_.Remove(key, hash);</span><br><span class="line">  <span class="keyword">if</span> (e != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    LRU_Remove(e);</span><br><span class="line">    Unref(e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="LRUCache-Prune"><a href="#LRUCache-Prune" class="headerlink" title="LRUCache Prune"></a>LRUCache Prune</h4><p>删除LRUCache中ref为1 的元素，最初插入的元素的引用为2，外部消费者对使用结束的元素ref减一。LRUCache中ref 为1 的handle表示此元素只在LRUCache中出现，外部并不使用。此方法的作用就是删除这样的元素。<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void <span class="symbol">LRUCache:</span><span class="symbol">:Prune</span>() &#123;</span><br><span class="line">  MutexLock l(&amp;mutex<span class="number">_</span>);</span><br><span class="line">  <span class="keyword">for</span> (LRUHandle* e = lru<span class="number">_</span>.<span class="keyword">next</span>; e != &amp;lru<span class="number">_</span>; ) &#123;</span><br><span class="line">    LRUHandle* <span class="keyword">next</span> = e-&gt;<span class="keyword">next</span>;</span><br><span class="line">    if (e-&gt;refs == <span class="number">1</span>) &#123;</span><br><span class="line">      table<span class="number">_</span>.Remove(e-&gt;key(), e-&gt;hash);</span><br><span class="line">      LRU_Remove(e);</span><br><span class="line">      Unref(e);</span><br><span class="line">    &#125;</span><br><span class="line">    e = <span class="keyword">next</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="LRU-Remove"><a href="#LRU-Remove" class="headerlink" title="LRU_Remove"></a>LRU_Remove</h4><p>删除双向链表中一个节点<br><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void LRUCache::LRU_Remove(LRUHandle* e) &#123;</span><br><span class="line">  <span class="function"><span class="title">e</span>-&gt;</span><span class="function"><span class="title">next</span>-&gt;</span><span class="function"><span class="title">prev</span> = e-&gt;</span>prev;</span><br><span class="line">  <span class="function"><span class="title">e</span>-&gt;</span><span class="function"><span class="title">prev</span>-&gt;</span><span class="function"><span class="title">next</span> = e-&gt;</span>next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="LRU-Append"><a href="#LRU-Append" class="headerlink" title="LRU_Append"></a>LRU_Append</h4><p>插入到双向链表表头位置<br><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void LRUCache::LRU_Append(LRUHandle* e) &#123;</span><br><span class="line">  <span class="comment">// Make "e" newest entry by inserting just before lru_</span></span><br><span class="line">  <span class="function"><span class="title">e</span>-&gt;</span>next = &amp;lru_;</span><br><span class="line">  <span class="function"><span class="title">e</span>-&gt;</span>prev = lru_.prev;</span><br><span class="line">  <span class="function"><span class="title">e</span>-&gt;</span><span class="function"><span class="title">prev</span>-&gt;</span>next = e;</span><br><span class="line">  <span class="function"><span class="title">e</span>-&gt;</span><span class="function"><span class="title">next</span>-&gt;</span>prev = e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="ShardedLRUCache"><a href="#ShardedLRUCache" class="headerlink" title="ShardedLRUCache"></a>ShardedLRUCache</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> kNumShardBits = <span class="number">4</span>;</span><br><span class="line"><span class="comment">// 16个 lru cache，目的在多线程的环境下，每个线程的访问都会锁住缓冲区</span></span><br><span class="line"><span class="comment">// 如果缓冲区比较大的话， 多线程情况下的性能比较差，</span></span><br><span class="line"><span class="comment">// 所以使用hash 的方式将一块cache 缓冲区 划分为多个小块的缓冲区</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> kNumShards = <span class="number">1</span> &lt;&lt; kNumShardBits;</span><br><span class="line">class ShardedLRUCache : <span class="keyword">public</span> Cache &#123;</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">// LRUCache 数组，每个LRUCache对象使用自己的锁</span></span><br><span class="line">  LRUCache shard_[kNumShards];</span><br><span class="line">  <span class="comment">// 这个锁只保护id</span></span><br><span class="line">  port::Mutex id_mutex_;</span><br><span class="line">  uint64_t last_id_;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">inline</span> uint32_t HashSlice(<span class="keyword">const</span> Slice&amp; s) &#123;</span><br><span class="line">    <span class="built_in">return</span> Hash(s.data(), s.<span class="built_in">size</span>(), <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Shard 函数，根据key计算的hash 值定位LRUCache数组的位置</span></span><br><span class="line">  <span class="keyword">static</span> uint32_t Shard(uint32_t hash) &#123;</span><br><span class="line">    <span class="comment">// 不需要使用mod运算，此数值一定是在0~kNumShards这个区间</span></span><br><span class="line">    <span class="built_in">return</span> hash &gt;&gt; (<span class="number">32</span> - kNumShardBits);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">explicit</span> ShardedLRUCache(size_t capacity)</span><br><span class="line">      : last_id_(<span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 向上取整，为每个LRUCache 分配容量</span></span><br><span class="line">    <span class="keyword">const</span> size_t per_shard = (capacity + (kNumShards - <span class="number">1</span>)) / kNumShards;</span><br><span class="line">    <span class="built_in">for</span> (<span class="keyword">int</span> s = <span class="number">0</span>; s &lt; kNumShards; s++) &#123;</span><br><span class="line">      shard_[s].SetCapacity(per_shard);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">virtual</span> ~ShardedLRUCache() &#123; &#125;</span><br><span class="line">  <span class="comment">// 插入时，先使用Shard方法定位到相应的LRUCache</span></span><br><span class="line">  <span class="keyword">virtual</span> Handle* Insert(<span class="keyword">const</span> Slice&amp; key, <span class="keyword">void</span>* value, size_t charge,</span><br><span class="line">                         <span class="keyword">void</span> (*deleter)(<span class="keyword">const</span> Slice&amp; key, <span class="keyword">void</span>* value)) &#123;</span><br><span class="line">    <span class="keyword">const</span> uint32_t hash = HashSlice(key);</span><br><span class="line">    <span class="built_in">return</span> shard_[Shard(hash)].Insert(key, hash, value, charge, deleter);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">virtual</span> Handle* Lookup(<span class="keyword">const</span> Slice&amp; key) &#123;</span><br><span class="line">    <span class="keyword">const</span> uint32_t hash = HashSlice(key);</span><br><span class="line">    <span class="built_in">return</span> shard_[Shard(hash)].Lookup(key, hash);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">virtual</span> <span class="keyword">void</span> Release(Handle* handle) &#123;</span><br><span class="line">    LRUHandle* h = <span class="keyword">reinterpret_cast</span>&lt;LRUHandle*&gt;(handle);</span><br><span class="line">    shard_[Shard(h-&gt;hash)].Release(handle);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">virtual</span> <span class="keyword">void</span> Erase(<span class="keyword">const</span> Slice&amp; key) &#123;</span><br><span class="line">    <span class="keyword">const</span> uint32_t hash = HashSlice(key);</span><br><span class="line">    shard_[Shard(hash)].Erase(key, hash);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">virtual</span> <span class="keyword">void</span>* Value(Handle* handle) &#123;</span><br><span class="line">    <span class="built_in">return</span> <span class="keyword">reinterpret_cast</span>&lt;LRUHandle*&gt;(handle)-&gt;value;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">virtual</span> uint64_t NewId() &#123;</span><br><span class="line">    MutexLock l(&amp;id_mutex_);</span><br><span class="line">    <span class="built_in">return</span> ++(last_id_);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">virtual</span> <span class="keyword">void</span> Prune() &#123;</span><br><span class="line">    <span class="built_in">for</span> (<span class="keyword">int</span> s = <span class="number">0</span>; s &lt; kNumShards; s++) &#123;</span><br><span class="line">      shard_[s].Prune();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">virtual</span> size_t TotalCharge() <span class="keyword">const</span> &#123;</span><br><span class="line">    size_t total = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">for</span> (<span class="keyword">int</span> s = <span class="number">0</span>; s &lt; kNumShards; s++) &#123;</span><br><span class="line">      total += shard_[s].TotalCharge();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> total;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Leveldb 实现的LRUCahe 基于hashtable以及双向链表实现，为了提升性能以及保证跨平台特性，Leveldb 实现了一个线程安全的拉链式hashtable,此hashtable 的缺点是当触发扩容操作的时候需要将老hashtable 的全部元素复制到新的hashtable 中，这会期间会一直占用锁，此时多线程环境下的读写会阻塞。这一点Memcached 中实现的hashtable是有一个线程专门负责扩展，每次只扩展一个元素。<br>Leveldb 为了提升多线程环境下的读写性能，将固定容量的Cache分摊到多个LRUCache，每个LRUCache保证自己的线程安全，这就降低了多线程环境下锁的竞争。这种做法与分段锁的思想类似。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://carbo06.github.io/2018/05/09/Linux-shell-颜色输出/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="carbo06@163.com">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Carbon's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/09/Linux-shell-颜色输出/" itemprop="url">Linux shell 颜色输出</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-09T14:54:36+08:00">
                2018-05-09
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于&#58;</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2018-05-09T14:56:34+08:00">
                2018-05-09
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Backend-Development/" itemprop="url" rel="index">
                    <span itemprop="name">Backend Development</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>可以利用<a href="https://en.wikipedia.org/wiki/ANSI_escape_code%20ANSI%20escape%20code" target="_blank" rel="noopener">ANSI escape code</a> 实现linux终端输出颜色文本。下面是几个ANSI escape code 对应的颜色。<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Black        <span class="number">0</span>;<span class="number">30</span>     Dark Gray     <span class="number">1</span>;<span class="number">30</span></span><br><span class="line">Red          <span class="number">0</span>;<span class="number">31</span>     Light Red     <span class="number">1</span>;<span class="number">31</span></span><br><span class="line">Green        <span class="number">0</span>;<span class="number">32</span>     Light Green   <span class="number">1</span>;<span class="number">32</span></span><br><span class="line">Brown/Orange <span class="number">0</span>;<span class="number">33</span>     Yellow        <span class="number">1</span>;<span class="number">33</span></span><br><span class="line">Blue         <span class="number">0</span>;<span class="number">34</span>     Light Blue    <span class="number">1</span>;<span class="number">34</span></span><br><span class="line">Purple       <span class="number">0</span>;<span class="number">35</span>     Light Purple  <span class="number">1</span>;<span class="number">35</span></span><br><span class="line">Cyan         <span class="number">0</span>;<span class="number">36</span>     Light Cyan    <span class="number">1</span>;<span class="number">36</span></span><br><span class="line">Light Gray   <span class="number">0</span>;<span class="number">37</span>     White         <span class="number">1</span>;<span class="number">37</span></span><br></pre></td></tr></table></figure></p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>以下是一个输出ANSI Rainbow 的示例。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="keyword">for</span> (( i = 30; i &lt; 38; i++ ))</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">	<span class="built_in">echo</span> -e <span class="string">"\033[0;"</span><span class="variable">$i</span><span class="string">"m Normal: (0;<span class="variable">$i</span>); \033[1;"</span><span class="variable">$i</span><span class="string">"m Light: (1;<span class="variable">$i</span>)"</span>;</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure></p>
<p>输出结果如下<br><img src="https://myblog-1256683296.cos.ap-beijing.myqcloud.com/colorful_echo.jpg" alt="avatar"><br>如果想设置固定区间的颜色，可以将’\033[0m’放在对应区间的结尾。如下示例<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">NC=<span class="string">'\033[0m'</span> <span class="comment"># No Color</span></span><br><span class="line"><span class="keyword">for</span> (( i = 30; i &lt; 38; i++ ))</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> -e <span class="string">"I \033[0;<span class="variable">$&#123;i&#125;</span>mlove<span class="variable">$&#123;NC&#125;</span> Linux"</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure></p>
<p>输出结果如下<br><img src="https://myblog-1256683296.cos.ap-beijing.myqcloud.com/range_colorful_echo.jpg" alt="avatar"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://carbo06.github.io/2018/05/03/Leveldb-Arena解析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="carbo06@163.com">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Carbon's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/03/Leveldb-Arena解析/" itemprop="url">Leveldb Arena解析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-03T16:30:27+08:00">
                2018-05-03
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于&#58;</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2018-05-03T16:34:50+08:00">
                2018-05-03
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Backend-Development/" itemprop="url" rel="index">
                    <span itemprop="name">Backend Development</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Arena 是leveldb 实现的简单的内存池，以最小4096bytes 为单位申请block, 使用指针记录当前block 中空余内存起始位置以及当前block剩余空间。将所有的block 放到blocks_ 数组中。Arena 提供了分配内存以及分配对齐的内存的两种接口，没有释放内存的接口，当Arena 的生命周期结束时，由Arena 的析构函数统一释放内存。Arena 的主要结构如下图所示：<br><img src="https://img-blog.csdn.net/20180503153740789?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NhcmJvbjA2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="leveldb arena"></p>
<h2 id="Leveldb-代码实现"><a href="#Leveldb-代码实现" class="headerlink" title="Leveldb 代码实现"></a>Leveldb 代码实现</h2><p>leveldb arena 实现在util/arena.h 以及 util/arena.cc</p>
<h3 id="接口以及成员"><a href="#接口以及成员" class="headerlink" title="接口以及成员"></a>接口以及成员</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Arena</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  Arena();</span><br><span class="line">  ~Arena();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Return a pointer to a newly allocated memory block of "bytes" bytes.</span></span><br><span class="line">  <span class="comment">// 分配指定大小的内存，并返回分配内存的首地址</span></span><br><span class="line">  <span class="function"><span class="keyword">char</span>* <span class="title">Allocate</span><span class="params">(<span class="keyword">size_t</span> bytes)</span></span>;</span><br><span class="line">  <span class="comment">// 分配指定大小并且对齐的内存</span></span><br><span class="line">  <span class="comment">// Allocate memory with the normal alignment guarantees provided by malloc</span></span><br><span class="line">  <span class="function"><span class="keyword">char</span>* <span class="title">AllocateAligned</span><span class="params">(<span class="keyword">size_t</span> bytes)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Returns an estimate of the total memory usage of data allocated</span></span><br><span class="line">  <span class="comment">// by the arena.</span></span><br><span class="line">  <span class="comment">// 统计使用了多少内存</span></span><br><span class="line">  <span class="keyword">size_t</span> MemoryUsage() <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">uintptr_t</span>&gt;(memory_usage_.NoBarrier_Load());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">// 分配内存，根据情况决定是否使用新的block</span></span><br><span class="line">  <span class="function"><span class="keyword">char</span>* <span class="title">AllocateFallback</span><span class="params">(<span class="keyword">size_t</span> bytes)</span></span>;</span><br><span class="line">  <span class="comment">// 分配一个新的block</span></span><br><span class="line">  <span class="function"><span class="keyword">char</span>* <span class="title">AllocateNewBlock</span><span class="params">(<span class="keyword">size_t</span> block_bytes)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Allocation state</span></span><br><span class="line">  <span class="comment">// 指向一个block中未被使用的内存首地址</span></span><br><span class="line">  <span class="keyword">char</span>* alloc_ptr_;</span><br><span class="line">  <span class="comment">// 表示一个block还剩余多少空间</span></span><br><span class="line">  <span class="keyword">size_t</span> alloc_bytes_remaining_;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Array of new[] allocated memory blocks</span></span><br><span class="line">  <span class="comment">// 内存池数组</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">char</span>*&gt; blocks_;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Total memory usage of the arena.</span></span><br><span class="line">  <span class="comment">// 统计内存使用，原子变量</span></span><br><span class="line">  port::AtomicPointer memory_usage_;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// No copying allowed</span></span><br><span class="line">  <span class="comment">// 将拷贝构造和赋值构造设置为私有</span></span><br><span class="line">  Arena(<span class="keyword">const</span> Arena&amp;);</span><br><span class="line">  <span class="keyword">void</span> <span class="keyword">operator</span>=(<span class="keyword">const</span> Arena&amp;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="分配指定bytes-的内存"><a href="#分配指定bytes-的内存" class="headerlink" title="分配指定bytes 的内存"></a>分配指定bytes 的内存</h3><p>首先根据alloc_bytes_remaining_判断是否需要分配一个新的block ,如果不需要的话，则重新设置alloc_ptr_ 以及 alloc_bytes_remaining_，否则调用<strong>AllocFallback</strong>方法分配新的block,并且判断新的block 是否可以被复用。<br><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> char* Arena<span class="type">::Allocate</span>(size_t <span class="built_in">bytes</span>) &#123;</span><br><span class="line">  <span class="comment">// The semantics of what to return are a bit messy if we allow</span></span><br><span class="line">  <span class="comment">// 0-byte allocations, so we disallow them here (we don't need</span></span><br><span class="line">  <span class="comment">// them for our internal use).</span></span><br><span class="line">  assert(<span class="built_in">bytes</span> &gt; <span class="number">0</span>);</span><br><span class="line">  <span class="comment">// 判断是否有可被复用的block</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">bytes</span> &lt;= alloc_bytes_remaining_) &#123;</span><br><span class="line">    char* result = alloc_ptr_;</span><br><span class="line">    alloc_ptr_ += <span class="built_in">bytes</span>;</span><br><span class="line">    alloc_bytes_remaining_ -= <span class="built_in">bytes</span>;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> AllocateFallback(<span class="built_in">bytes</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="分配指定bytes-对齐的内存"><a href="#分配指定bytes-对齐的内存" class="headerlink" title="分配指定bytes 对齐的内存"></a>分配指定bytes 对齐的内存</h3><p>与上一个接口不同的地方在于，将传入的bytes 化为可对齐内存的大小<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span>* Arena::AllocateAligned(<span class="keyword">size_t</span> bytes) &#123;</span><br><span class="line">  <span class="comment">// 获取当前系统指针大小</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">int</span> align = (<span class="keyword">sizeof</span>(<span class="keyword">void</span>*) &gt; <span class="number">8</span>) ? <span class="keyword">sizeof</span>(<span class="keyword">void</span>*) : <span class="number">8</span>;</span><br><span class="line">  <span class="comment">// 指针大小必须是2的整数次幂，2的整数次幂的二进制表示中</span></span><br><span class="line">  <span class="comment">// 有且只有1位是1</span></span><br><span class="line">  assert((align &amp; (align<span class="number">-1</span>)) == <span class="number">0</span>);   <span class="comment">// Pointer size should be a power of 2</span></span><br><span class="line">  <span class="comment">// 判断bytes是不是align 的整数倍，由于align是2的</span></span><br><span class="line">  <span class="comment">// 整数次幂，所以对align的取模运算可以转化为</span></span><br><span class="line">  <span class="comment">// 对（align - 1）进行按位与</span></span><br><span class="line">  <span class="keyword">size_t</span> current_mod = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">uintptr_t</span>&gt;(alloc_ptr_) &amp; (align<span class="number">-1</span>);</span><br><span class="line">  <span class="comment">// 为了对齐内存需要新增的大小</span></span><br><span class="line">  <span class="keyword">size_t</span> slop = (current_mod == <span class="number">0</span> ? <span class="number">0</span> : align - current_mod);</span><br><span class="line">  <span class="comment">// needed 表示分配对齐的内存所需的大小</span></span><br><span class="line">  <span class="comment">// 后面的逻辑同前</span></span><br><span class="line">  <span class="keyword">size_t</span> needed = bytes + slop;</span><br><span class="line">  <span class="keyword">char</span>* result;</span><br><span class="line">  <span class="keyword">if</span> (needed &lt;= alloc_bytes_remaining_) &#123;</span><br><span class="line">    result = alloc_ptr_ + slop;</span><br><span class="line">    alloc_ptr_ += needed;</span><br><span class="line">    alloc_bytes_remaining_ -= needed;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// AllocateFallback always returned aligned memory</span></span><br><span class="line">    result = AllocateFallback(bytes);</span><br><span class="line">  &#125;</span><br><span class="line">  assert((<span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">uintptr_t</span>&gt;(result) &amp; (align<span class="number">-1</span>)) == <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="AllocateFallback"><a href="#AllocateFallback" class="headerlink" title="AllocateFallback"></a>AllocateFallback</h3><p>函数的作用是分配一个新的block。不同的是，如果bytes 小于blocksize 的四分之一，则此新分配的block 可以被继续复用。否则的话直接分配新的block, Arena 中可被复用的block 保持不变。<br><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">char* Arena<span class="type">::AllocateFallback</span>(size_t <span class="built_in">bytes</span>) &#123;</span><br><span class="line">  <span class="comment">// 分配的bytes较小，此新block可以被复用</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">bytes</span> &gt; kBlockSize / <span class="number">4</span>) &#123;</span><br><span class="line">    <span class="comment">// Object is more than a quarter of our block size.  Allocate it separately</span></span><br><span class="line">    <span class="comment">// to avoid wasting too much space in leftover bytes.</span></span><br><span class="line">    char* result = AllocateNewBlock(<span class="built_in">bytes</span>);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// We waste the remaining space in the current block.</span></span><br><span class="line">  <span class="comment">// 此新分配的block可以被复用，重新设置</span></span><br><span class="line">  <span class="comment">// alloc_ptr_ 以及 alloc_bytes_remaining_</span></span><br><span class="line">  alloc_ptr_ = AllocateNewBlock(kBlockSize);</span><br><span class="line">  alloc_bytes_remaining_ = kBlockSize;</span><br><span class="line"></span><br><span class="line">  char* result = alloc_ptr_;</span><br><span class="line">  alloc_ptr_ += <span class="built_in">bytes</span>;</span><br><span class="line">  alloc_bytes_remaining_ -= <span class="built_in">bytes</span>;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="AllocateNewBlock"><a href="#AllocateNewBlock" class="headerlink" title="AllocateNewBlock"></a>AllocateNewBlock</h3><p>直接使用new分配符分配指定大小的内存，并且更新memory_usage_<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span>* Arena::AllocateNewBlock(<span class="keyword">size_t</span> block_bytes) &#123;</span><br><span class="line">  <span class="comment">// 分配空间</span></span><br><span class="line">  <span class="keyword">char</span>* result = <span class="keyword">new</span> <span class="keyword">char</span>[block_bytes];</span><br><span class="line">  <span class="comment">// 新的block 加入内存池</span></span><br><span class="line">  blocks_.push_back(result);</span><br><span class="line">  <span class="comment">// 更新memory_usage_</span></span><br><span class="line">  memory_usage_.NoBarrier_Store(</span><br><span class="line">      <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">void</span>*&gt;(MemoryUsage() + block_bytes + <span class="keyword">sizeof</span>(<span class="keyword">char</span>*)));</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="析构"><a href="#析构" class="headerlink" title="析构"></a>析构</h3><p>逐个释放内存池中的block<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Arena::~Arena() &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; blocks_.size(); i++) &#123;</span><br><span class="line">    <span class="keyword">delete</span>[] blocks_[i];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Leveldb Arena 实现简单，Arena 的设计与leveldb 特定的应用场景相关，比如一个memtable 使用一个Arena对象统一获取内存，当memtable对象声明周期结束时，由Arena 统一释放内存，不需要消费者每次new一片内存就要自己delete 掉。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://carbo06.github.io/2018/04/28/Leveldb-BloomFilter-解析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="carbo06@163.com">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Carbon's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/28/Leveldb-BloomFilter-解析/" itemprop="url">Leveldb BloomFilter 解析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-28T15:39:24+08:00">
                2018-04-28
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于&#58;</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2018-04-28T16:25:04+08:00">
                2018-04-28
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Backend-Development/" itemprop="url" rel="index">
                    <span itemprop="name">Backend Development</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="BloomFilter-原理"><a href="#BloomFilter-原理" class="headerlink" title="BloomFilter 原理"></a>BloomFilter 原理</h2><p>布隆过滤器由巴顿布隆于1970年提出，由一个很长的bit数组以及一系列hash函数组成。bloomfilter可以用于检索一个元素是否出现在一个集合中，bloomfilter的优点是相比hash表拥有极大的空间效率，缺点是会出现一定的错误概率(False positive,一个不在集合中的元素被误认为处于集合中）。<br>bloomfilter 的原理是，当一个元素在加入集合时，通过k个hash 函数映射到bit数组的k个位置，并将相应的位置置1。在查找一个元素是否存在于集合中时，使用相同的k个hash 函数查看bit数组中的位置是否为全为1，如果出现一个0，则该key 一定不存在集合中，否则有可能出现在集合中。</p>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>Bloomfilter 可以使用较少的空间存储大量数据的全集，并且存储的不是每个元素的原本的数值，只是设置对应的bit位，一定程度上实现了加密的效果。除空间效率之外，bloomfilter的时间效率都是常数级别O(k),其中k 代表使用的hash 函数个数，由于k个hash 函数式相互独立的性质，在进行k个hash 计算时可以并行计算进一步加速插入查找。</p>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>Bloomfilter 的缺点是会出现False positive 的误判率，而且随着元素的增加，误算率也随之增加。因此尽可能降低误判率需要一些额外工作。</p>
<h3 id="BloomFilter参数选择"><a href="#BloomFilter参数选择" class="headerlink" title="BloomFilter参数选择"></a>BloomFilter参数选择</h3><p>以下均参考wikipedia <a href="https://en.wikipedia.org/wiki/Bloom_filter" target="_blank" rel="noopener">bloomfilter</a> 中关于误差率的计算章节。直接说结论，当k(hash 函数个数)，m(bit数组大小)，n(插入元素个数)满足下式的时候，可以保证最低的误差率。$$k=\cfrac{m}{n}ln2$$下图(摘自wikipedia) 表示在最优hash函数个数的情况下，不同m,n之间误差率关系。</p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/e/ef/Bloom_filter_fp_probability.svg" width="450" height="360/">从上图可以看到当存储10亿个元素时使用4GB的存储空间可以保证不到1e-06的错误率。可以看到bloomfilter在实现高空间利用率的同时可以保证较低误差率。</p>
<h2 id="Leveldb-实现"><a href="#Leveldb-实现" class="headerlink" title="Leveldb 实现"></a>Leveldb 实现</h2><p>leveldb bloomfilter 实现在util/bloom.cc</p>
<h3 id="成员变量以及构造函数"><a href="#成员变量以及构造函数" class="headerlink" title="成员变量以及构造函数"></a>成员变量以及构造函数</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class BloomFilterPolicy : <span class="keyword">public</span> FilterPolicy &#123;</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">// 平均每个key拥有的bit 数目</span></span><br><span class="line">  size_t bits_per_key_;</span><br><span class="line">  <span class="comment">// hash function 的个数</span></span><br><span class="line">  size_t k_;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">explicit</span> BloomFilterPolicy(<span class="keyword">int</span> bits_per_key)</span><br><span class="line">      : bits_per_key_(bits_per_key) &#123;</span><br><span class="line">    <span class="comment">// We intentionally round down to reduce probing cost a little bit</span></span><br><span class="line">    <span class="comment">// 按照上面的公式设定hash函数的个数</span></span><br><span class="line">    k_ = <span class="keyword">static_cast</span>&lt;size_t&gt;(bits_per_key * <span class="number">0.69</span>);  <span class="comment">// 0.69 =~ ln(2)</span></span><br><span class="line">    <span class="built_in">if</span> (k_ &lt; <span class="number">1</span>) k_ = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">if</span> (k_ &gt; <span class="number">30</span>) k_ = <span class="number">30</span>;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure>
<h3 id="CreateFilter"><a href="#CreateFilter" class="headerlink" title="CreateFilter"></a>CreateFilter</h3><p>将传入的n个key 存储到bloomfilter 中，bloomfilter结果使用string存储。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">CreateFilter</span><span class="params">(<span class="keyword">const</span> Slice* keys, <span class="keyword">int</span> n, <span class="built_in">std</span>::<span class="built_in">string</span>* dst)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Compute bloom filter size (in both bits and bytes)</span></span><br><span class="line">    <span class="comment">// bloomfilter 需要多少bit</span></span><br><span class="line">    <span class="keyword">size_t</span> bits = n * bits_per_key_;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// For small n, we can see a very high false positive rate.  Fix it</span></span><br><span class="line">    <span class="comment">// by enforcing a minimum bloom filter length.</span></span><br><span class="line">    <span class="keyword">if</span> (bits &lt; <span class="number">64</span>) bits = <span class="number">64</span>;</span><br><span class="line">    <span class="comment">// 对齐,方便内存读写以及后续位置索引</span></span><br><span class="line">    <span class="keyword">size_t</span> bytes = (bits + <span class="number">7</span>) / <span class="number">8</span>;</span><br><span class="line">    bits = bytes * <span class="number">8</span>;</span><br><span class="line">	<span class="comment">// 在string 中分配空间</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">size_t</span> init_size = dst-&gt;size();</span><br><span class="line">    dst-&gt;resize(init_size + bytes, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// string 的最后一个byte存储使用的hash 函数的个数</span></span><br><span class="line">    dst-&gt;push_back(<span class="keyword">static_cast</span>&lt;<span class="keyword">char</span>&gt;(k_));  <span class="comment">// Remember # of probes in filter</span></span><br><span class="line">    <span class="comment">// 获得string内部的char 型数组</span></span><br><span class="line">    <span class="keyword">char</span>* <span class="built_in">array</span> = &amp;(*dst)[init_size];</span><br><span class="line">    <span class="comment">// 逐个将每个key 写入bloom fliter</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">      <span class="comment">// Use double-hashing to generate a sequence of hash values.</span></span><br><span class="line">      <span class="comment">// See analysis in [Kirsch,Mitzenmacher 2006].</span></span><br><span class="line">      <span class="comment">// leveldb 使用一个hash 函数，每次对hash值向右循环移位17个bit来模拟实现多个hash 函数的效果</span></span><br><span class="line">      <span class="keyword">uint32_t</span> h = BloomHash(keys[i]);</span><br><span class="line">      <span class="comment">// 每次向右循环移位17个bit</span></span><br><span class="line">      <span class="keyword">const</span> <span class="keyword">uint32_t</span> delta = (h &gt;&gt; <span class="number">17</span>) | (h &lt;&lt; <span class="number">15</span>);  <span class="comment">// Rotate right 17 bits</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">size_t</span> j = <span class="number">0</span>; j &lt; k_; j++) &#123;</span><br><span class="line">        <span class="comment">// 在整个bit 数组的位置</span></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">uint32_t</span> bitpos = h % bits;</span><br><span class="line">        <span class="comment">// 在char型数组的位置</span></span><br><span class="line">        <span class="built_in">array</span>[bitpos/<span class="number">8</span>] |= (<span class="number">1</span> &lt;&lt; (bitpos % <span class="number">8</span>));</span><br><span class="line">        <span class="comment">// 更新获得一个新的hash 数值</span></span><br><span class="line">        h += delta;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="KeyMayMatch"><a href="#KeyMayMatch" class="headerlink" title="KeyMayMatch"></a>KeyMayMatch</h3><p>判断一个 key 在bloomfilter中是否存在。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">KeyMayMatch</span><span class="params">(<span class="keyword">const</span> Slice&amp; key, <span class="keyword">const</span> Slice&amp; bloom_filter)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">   <span class="keyword">const</span> <span class="keyword">size_t</span> len = bloom_filter.size();</span><br><span class="line">   <span class="keyword">if</span> (len &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">const</span> <span class="keyword">char</span>* <span class="built_in">array</span> = bloom_filter.data();</span><br><span class="line">   <span class="comment">// 最后一个byte数值代表使用了多少hash函数</span></span><br><span class="line">   <span class="comment">// 除最后一个byte之外代表bit数组</span></span><br><span class="line">   <span class="keyword">const</span> <span class="keyword">size_t</span> bits = (len - <span class="number">1</span>) * <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Use the encoded k so that we can read filters generated by</span></span><br><span class="line">   <span class="comment">// bloom filters created using different parameters.</span></span><br><span class="line">   <span class="keyword">const</span> <span class="keyword">size_t</span> k = <span class="built_in">array</span>[len<span class="number">-1</span>];</span><br><span class="line">   <span class="keyword">if</span> (k &gt; <span class="number">30</span>) &#123;</span><br><span class="line">     <span class="comment">// Reserved for potentially new encodings for short bloom filters.</span></span><br><span class="line">     <span class="comment">// Consider it a match.</span></span><br><span class="line">     <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">// 使用相同的方法模拟多个hash函数计算的hash值</span></span><br><span class="line">   <span class="keyword">uint32_t</span> h = BloomHash(key);</span><br><span class="line">   <span class="keyword">const</span> <span class="keyword">uint32_t</span> delta = (h &gt;&gt; <span class="number">17</span>) | (h &lt;&lt; <span class="number">15</span>);  <span class="comment">// Rotate right 17 bits</span></span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">size_t</span> j = <span class="number">0</span>; j &lt; k; j++) &#123;</span><br><span class="line">     <span class="keyword">const</span> <span class="keyword">uint32_t</span> bitpos = h % bits;</span><br><span class="line">     <span class="comment">// 找到一个bit位置不匹配，提前返回false</span></span><br><span class="line">     <span class="comment">// 在bit数组中位置的索引和设置时的方法一致</span></span><br><span class="line">     <span class="keyword">if</span> ((<span class="built_in">array</span>[bitpos/<span class="number">8</span>] &amp; (<span class="number">1</span> &lt;&lt; (bitpos % <span class="number">8</span>))) == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">     <span class="comment">// 更新获得下一个hash value</span></span><br><span class="line">     h += delta;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 全部匹配return true</span></span><br><span class="line">   <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="BloomFilter-应用场景"><a href="#BloomFilter-应用场景" class="headerlink" title="BloomFilter 应用场景"></a>BloomFilter 应用场景</h2><p>由于其高效的空间效率，bloomfilter 可以应用于以下场景：</p>
<ul>
<li>爬虫系统记录以经爬取过的url</li>
<li>垃圾邮件过滤</li>
<li>p2p 网络中查找资源操作: 使用一个bloomfilter 保存拥有此资源的网络通路</li>
<li>广播信息时检查某个ip是否发包</li>
<li>字典纠错：将所有单词存储到bloomfilter中，如果不存在则认为是一个错误拼写</li>
<li>CDN 代理缓存: 每个cache 服务器上使用bloomfilter 存储兄弟cache 服务器上是否有缓存关键字，如果没有则可以避免一次查找</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Bloomfilter 是一种设计巧妙的数据结构，由于其良好的空间效率，可以用于判断一个元素是否包含于海量元素集合的场景。<br>Leveldb 的实现的bloomfilter 可以灵活配置hash 函数的个数，使用一个hash 函数模拟任意多个hash 函数的场景，并将使用hash函数的个数存储到bloomfilter编码结果中。除此之外，leveldb bloomfilter 实现bit数组个数，hash函数个数以及存储元素个数的最优配置，保证最低的误差率。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://carbo06.github.io/2018/04/27/Leveldb-skiplist-实现以及解析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="carbo06@163.com">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Carbon's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/27/Leveldb-skiplist-实现以及解析/" itemprop="url">Leveldb skiplist 实现以及解析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-27T18:00:52+08:00">
                2018-04-27
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于&#58;</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2018-04-27T19:03:12+08:00">
                2018-04-27
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Backend-Development/" itemprop="url" rel="index">
                    <span itemprop="name">Backend Development</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="skiplist-原理介绍"><a href="#skiplist-原理介绍" class="headerlink" title="skiplist 原理介绍"></a>skiplist 原理介绍</h2><p>skiplist 由William Pugh 在论文<a href="http://www.cl.cam.ac.uk/teaching/0506/Algorithms/skiplists.pdf" target="_blank" rel="noopener">Skip Lists: A Probabilistic Alternative to Balanced Trees</a> 中提出的一种数据结构，skiplist 是一种随机化存储的多层线性链表结构，插入，查找，删除的都是对数级别的时间复杂度。skiplist 和平衡树有相同的时间复杂度，但相比平衡树，skip实现起来更简单。</p>
<p>下图是wikipedia 上一个一个高度为4的skiplist  </p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/8/86/Skip_list.svg" alt="avatar"><br>从垂直角度看，skiplist 的第0层以单链表的形式按照从小到大的顺序存储全部数据，越高层的链表的节点数越少，这样的特点实现了skiplist 在定位某个位置时，通过在高层较少的节点中查找就可以确定需要定位的位置处于哪个区间，从高层到低层不断缩小查找区间。以上图为例，比如我们需要在skiplist中查找2，查找过程如下，首先在最高层确定到2只可能处于1-&gt;NULL 这个区间，然后在第三层查找确定 2 只可能处于 1-&gt;4 这个区间，继续在第二层查找确定2 只可能处于1-3 这区间，最后在最底层1-&gt;3 这个区间查找可以确定2 是否存在于skiplist之中。<br>下图是wikipedia上提供的表示skiplist插入过程的一张gif,此图形象的说明了skiplist 定位以及插入节点的过程。<br><img src="https://img-blog.csdn.net/20180427150425101?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NhcmJvbjA2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="skiplist insert"><br>从水平角度来看，skiplist实现在链表开始的时候设置名为head 的哨兵节点，每一层链表的结束为止全部指向NULL。</p>
<h2 id="leveldb-实现"><a href="#leveldb-实现" class="headerlink" title="leveldb 实现"></a>leveldb 实现</h2><p>leveldb 实现的skiplist位于db/skiplist.h。</p>
<h3 id="skiplist-Node-类型定义"><a href="#skiplist-Node-类型定义" class="headerlink" title="skiplist Node 类型定义"></a>skiplist Node 类型定义</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Implementation details follow</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Key, class Comparator&gt;</span><br><span class="line">struct SkipList&lt;Key,Comparator&gt;::Node &#123;</span><br><span class="line">  <span class="keyword">explicit</span> Node(<span class="keyword">const</span> Key&amp; k) : key(k) &#123; &#125;</span><br><span class="line">  <span class="comment">// Node 存储的内容</span></span><br><span class="line">  Key <span class="keyword">const</span> key;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Accessors/mutators for links.  Wrapped in methods so we can</span></span><br><span class="line">  <span class="comment">// add the appropriate barriers as necessary.</span></span><br><span class="line">  <span class="comment">// 获取当前节点在指定level的下一个节点</span></span><br><span class="line">  Node* Next(<span class="keyword">int</span> n) &#123;</span><br><span class="line">    assert(n &gt;= <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// Use an 'acquire load' so that we observe a fully initialized</span></span><br><span class="line">    <span class="comment">// version of the returned Node.</span></span><br><span class="line">    <span class="built_in">return</span> <span class="keyword">reinterpret_cast</span>&lt;Node*&gt;(next_[n].Acquire_Load());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 将当前节点在指定level的下一个节点设置为x</span></span><br><span class="line">  <span class="keyword">void</span> SetNext(<span class="keyword">int</span> n, Node* x) &#123;</span><br><span class="line">    assert(n &gt;= <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// Use a 'release store' so that anybody who reads through this</span></span><br><span class="line">    <span class="comment">// pointer observes a fully initialized version of the inserted node.</span></span><br><span class="line">    next_[n].Release_Store(x);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 无内存屏障版本set。关于leveldb 内存屏障在新一篇博客介绍</span></span><br><span class="line">  <span class="comment">// No-barrier variants that can be safely used in a few locations.</span></span><br><span class="line">  Node* NoBarrier_Next(<span class="keyword">int</span> n) &#123;</span><br><span class="line">    assert(n &gt;= <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">return</span> <span class="keyword">reinterpret_cast</span>&lt;Node*&gt;(next_[n].NoBarrier_Load());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">void</span> NoBarrier_SetNext(<span class="keyword">int</span> n, Node* x) &#123;</span><br><span class="line">    assert(n &gt;= <span class="number">0</span>);</span><br><span class="line">    next_[n].NoBarrier_Store(x);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">// Array of length equal to the node height.  next_[0] is lowest level link.</span></span><br><span class="line">  <span class="comment">// 当前节点的下一个节点数组</span></span><br><span class="line">  port::AtomicPointer next_[<span class="number">1</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="skiplist-类成员变量"><a href="#skiplist-类成员变量" class="headerlink" title="skiplist 类成员变量"></a>skiplist 类成员变量</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">// 使用枚举类型定义skiplist 最高高度</span></span><br><span class="line">  <span class="keyword">enum</span> &#123; kMaxHeight = <span class="number">12</span> &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Immutable after construction</span></span><br><span class="line">  <span class="comment">// 用户定制的比较器</span></span><br><span class="line">  Comparator <span class="keyword">const</span> compare_;</span><br><span class="line">  <span class="comment">// leveldb 实现的简单的内存分配器</span></span><br><span class="line">  Arena* <span class="keyword">const</span> arena_;    <span class="comment">// Arena used for allocations of nodes</span></span><br><span class="line">  <span class="comment">// skiplist 的前置哨兵节点</span></span><br><span class="line">  Node* <span class="keyword">const</span> head_;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Modified only by Insert().  Read racily by readers, but stale</span></span><br><span class="line">  <span class="comment">// values are ok.</span></span><br><span class="line">  <span class="comment">// 记录当前skiplist使用的最高高度</span></span><br><span class="line">  port::AtomicPointer max_height_;   <span class="comment">// Height of the entire list</span></span><br></pre></td></tr></table></figure>
<h3 id="skiplist-插入"><a href="#skiplist-插入" class="headerlink" title="skiplist 插入"></a>skiplist 插入</h3><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename Key, class Comparator&gt;</span><br><span class="line"><span class="keyword">void</span> SkipList&lt;Key,Comparator&gt;::Insert(<span class="keyword">const</span> Key&amp; <span class="built_in">key</span>) &#123;</span><br><span class="line">  <span class="comment">// TODO(opt): We can use a barrier-free variant of FindGreaterOrEqual()</span></span><br><span class="line">  <span class="comment">// here since Insert() is externally synchronized.</span></span><br><span class="line">  <span class="comment">// 声明prev节点，代表插入位置的前一个节点</span></span><br><span class="line">  Node* prev[kMaxHeight];</span><br><span class="line">  <span class="comment">// 使用FindGreaterOrEqual函数找到第一个大于等于插入key的位置</span></span><br><span class="line">  Node* x = FindGreaterOrEqual(<span class="built_in">key</span>, prev);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Our data structure does not allow duplicate insertion</span></span><br><span class="line">  <span class="keyword">assert</span>(x == NULL || !Equal(<span class="built_in">key</span>, x-&gt;<span class="built_in">key</span>));</span><br><span class="line">  <span class="comment">// 使用随机数获取该节点的插入高度</span></span><br><span class="line">  <span class="built_in">int</span> <span class="built_in">height</span> = RandomHeight();</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">height</span> &gt; GetMaxHeight()) &#123;</span><br><span class="line">    <span class="comment">// 大于当前skiplist 最高高度的话，将多出的来的高度的prev 设置为哨兵节点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = GetMaxHeight(); i &lt; <span class="built_in">height</span>; i++) &#123;</span><br><span class="line">      prev[i] = head_;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//fprintf(stderr, "Change height from %d to %d\n", max_height_, height);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// It is ok to mutate max_height_ without any synchronization</span></span><br><span class="line">    <span class="comment">// with concurrent readers.  A concurrent reader that observes</span></span><br><span class="line">    <span class="comment">// the new value of max_height_ will see either the old value of</span></span><br><span class="line">    <span class="comment">// new level pointers from head_ (NULL), or a new value set in</span></span><br><span class="line">    <span class="comment">// the loop below.  In the former case the reader will</span></span><br><span class="line">    <span class="comment">// immediately drop to the next level since NULL sorts after all</span></span><br><span class="line">    <span class="comment">// keys.  In the latter case the reader will use the new node.</span></span><br><span class="line"><span class="comment">// 跟新max_height_    max_height_.NoBarrier_Store(reinterpret_cast&lt;void*&gt;(height));</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 创建要插入的节点对象</span></span><br><span class="line">  x = NewNode(<span class="built_in">key</span>, <span class="built_in">height</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">height</span>; i++) &#123;</span><br><span class="line">    <span class="comment">// NoBarrier_SetNext() suffices since we will add a barrier when</span></span><br><span class="line">    <span class="comment">// we publish a pointer to "x" in prev[i].</span></span><br><span class="line">    <span class="comment">// 首先将x的next 指向prev 的下一个节点</span></span><br><span class="line">    x-&gt;NoBarrier_SetNext(i, prev[i]-&gt;NoBarrier_Next(i));</span><br><span class="line">    <span class="comment">// 将prev 指向x</span></span><br><span class="line">    prev[i]-&gt;SetNext(i, x);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="skiplist-查找"><a href="#skiplist-查找" class="headerlink" title="skiplist 查找"></a>skiplist 查找</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Key, <span class="class"><span class="keyword">class</span> <span class="title">Comparator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">bool</span> <span class="title">SkipList</span>&lt;Key,Comparator&gt;:</span>:Contains(<span class="keyword">const</span> Key&amp; key) <span class="keyword">const</span> &#123;</span><br><span class="line">  <span class="comment">// 找到大于等于当前key的第一个node,然后判断node 的key</span></span><br><span class="line">  <span class="comment">// 和传入的key 是否相等</span></span><br><span class="line">  Node* x = FindGreaterOrEqual(key, <span class="literal">NULL</span>);</span><br><span class="line">  <span class="keyword">if</span> (x != <span class="literal">NULL</span> &amp;&amp; Equal(key, x-&gt;key)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="FindGreaterOrEqual"><a href="#FindGreaterOrEqual" class="headerlink" title="FindGreaterOrEqual"></a>FindGreaterOrEqual</h3><p>函数的作用是找到第一个大于或等于指定的key 的node,以及该node的前一个node<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Key, <span class="class"><span class="keyword">class</span> <span class="title">Comparator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">typename</span> <span class="title">SkipList</span>&lt;Key,Comparator&gt;:</span>:Node* SkipList&lt;Key,Comparator&gt;::FindGreaterOrEqual(<span class="keyword">const</span> Key&amp; key, Node** prev)</span><br><span class="line">    <span class="keyword">const</span> &#123;</span><br><span class="line">  Node* x = head_;</span><br><span class="line">  <span class="comment">// level 从0 开始编码</span></span><br><span class="line">  <span class="keyword">int</span> level = GetMaxHeight() - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">	<span class="comment">// 定位到当前level的下一个节点</span></span><br><span class="line">    Node* next = x-&gt;Next(level);</span><br><span class="line">    <span class="comment">// key 没有在当前区间</span></span><br><span class="line">    <span class="keyword">if</span> (KeyIsAfterNode(key, next)) &#123;</span><br><span class="line">      <span class="comment">// Keep searching in this list</span></span><br><span class="line">      x = next;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	  <span class="comment">// key 在当前区间，在低level 继续查找，</span></span><br><span class="line">	  <span class="comment">// 在查找的同时设置prev 节点</span></span><br><span class="line">      <span class="keyword">if</span> (prev != <span class="literal">NULL</span>) prev[level] = x;</span><br><span class="line">      <span class="comment">// 在最低level找到相应位置</span></span><br><span class="line">      <span class="keyword">if</span> (level == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Switch to next list</span></span><br><span class="line">        level--;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="RandomHeight"><a href="#RandomHeight" class="headerlink" title="RandomHeight"></a>RandomHeight</h3><p>利用随机数实现每次有4分之一的概率增长高度。<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Key, class Comparator&gt;</span><br><span class="line"><span class="keyword">int</span> SkipList&lt;Key,Comparator&gt;::RandomHeight() &#123;</span><br><span class="line">  <span class="comment">// Increase height with probability 1 in kBranching</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> kBranching = <span class="number">4</span>;</span><br><span class="line">  <span class="keyword">int</span> <span class="built_in">height</span> = <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">while</span> (<span class="built_in">height</span> &lt; kMaxHeight &amp;&amp; ((rnd_.Next() % kBranching) == <span class="number">0</span>)) &#123;</span><br><span class="line">    <span class="built_in">height</span>++;</span><br><span class="line">  &#125;</span><br><span class="line">  assert(<span class="built_in">height</span> &gt; <span class="number">0</span>);</span><br><span class="line">  assert(<span class="built_in">height</span> &lt;= kMaxHeight);</span><br><span class="line">  <span class="built_in">return</span> <span class="built_in">height</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="FindLessThan"><a href="#FindLessThan" class="headerlink" title="FindLessThan"></a>FindLessThan</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Key, <span class="class"><span class="keyword">class</span> <span class="title">Comparator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">typename</span> <span class="title">SkipList</span>&lt;Key,Comparator&gt;:</span>:Node*</span><br><span class="line">SkipList&lt;Key,Comparator&gt;::FindLessThan(<span class="keyword">const</span> Key&amp; key) <span class="keyword">const</span> &#123;</span><br><span class="line">  Node* x = head_;</span><br><span class="line">  <span class="keyword">int</span> level = GetMaxHeight() - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    assert(x == head_ || compare_(x-&gt;key, key) &lt; <span class="number">0</span>);</span><br><span class="line">    \<span class="comment">// 在当前level 查找</span></span><br><span class="line">    Node* next = x-&gt;Next(level);</span><br><span class="line">    <span class="comment">//  if 分支为true 的时候表示需要查找的位置在当前区间</span></span><br><span class="line">    <span class="keyword">if</span> (next == <span class="literal">NULL</span> || compare_(next-&gt;key, key) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// 在最后一层停止查找</span></span><br><span class="line">      <span class="keyword">if</span> (level == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Switch to next list</span></span><br><span class="line">        level--;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 在当前level 就找到了比key 小的节点</span></span><br><span class="line">      x = next;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>skiplist最底层单链表有序存储全部元素，利用多层有序链表的结构实现加速索引的功能，处于越高level 节点的链表越稀疏查找速度越快，在不断向下查找的过程中不断缩小查找空间。<br>总的来说，skiplist 是一种设计巧妙的数据结构，leveldb 的实现可读性高，容易理解。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://carbo06.github.io/2018/04/26/C-拼接长字符串/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="carbo06@163.com">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Carbon's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/26/C-拼接长字符串/" itemprop="url">C++ 拼接长字符串</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-26T17:25:11+08:00">
                2018-04-26
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于&#58;</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2018-04-28T16:03:48+08:00">
                2018-04-28
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Backend-Development/" itemprop="url" rel="index">
                    <span itemprop="name">Backend Development</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="C-拼接长字符串"><a href="#C-拼接长字符串" class="headerlink" title="C++ 拼接长字符串"></a>C++ 拼接长字符串</h1><p>c++ string 类型提供 <strong>opearator+=</strong> 以及 <strong>append</strong> 方法进行字符串拼接，本文探讨c++拼接长字符串执行效率最高的方法。以下是四种实现方式。</p>
<h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><h3 id="operator"><a href="#operator" class="headerlink" title="operator +="></a>operator +=</h3><p>使用 string 类提供重载 += 方法拼接字符串。示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// length 参数代表拼接的字符串长度</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">composeLongstringWithOperator</span><span class="params">(<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> length,<span class="built_in">std</span>::<span class="built_in">string</span>&amp; long_string)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; length / <span class="number">9</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">char</span> str[<span class="number">10</span>];</span><br><span class="line">        <span class="comment">// randStr 方法构造长度为9的随机字符串</span></span><br><span class="line">        long_string += (randStr(str,<span class="number">9</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="append"><a href="#append" class="headerlink" title="append"></a>append</h3><p>使用 string 类提供的append 方法拼接字符串。示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">composeLongstringWithAppend</span><span class="params">(<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> length,<span class="built_in">std</span>::<span class="built_in">string</span>&amp; long_string)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; length / <span class="number">9</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">char</span> str[<span class="number">10</span>];</span><br><span class="line">        long_string.append(randStr(str,<span class="number">9</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="reserve-amp-amp-operator"><a href="#reserve-amp-amp-operator" class="headerlink" title="reserve &amp;&amp; operator +="></a>reserve &amp;&amp; operator +=</h3><p>在拼接字符串之前为string 对象提前分配空间，然后使用 += 方法进行拼接，示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">composeLongstringWithReserveAndOperator</span><span class="params">(<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> length,<span class="built_in">std</span>::<span class="built_in">string</span>&amp; long_string)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    long_string.reserve(length);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; length / <span class="number">9</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">char</span> str[<span class="number">10</span>];</span><br><span class="line">        long_string += (randStr(str,<span class="number">9</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="reserve-amp-amp-append"><a href="#reserve-amp-amp-append" class="headerlink" title="reserve &amp;&amp; append"></a>reserve &amp;&amp; append</h3><p>在拼接字符串之前为string 对象提前分配空间，然后使用 append 方法进行拼接，示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">composeLongstringWithAppend</span><span class="params">(<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> length,<span class="built_in">std</span>::<span class="built_in">string</span>&amp; long_string)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; length / <span class="number">9</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">char</span> str[<span class="number">10</span>];</span><br><span class="line">        long_string.append(randStr(str,<span class="number">9</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="性能测试"><a href="#性能测试" class="headerlink" title="性能测试"></a>性能测试</h2><h3 id="测试方法"><a href="#测试方法" class="headerlink" title="测试方法"></a>测试方法</h3><p>进行10000次长字符串拼接，统计每种方式下耗时，示例代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">randStr</span><span class="params">(<span class="keyword">char</span>* str,<span class="keyword">const</span> <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; len; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        str[i] = <span class="string">'A'</span> + rand() % <span class="number">26</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    str[++i] = <span class="string">'\0'</span>;</span><br><span class="line">    <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    (<span class="keyword">void</span>) argc;</span><br><span class="line">    <span class="comment">// 第一个参数代表生成的字符串的长度</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> length = atoi(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="comment">// 第二个参数代表使用哪种方法进行拼接</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> type = atoi(argv[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">    srand(time(<span class="literal">NULL</span>));</span><br><span class="line">    <span class="keyword">auto</span> start = <span class="built_in">std</span>::chrono::high_resolution_clock::now();</span><br><span class="line">    <span class="keyword">switch</span>(type)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"composeLongstringWithReserveAndAppend"</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">std</span>::<span class="built_in">string</span> long_string;</span><br><span class="line">                composeLongstringWithReserveAndAppend(length,long_string);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"composeLongstringWithReserveAndOperator"</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">std</span>::<span class="built_in">string</span> long_string;</span><br><span class="line">                composeLongstringWithReserveAndOperator(length,long_string);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"composeLongstringWithAppend"</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">std</span>::<span class="built_in">string</span> long_string;</span><br><span class="line">                composeLongstringWithAppend(length,long_string);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"composeLongstringWithOperator"</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">std</span>::<span class="built_in">string</span> long_string;</span><br><span class="line">                composeLongstringWithOperator(length,long_string);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">auto</span> end = <span class="built_in">std</span>::chrono::high_resolution_clock::now();</span><br><span class="line">    <span class="built_in">std</span>::chrono::duration&lt;<span class="keyword">double</span>&gt; diff = end - start;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">" cost "</span> &lt;&lt; <span class="number">1000</span> * diff.count() &lt;&lt; <span class="string">" ms\n"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译<br><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">g</span><span class="literal">+</span><span class="literal">+</span> <span class="literal">-</span><span class="comment">std=c</span><span class="literal">+</span><span class="literal">+</span><span class="comment">11</span> <span class="literal">-</span><span class="comment">O3</span> <span class="comment">compose_long_string</span><span class="string">.</span><span class="comment">cpp</span> <span class="literal">-</span><span class="comment">o</span> <span class="comment">compose_long_string</span></span><br></pre></td></tr></table></figure></p>
<h3 id="性能表现"><a href="#性能表现" class="headerlink" title="性能表现"></a>性能表现</h3><p>长字符串长度为1000000，每种方法进行10000次拼接，四种方法的耗时如下：  </p>
<table>
<thead>
<tr>
<th>method</th>
<th>cost (ms)</th>
</tr>
</thead>
<tbody>
<tr>
<td>reserve &amp;&amp; append</td>
<td>117304</td>
</tr>
<tr>
<td>reserve &amp;&amp; operator</td>
<td>122998</td>
</tr>
<tr>
<td>append</td>
<td>125682</td>
</tr>
<tr>
<td>operator</td>
<td>129071</td>
</tr>
</tbody>
</table>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><ol>
<li>针对较短字符串，使用<strong>reserve</strong>提前分配空间对性能提升意义不大，当字符串的长度很长是，使用<strong>reserve</strong>方法提前分配空间可以带来比较大的性能提升。</li>
<li><strong>operator+=</strong> 和 <strong>append</strong> 方法在进行字符串拼接时性能表现几乎一致。原因是stl 实现的<strong>operator+=</strong> 方式实际是直接调用了<strong>append</strong> 方法。</li>
<li>综上，拼接长字符串时最优方式是 <strong>reserve</strong> &amp;&amp; <strong>append</strong>。</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://carbo06.github.io/2018/04/19/读书短评/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="carbo06@163.com">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Carbon's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/19/读书短评/" itemprop="url">读书短评</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-19T10:59:28+08:00">
                2018-04-19
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于&#58;</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2018-07-06T11:03:18+08:00">
                2018-07-06
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Reading/" itemprop="url" rel="index">
                    <span itemprop="name">Reading</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="2018-04-19"><a href="#2018-04-19" class="headerlink" title="2018-04-19"></a>2018-04-19</h1><h2 id="《人类简史》"><a href="#《人类简史》" class="headerlink" title="《人类简史》"></a>《人类简史》</h2><p>现代社会建立在人类的重重假设，回到非洲大草原摘个野果子吃就很快乐~<br>从物种繁衍的角度来看，小麦，家畜是比人要更成功的。但是物种繁衍的成功不等同于个体的快乐。有人可能会说小麦，家畜的一生都很短暂，但相对浩瀚宇宙来说，人的一生也是沧海一粟。都是匆匆过客，如果能更多卸下捆绑获得真正的快乐才是生活的真谛。</p>
<h2 id="《活着》"><a href="#《活着》" class="headerlink" title="《活着》"></a>《活着》</h2><p>所有的困难都会过去，活着本身就是最大的意义。</p>
<h2 id="《围城》"><a href="#《围城》" class="headerlink" title="《围城》"></a>《围城》</h2><p>很多现象都可以用围城思想来解释，里面的人想出去，外边的人想进去</p>
<h2 id="《明朝那些事》"><a href="#《明朝那些事》" class="headerlink" title="《明朝那些事》"></a>《明朝那些事》</h2><p>除了朱元璋打天下，朱棣篡位，剩下大部分篇幅都在讲官场政治，当年明月本是公务员，写官场政治这些也非常熟悉，所以后面那几本叫《明朝官场那些事》可能更合适。</p>
<h2 id="《解忧杂货店》"><a href="#《解忧杂货店》" class="headerlink" title="《解忧杂货店》"></a>《解忧杂货店》</h2><p>高产如东野，可能写悬疑探案类更费精力，所以来碗鸡汤喂喂。书中所有故事都说明了影射一个道理，向别人寻求建议的时候，自己心理已经有答案，只不过是希望别人加强一下自己的信念，如果建议和自己想的相反，你会找别的人再给你建议~</p>
<h2 id="《白鹿原》"><a href="#《白鹿原》" class="headerlink" title="《白鹿原》"></a>《白鹿原》</h2><p>具有西北特色的低配百年孤独。读的过程中可以感受到西北作家的朴实的文风，稍微结合一点贵party的black历史就可以如此精彩！另外，读的过程中经常想吃羊肉泡馍~</p>
<h2 id="《苏东坡传》"><a href="#《苏东坡传》" class="headerlink" title="《苏东坡传》"></a>《苏东坡传》</h2><p>上学课本上说的伟大的文学家，书画家。而借用林语堂在前言中对苏东坡的描述: “苏东坡是一个无可救药的乐天派、一个伟大的人道主义者、一个百姓的朋友、一个大文豪、大书法家、创新的画家、造酒试验家、一个工程师、一个憎恨清教徒主义的人、一位瑜伽修行者佛教徒、巨儒政治家、一个皇帝的秘书、酒仙、厚道的法官、一位在政治上专唱反调的人。一个月夜徘徊者、一个诗人、一个小丑”,相比之下自己的生活单调了好多，所以应该在自己身上点更多天赋。不写了，中午吃东坡肉。</p>
<h1 id="2018-04-20"><a href="#2018-04-20" class="headerlink" title="2018-04-20"></a>2018-04-20</h1><h2 id="《天龙八部》"><a href="#《天龙八部》" class="headerlink" title="《天龙八部》"></a>《天龙八部》</h2><p>乔峰，段誉，虚竹，慕容复所有主要角色无不苦难。众生皆苦，无欲则刚，修炼成佛的还是没几个。</p>
<h2 id="《百年孤独》"><a href="#《百年孤独》" class="headerlink" title="《百年孤独》"></a>《百年孤独》</h2><p>人生来孤独，所以需要把雕刻好小金鱼后融掉重新再雕，需要吃土排解孤独。随便拉出个人来，对他说“我想你才是真正的孤独吧！”他都会感到你是他的知音~</p>
<h2 id="《追风筝的人》"><a href="#《追风筝的人》" class="headerlink" title="《追风筝的人》"></a>《追风筝的人》</h2><p>“为你，千千万万遍” 对主人的忠诚和对友谊的坚持要有多深才能说出这样的话。</p>
<h2 id="《鹿鼎记》"><a href="#《鹿鼎记》" class="headerlink" title="《鹿鼎记》"></a>《鹿鼎记》</h2><p>“老子不干了” 在康熙皇帝和天地会之间脚踏两条船太累了！在这两个没法做决定的选择面前，干脆不选了，全都qtmd！</p>
<h2 id="《黄金时代》"><a href="#《黄金时代》" class="headerlink" title="《黄金时代》"></a>《黄金时代》</h2><p>在混乱的年代，黄金时代年纪，有个人一起实践伟大革命友谊也很幸福吧！</p>
<h1 id="2018-04-25"><a href="#2018-04-25" class="headerlink" title="2018-04-25"></a>2018-04-25</h1><h2 id="《万寿寺》"><a href="#《万寿寺》" class="headerlink" title="《万寿寺》"></a>《万寿寺》</h2><p>万寿寺的主要作用之一是为了老佛爷乘船去颐和园游玩的途中休息一下。之所以老佛爷成为了老佛爷是因为咸丰帝从她身上爬起来时那条射过精的疲软的jb,王小波称之为历史的脐带(hahaha)。所以他在万寿寺搞一些历史的脐带考，领导很不喜欢！</p>
<h2 id="《了不起的盖茨比》"><a href="#《了不起的盖茨比》" class="headerlink" title="《了不起的盖茨比》"></a>《了不起的盖茨比》</h2><p>对黛西的爱情是盖茨比先生的一道绿光，绿光指引他前行，我猜在他临死之前，绿光也不曾熄灭。</p>
<h2 id="《指数基金投资指南》"><a href="#《指数基金投资指南》" class="headerlink" title="《指数基金投资指南》"></a>《指数基金投资指南》</h2><p>钉大的扫盲科普书籍，1 h 看完，后面继续有选择的抄E大和钉大的作业。</p>
<h1 id="2018-05-02"><a href="#2018-05-02" class="headerlink" title="2018-05-02"></a>2018-05-02</h1><h2 id="《笑傲江湖》"><a href="#《笑傲江湖》" class="headerlink" title="《笑傲江湖》"></a>《笑傲江湖》</h2><p>金庸武侠里面政治色彩很重的一本，前面甚嚣尘土的左盟主还是被岳君子阴了。伪君子比真小人更可怕。</p>
<h2 id="《神雕侠侣》"><a href="#《神雕侠侣》" class="headerlink" title="《神雕侠侣》"></a>《神雕侠侣》</h2><p>侠之大者为国为民，杨过在最后领悟此道理，也解开了杀父之仇的心结。在经过无数挫折之后终于和小龙女走到一起，只是苦了那些“一见杨过误终身”的少女们~</p>
<h1 id="2018-05-03"><a href="#2018-05-03" class="headerlink" title="2018-05-03"></a>2018-05-03</h1><h2 id="《月亮与六便士》"><a href="#《月亮与六便士》" class="headerlink" title="《月亮与六便士》"></a>《月亮与六便士》</h2><p>“忘了是谁说过，为了让灵魂受益，每天应该做两件自己不喜欢的事情，说着这句话的是一个富有智慧的人，我把这句格言谨记在新，遵照行事，因此每天我醒来起床，每晚上床睡下” 毛姆这句话描述的境界是生活中所做的任何事都是自己发自肺腑开心的事，这比诗和远方的境界高多了。我承认自己不可能达到那种境界，只希望自己在低头捞便士的同时不要忘了抬头看一下明亮的月亮。</p>
<h2 id="《1984》"><a href="#《1984》" class="headerlink" title="《1984》"></a>《1984》</h2><p>“Big brother is watching you.”,原本影射苏联的一书放在今日天朝也并无太多违和。修宪之后，海康威视大涨就让我想到1984中的场景，依据相同的逻辑，中证传媒一定不会有大发展，军工企业虽然垃圾，但会有很大机会。不知道这书啥时候成为禁书。</p>
<h2 id="《寻找无双》"><a href="#《寻找无双》" class="headerlink" title="《寻找无双》"></a>《寻找无双》</h2><p>王仙客在寻找无双的过程中困难重重，我们追寻的理想也同样如此吧，不过无所谓，重要的反而是追寻理想的过程吧！</p>
<h2 id="《革命时期的爱情》"><a href="#《革命时期的爱情》" class="headerlink" title="《革命时期的爱情》"></a>《革命时期的爱情》</h2><p>所有混乱的事情，如果是放在革命时期也就显得不那么难以解释。X海鹰作为先进青年在挽救堕落青年的王二的时候怎么可以动歪心思！</p>
<h2 id="《爱你就像爱生命》"><a href="#《爱你就像爱生命》" class="headerlink" title="《爱你就像爱生命》"></a>《爱你就像爱生命》</h2><p>王小波李银河书信整理合集。李银河在书中表示说自己是回应了王小波热烈的感情，同时对他的爱也变得炽烈。最喜欢里面的两句活，“一想起你我这张丑脸上就泛起笑容”，“你好哇，李银河”。</p>
<h1 id="2018-05-08"><a href="#2018-05-08" class="headerlink" title="2018-05-08"></a>2018-05-08</h1><h2 id="《蒋介石与现代中国》"><a href="#《蒋介石与现代中国》" class="headerlink" title="《蒋介石与现代中国》"></a>《蒋介石与现代中国》</h2><p>讲述了委员长上位，完成中国形式上统一，抗日战争，国共内战，退守台湾五个阶段的大事。感受到那个动荡的时代波兰壮阔的历史，比历史课本中看到人物丰富立体。书中对抗日初期我党对抗日的态度，委员长对美玲的追求，退守台湾后两位大佬心照不宣共同薅美苏羊毛给我留下很深印象。最后留下在青岛花石楼里偶然看到的委员长一张诡异的微笑图。<img src="https://myblog-1256683296.cos.ap-beijing.myqcloud.com/WechatIMG28.jpeg" alt=""></p>
<h2 id="《天才在左，疯子在右》"><a href="#《天才在左，疯子在右》" class="headerlink" title="《天才在左，疯子在右》"></a>《天才在左，疯子在右》</h2><p>初读之后非常震撼，每个人的精神世界都是非常奇妙，即使是本人无法完全洞悉自己的全部想法。所谓精神病的概念，更多的是说那帮人的想法和社会主流价值观所要求的不一致。心理学是如此奇妙。</p>
<h2 id="《三体》"><a href="#《三体》" class="headerlink" title="《三体》"></a>《三体》</h2><p>印象最深的是第二部中黑暗丛林法则，这个原则放到现在的社会也不无道理。看书过程中不断为作者磅礴而又严谨的想象所感叹，科幻的同时还可以看到作者对人性的思考，很赞。</p>
<h1 id="2018-05-15"><a href="#2018-05-15" class="headerlink" title="2018-05-15"></a>2018-05-15</h1><h2 id="《霍乱时期的爱情》"><a href="#《霍乱时期的爱情》" class="headerlink" title="《霍乱时期的爱情》"></a>《霍乱时期的爱情》</h2><p>男主一生的主题就是对女主爱情的追求，在认识女主之后男主做的所有事情都是以赢得爱情为目标，和神雕侠侣里一见杨过毁终生的少女有些相似的感觉。书中描写了各种种类的爱情，读的同时还是感觉到和百年孤独类似的荒芜感，不同的是从这本书里还读到老爷子幽默的地方(比如女主从无限讨厌茄子，到无限热爱茄子，哈哈)。<br>看到豆瓣里很有意思的一个书评，“屌丝战胜高帅富的方法就是活得比高帅富久，所以屌丝们赶紧锻炼身体去吧”</p>
<h1 id="2018-05-22"><a href="#2018-05-22" class="headerlink" title="2018-05-22"></a>2018-05-22</h1><h2 id="《谁在世界中心》"><a href="#《谁在世界中心》" class="headerlink" title="《谁在世界中心》"></a>《谁在世界中心》</h2><p>书中一直在强调地缘政治的重要性，大部分篇幅都在讲现在是海权时代，海洋强国才是真的强国。感到新奇的一点是如果继续全球变暖，北冰洋加速融化，俄罗斯会成为另外一个海洋大国，地缘优势会大大增加，那时候老毛子会更跳~</p>
<h2 id="《精进》"><a href="#《精进》" class="headerlink" title="《精进》"></a>《精进》</h2><p>作为非常讨厌鸡汤以及成功学的我，在采铜的这本书中看到了超多的干货，里面很多思想和刘未鹏博客中的观点不谋而合。总之就是信息量超大的一本书。最近逛知乎看到采铜已经离开知乎了，这也并不奇怪，知乎现在已经是段子手和装逼犯集中的地方了，没那么多大佬了。</p>
<h1 id="2018-05-25"><a href="#2018-05-25" class="headerlink" title="2018-05-25"></a>2018-05-25</h1><h2 id="《送你一颗子弹》"><a href="#《送你一颗子弹》" class="headerlink" title="《送你一颗子弹》"></a>《送你一颗子弹》</h2><p>刘瑜老师才是真正文艺女青年，整本书大部分是刘瑜老师在06-08年的生活见闻，其中充满了对生活，爱情，政治，自由的思考，文笔朴实犀利又不乏幽默，很赞。相比起来，生活中大部分自诩文艺的女青年还是差距太大了，建议她们多读读马克思，少看些张小娴吧。</p>
<h1 id="2018-06-01"><a href="#2018-06-01" class="headerlink" title="2018-06-01"></a>2018-06-01</h1><h2 id="《撒哈拉的故事》"><a href="#《撒哈拉的故事》" class="headerlink" title="《撒哈拉的故事》"></a>《撒哈拉的故事》</h2><p>上高中还是本科的时候看过一遍。感觉到三毛作为一个文艺女青年也是够燥够任性，好好的在西班牙享受现代资本主义的灯红酒绿突然要跑到撒哈拉沙漠去。到撒哈拉之后自力更生经营自己的生活，见识了好多的奇奇怪怪的习俗同时又冒了好多险。总的来说，再次读的过程中不断感受到这位文艺女青年强大的气场。</p>
<h1 id="2018-07-06"><a href="#2018-07-06" class="headerlink" title="2018-07-06"></a>2018-07-06</h1><h2 id="《小王子》"><a href="#《小王子》" class="headerlink" title="《小王子》"></a>《小王子》</h2><p>小王子在各个星球旅行，遇到形形色色各式各样不能理解的大人。这对应到现实生活中也正是如此，我们做的大部分事情可能都是没啥实际意义或者说已经脱离原本的想法，拥有孩子的天真以及直接了当实在难能可贵。</p>
<h2 id="《未来简史》"><a href="#《未来简史》" class="headerlink" title="《未来简史》"></a>《未来简史》</h2><p><span id="inline-yellow"> 待续 </span></p>
<h2 id="《盗墓笔记》"><a href="#《盗墓笔记》" class="headerlink" title="《盗墓笔记》"></a>《盗墓笔记》</h2><p><span id="inline-yellow"> 待续 </span></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://carbo06.github.io/2018/04/17/Leveldb-varint-解析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="carbo06@163.com">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Carbon's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/17/Leveldb-varint-解析/" itemprop="url">Leveldb varint 解析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-17T20:00:46+08:00">
                2018-04-17
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于&#58;</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2018-04-17T20:04:12+08:00">
                2018-04-17
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Backend-Development/" itemprop="url" rel="index">
                    <span itemprop="name">Backend Development</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="varint-介绍"><a href="#varint-介绍" class="headerlink" title="varint 介绍"></a>varint 介绍</h1><p>我们知道 uint32_t 类型占用4个byte，uint64_t 占用8个byte, 但是对于比较小的数字来说，使用uint32_t 或者uint64_t 存储会比较浪费，varint 的思想是根据数字所需大小使用unsigned char* 指针存储数据，节约内存。</p>
<h1 id="leveldb-实现"><a href="#leveldb-实现" class="headerlink" title="leveldb 实现"></a>leveldb 实现</h1><p>leveldb 中的varint实现原理简单，每个byte 使用最高bit的 0/1值代表此整数值是否结束，用剩下的7个bit 存储实际的数值。知道最后一个byte 的最高bit 是0 表示整数结束。因此小于128的数据都可以用一个byte 来表示，大于128的，比如说300，使用varint 编码的话需要两个字节<strong>10101100 0000 0010</strong></p>
<h2 id="leveldb-32位int变长编码实现"><a href="#leveldb-32位int变长编码实现" class="headerlink" title="leveldb 32位int变长编码实现"></a>leveldb 32位int变长编码实现</h2><p>正常情况下，32位int占用4个byte, varint 编码中每个byte 中的最高bit 用来表示该byte 是不是最后一个byte,所以针对大的数varint 编码可能需要5个byte才能表示。leveldb 实现中5个if 分支对应varint占用1到5个byte 的情况。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">EncodeVarint32</span><span class="params">(<span class="keyword">char</span>* dst, <span class="keyword">uint32_t</span> v)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Operate on characters as unsigneds</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">char</span>* ptr = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">char</span>*&gt;(dst);</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> B = <span class="number">128</span>;</span><br><span class="line">  <span class="keyword">if</span> (v &lt; (<span class="number">1</span>&lt;&lt;<span class="number">7</span>)) &#123;</span><br><span class="line">    *(ptr++) = v;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v &lt; (<span class="number">1</span>&lt;&lt;<span class="number">14</span>)) &#123;</span><br><span class="line">    *(ptr++) = v | B;</span><br><span class="line">    *(ptr++) = v&gt;&gt;<span class="number">7</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v &lt; (<span class="number">1</span>&lt;&lt;<span class="number">21</span>)) &#123;</span><br><span class="line">    *(ptr++) = v | B;</span><br><span class="line">    *(ptr++) = (v&gt;&gt;<span class="number">7</span>) | B;</span><br><span class="line">    *(ptr++) = v&gt;&gt;<span class="number">14</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v &lt; (<span class="number">1</span>&lt;&lt;<span class="number">28</span>)) &#123;</span><br><span class="line">    *(ptr++) = v | B;</span><br><span class="line">    *(ptr++) = (v&gt;&gt;<span class="number">7</span>) | B;</span><br><span class="line">    *(ptr++) = (v&gt;&gt;<span class="number">14</span>) | B;</span><br><span class="line">    *(ptr++) = v&gt;&gt;<span class="number">21</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    *(ptr++) = v | B;</span><br><span class="line">    *(ptr++) = (v&gt;&gt;<span class="number">7</span>) | B;</span><br><span class="line">    *(ptr++) = (v&gt;&gt;<span class="number">14</span>) | B;</span><br><span class="line">    *(ptr++) = (v&gt;&gt;<span class="number">21</span>) | B;</span><br><span class="line">    *(ptr++) = v&gt;&gt;<span class="number">28</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">char</span>*&gt;(ptr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>对应的varint 解码的思路是从低byte 到高byte遍历，直到找到最后一个表示编码结束的byte(判断条件是 <strong>byte &amp; 128 == 1</strong>)，代码如下<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 针对一个byte情况直接处理，大于一个byte 时，</span></span><br><span class="line"><span class="comment">// 使用 GetVarint32PtrFallback 处理</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">GetVarint32Ptr</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* p,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  <span class="keyword">const</span> <span class="keyword">char</span>* limit,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  <span class="keyword">uint32_t</span>* value)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (p &lt; limit) &#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> result = *(<span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span>*&gt;(p));</span><br><span class="line">    <span class="keyword">if</span> ((result &amp; <span class="number">128</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">      *value = result;</span><br><span class="line">      <span class="keyword">return</span> p + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> GetVarint32PtrFallback(p, limit, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">GetVarint32PtrFallback</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* p,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   <span class="keyword">const</span> <span class="keyword">char</span>* limit,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   <span class="keyword">uint32_t</span>* value)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">uint32_t</span> result = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">uint32_t</span> shift = <span class="number">0</span>; shift &lt;= <span class="number">28</span> &amp;&amp; p &lt; limit; shift += <span class="number">7</span>) &#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> byte = *(<span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span>*&gt;(p));</span><br><span class="line">    p++;</span><br><span class="line">    <span class="keyword">if</span> (byte &amp; <span class="number">128</span>) &#123;</span><br><span class="line">      <span class="comment">// More bytes are present</span></span><br><span class="line">      result |= ((byte &amp; <span class="number">127</span>) &lt;&lt; shift);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      result |= (byte &lt;&lt; shift);</span><br><span class="line">      *value = result;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">char</span>*&gt;(p);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="64位变长编码的实现"><a href="#64位变长编码的实现" class="headerlink" title="64位变长编码的实现"></a>64位变长编码的实现</h2><p>64位整形最多需要<strong>(10 * 8 - 10 &gt; 64)</strong> 10个byte 来保存，类似于32位int的编码，需要写10个if-else 分支，针对64位整形的编码，leveldb 给出了更优雅的解决方案。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">EncodeVarint64</span><span class="params">(<span class="keyword">char</span>* dst, <span class="keyword">uint64_t</span> v)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> B = <span class="number">128</span>;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">char</span>* ptr = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">char</span>*&gt;(dst);</span><br><span class="line">  <span class="keyword">while</span> (v &gt;= B) &#123;</span><br><span class="line">    *(ptr++) = (v &amp; (B<span class="number">-1</span>)) | B;</span><br><span class="line">    v &gt;&gt;= <span class="number">7</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  *(ptr++) = <span class="keyword">static_cast</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">char</span>&gt;(v);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">char</span>*&gt;(ptr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p> 针对64位整形的解码，leveldb 实现同样是类似的逻辑。也是从低位byte 开始向高位byte遍历判断编码是否结束。代码实现如下<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">GetVarint64Ptr</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* p, <span class="keyword">const</span> <span class="keyword">char</span>* limit, <span class="keyword">uint64_t</span>* value)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">uint64_t</span> result = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">uint32_t</span> shift = <span class="number">0</span>; shift &lt;= <span class="number">63</span> &amp;&amp; p &lt; limit; shift += <span class="number">7</span>) &#123;</span><br><span class="line">    <span class="keyword">uint64_t</span> byte = *(<span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span>*&gt;(p));</span><br><span class="line">    p++;</span><br><span class="line">    <span class="keyword">if</span> (byte &amp; <span class="number">128</span>) &#123;</span><br><span class="line">      <span class="comment">// More bytes are present</span></span><br><span class="line">      result |= ((byte &amp; <span class="number">127</span>) &lt;&lt; shift);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      result |= (byte &lt;&lt; shift);</span><br><span class="line">      *value = result;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">char</span>*&gt;(p);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>varint 的思想是针对32位或者64位整形类型来说存储的大部分数据都是多余的，因此使用每个byte的最高位来标识编码是否结束，使用一个<strong>char</strong> 型指针存储编码的结果，针对很多情况可以节约存储空间。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://carbo06.github.io/2018/04/11/Memcached-hashtable解析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="carbo06@163.com">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Carbon's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/11/Memcached-hashtable解析/" itemprop="url">Memcached hashtable解析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-11T12:45:44+08:00">
                2018-04-11
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于&#58;</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2018-04-11T17:10:26+08:00">
                2018-04-11
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Backend-Development/" itemprop="url" rel="index">
                    <span itemprop="name">Backend Development</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>Memcached中实现了高性能的hashtable。其解决hash冲突的方法采用拉链法。当hashtable 中存储的item个数大于容器大小的1.5倍的时候通知线程进行hashtable 扩容，为了保证在扩容期间的读写性能，扩容线程默认每次只迁移一个bucket。设置一个变量标识当前的迁移进度，在进行读写操作时根据此变量确定是去 <strong>old_hashtable</strong> 还是 <strong>primary_hashtable</strong> 进行操作。</p>
<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><h2 id="主要接口"><a href="#主要接口" class="headerlink" title="主要接口"></a>主要接口</h2><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*数组的大小都是2指数次幂，这样的好处是可以将 index % hashsize </span></span><br><span class="line"><span class="comment">变为 index &amp; hashmask*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> hashsize(n) ((ub4)1&lt;&lt;(n))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> hashmask(n) (hashsize(n)-1)</span></span><br><span class="line"><span class="comment">// 初始化函数的作用是为主表分配空间</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">assoc_init</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> hashtable_init)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (hashtable_init) &#123;</span><br><span class="line">        hashpower = hashtable_init;</span><br><span class="line">    &#125;</span><br><span class="line">    primary_hashtable = <span class="built_in">calloc</span>(hashsize(hashpower), <span class="keyword">sizeof</span>(<span class="keyword">void</span> *));</span><br><span class="line">    <span class="keyword">if</span> (! primary_hashtable) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Failed to init hashtable.\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    STATS_LOCK();</span><br><span class="line">    stats_state.hash_power_level = hashpower;</span><br><span class="line">    stats_state.hash_bytes = hashsize(hashpower) * <span class="keyword">sizeof</span>(<span class="keyword">void</span> *);</span><br><span class="line">    STATS_UNLOCK();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><p>hash 查找的逻辑是优先使用hash 预算定位到bucket,然后循环bucket 链表找到指定的key。需要理解的地方在于查找时可能存在hashtable 正在进行扩展，所以需要确定是在<strong>old_hashtable</strong>还是 <strong>primary_hashtable</strong> 进行查找。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">item *<span class="title">assoc_find</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *key, <span class="keyword">const</span> <span class="keyword">size_t</span> nkey, <span class="keyword">const</span> <span class="keyword">uint32_t</span> hv)</span> </span>&#123;</span><br><span class="line">    item *it;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> oldbucket;</span><br><span class="line">    <span class="comment">/* expanding 标识扩展是否完成。</span></span><br><span class="line"><span class="comment">    expand_bucket表示当前扩展的进度，使用位与操作查找bucket位置 */</span></span><br><span class="line">    <span class="keyword">if</span> (expanding &amp;&amp;</span><br><span class="line">        (oldbucket = (hv &amp; hashmask(hashpower - <span class="number">1</span>))) &gt;= expand_bucket)</span><br><span class="line">    &#123;</span><br><span class="line">        it = old_hashtable[oldbucket];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        it = primary_hashtable[hv &amp; hashmask(hashpower)];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    item *ret = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> depth = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 循环单链表查找指定key</span></span><br><span class="line">    <span class="keyword">while</span> (it) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((nkey == it-&gt;nkey) &amp;&amp; (<span class="built_in">memcmp</span>(key, ITEM_key(it), nkey) == <span class="number">0</span>)) &#123;</span><br><span class="line">            ret = it;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        it = it-&gt;h_next;</span><br><span class="line">        ++depth;</span><br><span class="line">    &#125;</span><br><span class="line">    MEMCACHED_ASSOC_FIND(key, nkey, depth);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><p>插入的主要逻辑是找到指定桶的位置，将当前插入的节点设置为桶中位置的链表头结点位置，并且重新设置桶中元素的value<br><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">int</span> assoc_insert(<span class="keyword">item </span>*<span class="keyword">it, </span>const uint32_t hv) &#123;</span><br><span class="line">    unsigned int oldbucket<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">//  <span class="meta">assert</span>(assoc_find(<span class="keyword">ITEM_key(it), </span><span class="keyword">it-&gt;nkey) </span>== <span class="number">0</span>)<span class="comment">;  /* shouldn't have duplicately named things defined */</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">if</span> (expanding &amp;&amp;</span><br><span class="line">        (oldbucket = (hv &amp; hashmask(hashpower - <span class="number">1</span>))) &gt;= expand_bucket)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">it-&gt;h_next </span>= old_hashtable[oldbucket]<span class="comment">;</span></span><br><span class="line">        old_hashtable[oldbucket] = <span class="keyword">it;</span></span><br><span class="line"><span class="keyword"> </span>   &#125; <span class="meta">else</span> &#123;</span><br><span class="line">        <span class="keyword">it-&gt;h_next </span>= primary_hashtable[hv &amp; hashmask(hashpower)]<span class="comment">;</span></span><br><span class="line">        primary_hashtable[hv &amp; hashmask(hashpower)] = <span class="keyword">it;</span></span><br><span class="line"><span class="keyword"> </span>   &#125;</span><br><span class="line"></span><br><span class="line">    MEMCACHED_ASSOC_INSERT(<span class="keyword">ITEM_key(it), </span><span class="keyword">it-&gt;nkey);</span></span><br><span class="line"><span class="keyword"> </span>   return <span class="number">1</span><span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>删除接口的主要逻辑是使用<strong>_hashitem_before</strong> 函数找到要删除item前一个item指针位置，然后将此指针的位置直接指向被删除item 的下一个item 位置<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">assoc_delete</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *key, <span class="keyword">const</span> size_t nkey, <span class="keyword">const</span> uint32_t hv)</span> </span>&#123;</span><br><span class="line">    item **<span class="keyword">before</span> = <span class="title">_hashitem_before</span>(key, nkey, hv);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (*<span class="keyword">before</span>) &#123;</span><br><span class="line">        item *nxt;</span><br><span class="line">        <span class="comment">/* The DTrace probe cannot be triggered as the last instruction</span></span><br><span class="line"><span class="comment">         * due to possible tail-optimization by the compiler</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        MEMCACHED_ASSOC_DELETE(key, nkey);</span><br><span class="line">        nxt = (*<span class="keyword">before</span>)-&gt;h_next;</span><br><span class="line">        (*<span class="keyword">before</span>)-&gt;h_next = <span class="number">0</span>;   <span class="comment">/* probably pointless, but whatever. */</span></span><br><span class="line">        *<span class="keyword">before</span> = nxt;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    /* Note:  we never actually get here.  the callers don't delete things</span><br><span class="line">       they can't find. */</span><br><span class="line">    <span class="title">assert</span>(*<span class="keyword">before</span> != 0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="其他辅助函数"><a href="#其他辅助函数" class="headerlink" title="其他辅助函数"></a>其他辅助函数</h2><h3 id="hashitem-before"><a href="#hashitem-before" class="headerlink" title="_hashitem_before"></a>_hashitem_before</h3><p>函数的作用是查找给定item的前一个节点的指针，在delete 接口中调用<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> item** _hashitem_before (<span class="keyword">const</span> <span class="keyword">char</span> *key, <span class="keyword">const</span> <span class="keyword">size_t</span> nkey, <span class="keyword">const</span> <span class="keyword">uint32_t</span> hv) &#123;</span><br><span class="line">    item **pos;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> oldbucket;</span><br><span class="line">    <span class="comment">// 同理是确定是在old_hashtable 还是在primary_hashtable</span></span><br><span class="line">    <span class="keyword">if</span> (expanding &amp;&amp;</span><br><span class="line">        (oldbucket = (hv &amp; hashmask(hashpower - <span class="number">1</span>))) &gt;= expand_bucket)</span><br><span class="line">    &#123;</span><br><span class="line">        pos = &amp;old_hashtable[oldbucket];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        pos = &amp;primary_hashtable[hv &amp; hashmask(hashpower)];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 从头结点的位置开始顺序遍历单链表中的节点</span></span><br><span class="line">    <span class="keyword">while</span> (*pos &amp;&amp; ((nkey != (*pos)-&gt;nkey) || <span class="built_in">memcmp</span>(key, ITEM_key(*pos), nkey))) &#123;</span><br><span class="line">        pos = &amp;(*pos)-&gt;h_next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="assoc-expand"><a href="#assoc-expand" class="headerlink" title="assoc_expand"></a>assoc_expand</h3><p>函数的作用是执行hash表的扩容，执行的过程是将当前<strong>primary_hashtable</strong> 指定为<strong>old_hashtable</strong>, 为<strong>primary_hashtable</strong> 分配内存,<strong>primary_hashtable</strong>的大小是<strong>old_hashtable</strong> 的两倍，将标识是否在扩展的bool型变量 <strong>expanding</strong> 设置为true。将标识扩展进度的变量<strong>expand_bucket</strong>设置为0<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* grows the hashtable to the next power of 2. */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">assoc_expand</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    old_hashtable = primary_hashtable;</span><br><span class="line"></span><br><span class="line">    primary_hashtable = <span class="built_in">calloc</span>(hashsize(hashpower + <span class="number">1</span>), <span class="keyword">sizeof</span>(<span class="keyword">void</span> *));</span><br><span class="line">    <span class="keyword">if</span> (primary_hashtable) &#123;</span><br><span class="line">        <span class="keyword">if</span> (settings.verbose &gt; <span class="number">1</span>)</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Hash table expansion starting\n"</span>);</span><br><span class="line">        hashpower++;</span><br><span class="line">        expanding = <span class="literal">true</span>;</span><br><span class="line">        expand_bucket = <span class="number">0</span>;</span><br><span class="line">        STATS_LOCK();</span><br><span class="line">        stats_state.hash_power_level = hashpower;</span><br><span class="line">        stats_state.hash_bytes += hashsize(hashpower) * <span class="keyword">sizeof</span>(<span class="keyword">void</span> *);</span><br><span class="line">        stats_state.hash_is_expanding = <span class="literal">true</span>;</span><br><span class="line">        STATS_UNLOCK();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        primary_hashtable = old_hashtable;</span><br><span class="line">        <span class="comment">/* Bad news, but we can keep running. */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="assoc-start-expand"><a href="#assoc-start-expand" class="headerlink" title="assoc_start_expand"></a>assoc_start_expand</h3><p>函数的作用判断是否进行扩展，进行扩展的临界条件是hashtable 中item 个数大于hash 桶数的1.5倍。满足此临界条件时通知扩展线程进行扩展<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">assoc_start_expand</span><span class="params">(<span class="keyword">uint64_t</span> curr_items)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (started_expanding)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (curr_items &gt; (hashsize(hashpower) * <span class="number">3</span>) / <span class="number">2</span> &amp;&amp;</span><br><span class="line">          hashpower &lt; HASHPOWER_MAX) &#123;</span><br><span class="line">        started_expanding = <span class="literal">true</span>;</span><br><span class="line">        pthread_cond_signal(&amp;maintenance_cond);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="start-assoc-maintenance-thread"><a href="#start-assoc-maintenance-thread" class="headerlink" title="start_assoc_maintenance_thread"></a>start_assoc_maintenance_thread</h3><p>函数的作用是创建hash 扩展线程，可以根据用户指定的参数设置每次扩展多少个bucket。如果不指定此参数的话，默认每次只扩展一个bucket<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">start_assoc_maintenance_thread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="keyword">char</span> *env = getenv(<span class="string">"MEMCACHED_HASH_BULK_MOVE"</span>);</span><br><span class="line">    <span class="keyword">if</span> (env != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        hash_bulk_move = atoi(env);</span><br><span class="line">        <span class="keyword">if</span> (hash_bulk_move == <span class="number">0</span>) &#123;</span><br><span class="line">            hash_bulk_move = DEFAULT_HASH_BULK_MOVE;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_mutex_init(&amp;maintenance_lock, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> ((ret = pthread_create(&amp;maintenance_tid, <span class="literal">NULL</span>,</span><br><span class="line">                              assoc_maintenance_thread, <span class="literal">NULL</span>)) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Can't create thread: %s\n"</span>, strerror(ret));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="assoc-maintenance-thread"><a href="#assoc-maintenance-thread" class="headerlink" title="assoc_maintenance_thread"></a>assoc_maintenance_thread</h3><p>函数的作用是执行实际的bucket 扩展。具体解释见注释<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">assoc_maintenance_thread</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    mutex_lock(&amp;maintenance_lock);</span><br><span class="line">    <span class="keyword">while</span> (do_run_maintenance_thread) &#123;</span><br><span class="line">        <span class="keyword">int</span> ii = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* There is only one expansion thread, so no need to global lock. */</span></span><br><span class="line">        <span class="comment">// 循环每次扩展的全部bucket</span></span><br><span class="line">        <span class="keyword">for</span> (ii = <span class="number">0</span>; ii &lt; hash_bulk_move &amp;&amp; expanding; ++ii) &#123;</span><br><span class="line">            item *it, *next;</span><br><span class="line">            <span class="keyword">unsigned</span> <span class="keyword">int</span> bucket;</span><br><span class="line">            <span class="keyword">void</span> *item_lock = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* bucket = hv &amp; hashmask(hashpower) =&gt;the bucket of hash table</span></span><br><span class="line"><span class="comment">             * is the lowest N bits of the hv, and the bucket of item_locks is</span></span><br><span class="line"><span class="comment">             *  also the lowest M bits of hv, and N is greater than M.</span></span><br><span class="line"><span class="comment">             *  So we can process expanding with only one item_lock. cool! */</span></span><br><span class="line">            <span class="comment">/* expand_bucket需要锁保护,由于处于同一个bucket</span></span><br><span class="line"><span class="comment">             中的特性是这些item 的hv 的低N位是完全相同，对应的</span></span><br><span class="line"><span class="comment">             item_lock 的位置靠hv 的低M位确定，由于item_lock</span></span><br><span class="line"><span class="comment">             数组大小小于桶数组的大小，所以有 M &lt; N ,也就是说处</span></span><br><span class="line"><span class="comment">             于同一个桶中的item拥有相同item_lock,所以在遍历桶中</span></span><br><span class="line"><span class="comment">             所有的item 的时候不需要在额外获取item_lock。这里的</span></span><br><span class="line"><span class="comment">             设计非常精妙~ */</span></span><br><span class="line">            <span class="keyword">if</span> ((item_lock = item_trylock(expand_bucket))) &#123;</span><br><span class="line">                    <span class="comment">/* 遍历bucket 中全部item,插入到</span></span><br><span class="line"><span class="comment">                    primary_hashtable 中相应bucket */</span></span><br><span class="line">                    <span class="keyword">for</span> (it = old_hashtable[expand_bucket]; <span class="literal">NULL</span> != it; it = next) &#123;</span><br><span class="line">                        next = it-&gt;h_next;</span><br><span class="line">                        bucket = hash(ITEM_key(it), it-&gt;nkey) &amp; hashmask(hashpower);</span><br><span class="line">                        it-&gt;h_next = primary_hashtable[bucket];</span><br><span class="line">                        primary_hashtable[bucket] = it;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// old_hashtable 中bucket 内容设置为空</span></span><br><span class="line">                    old_hashtable[expand_bucket] = <span class="literal">NULL</span>;</span><br><span class="line">                    <span class="comment">// 维护当前扩展的进度</span></span><br><span class="line">                    expand_bucket++;</span><br><span class="line">                    <span class="comment">/* 如果扩展已经全部完成则设置expanding为</span></span><br><span class="line"><span class="comment">                    false ,释放old_hashtable 的内存*/</span></span><br><span class="line">                    <span class="keyword">if</span> (expand_bucket == hashsize(hashpower - <span class="number">1</span>)) &#123;</span><br><span class="line">                        expanding = <span class="literal">false</span>;</span><br><span class="line">                        <span class="built_in">free</span>(old_hashtable);</span><br><span class="line">                        STATS_LOCK();</span><br><span class="line">                        stats_state.hash_bytes -= hashsize(hashpower - <span class="number">1</span>) * <span class="keyword">sizeof</span>(<span class="keyword">void</span> *);</span><br><span class="line">                        stats_state.hash_is_expanding = <span class="literal">false</span>;</span><br><span class="line">                        STATS_UNLOCK();</span><br><span class="line">                        <span class="keyword">if</span> (settings.verbose &gt; <span class="number">1</span>)</span><br><span class="line">                            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Hash table expansion done\n"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                usleep(<span class="number">10</span>*<span class="number">1000</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 释放资源</span></span><br><span class="line">            <span class="keyword">if</span> (item_lock) &#123;</span><br><span class="line">                item_trylock_unlock(item_lock);</span><br><span class="line">                item_lock = <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果不在进行扩展，则设置条件变量，等待被触发扩展</span></span><br><span class="line">        <span class="keyword">if</span> (!expanding) &#123;</span><br><span class="line">            <span class="comment">/* We are done expanding.. just wait for next invocation */</span></span><br><span class="line">            started_expanding = <span class="literal">false</span>;</span><br><span class="line">            pthread_cond_wait(&amp;maintenance_cond, &amp;maintenance_lock);</span><br><span class="line">            <span class="comment">/* assoc_expand() swaps out the hash table entirely, so we need</span></span><br><span class="line"><span class="comment">             * all threads to not hold any references related to the hash</span></span><br><span class="line"><span class="comment">             * table while this happens.</span></span><br><span class="line"><span class="comment">             * This is instead of a more complex, possibly slower algorithm to</span></span><br><span class="line"><span class="comment">             * allow dynamic hash table expansion without causing significant</span></span><br><span class="line"><span class="comment">             * wait times.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            pause_threads(PAUSE_ALL_THREADS);</span><br><span class="line">            assoc_expand();</span><br><span class="line">            pause_threads(RESUME_ALL_THREADS);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h1><p>memcached 使用分段锁实现hashtable 线程安全，分段锁避免了hashtable 中全部的item公用一个锁，公用一个锁的会降低hashtable 的读写性能。下面部分代码是memcached 初始化分段锁数组的逻辑。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (nthreads &lt; <span class="number">3</span>) &#123;</span><br><span class="line">    power = <span class="number">10</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (nthreads &lt; <span class="number">4</span>) &#123;</span><br><span class="line">    power = <span class="number">11</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (nthreads &lt; <span class="number">5</span>) &#123;</span><br><span class="line">    power = <span class="number">12</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (nthreads &lt;= <span class="number">10</span>) &#123;</span><br><span class="line">    power = <span class="number">13</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (nthreads &lt;= <span class="number">20</span>) &#123;</span><br><span class="line">    power = <span class="number">14</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">/* 32k buckets. just under the hashpower default. */</span></span><br><span class="line">    power = <span class="number">15</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 保证分段锁的数目小于hashtable 桶的个数，这样设计的好处之一</span></span><br><span class="line"><span class="comment">是在扩展的时候针对一个桶中的所有item 对应的是同一个</span></span><br><span class="line"><span class="comment">item_lock*/</span></span><br><span class="line"><span class="keyword">if</span> (power &gt;= hashpower) &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Hash table power size (%d) cannot be equal to or less than item lock table (%d)\n"</span>, hashpower, power);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Item lock table grows with `-t N` (worker threadcount)\n"</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Hash table grows with `-o hashpower=N` \n"</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">item_lock_count = hashsize(power);</span><br><span class="line">item_lock_hashpower = power;</span><br><span class="line"><span class="comment">// 分配分段锁数组</span></span><br><span class="line">item_locks = <span class="built_in">calloc</span>(item_lock_count, <span class="keyword">sizeof</span>(<span class="keyword">pthread_mutex_t</span>));</span><br><span class="line"><span class="keyword">if</span> (! item_locks) &#123;</span><br><span class="line">    perror(<span class="string">"Can't allocate item locks"</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在对hashtable 进行多线程读写时，首先需要根据hash 算法计算出hv 值，然后根据hv 获取item_lock,获取到item_lock 之后再进行读写操作。这也从侧面解释了为什么memcached在扩展时默认每次只扩展一个bucket，因为在进行扩展的时候需要占有item_lock，每次执行扩展的bucket 数多会影响读写性能。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>memcached 的hashtable是典型的拉链式hashtable,实现代码短小易读，使用一个线程进行hashtable的扩展以保证不会出现item增多导致哈希冲突激增降低读写性能的现象，除此之外使用分段锁来保证多线程的读写安全，相比全局锁也可以提升读写性能。memcached hashsize设置为2的整数次幂的设计非常精妙，首先这样可以将查找hash bucket索引的取余操作转化为对（hashsize-1）取按位与操作，在加上分段锁的数目大小小于hashsize 的设置可以保证一个bucket 中所有的item 对应于同一个分段锁，进而保证在扩展bucket中全部内容时只需要获取一次分段锁!</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/3/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/5/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.png"
                alt="carbo06@163.com" />
            
              <p class="site-author-name" itemprop="name">carbo06@163.com</p>
              <p class="site-description motion-element" itemprop="description">About Linux C++ and routing algorithms.</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">45</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">5</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">18</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/ce39906" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:ce39906@163.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-block">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                Friends
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="https://lambdae.github.io/" title="DingliYang" target="_blank">DingliYang</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://zsirkg.github.io/" title="SongZhang" target="_blank">SongZhang</a>
                  </li>
                
              </ul>
            </div>
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">carbo06@163.com</span>

  
</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
          <span id="scrollpercent"><span>0</span>%</span>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  







<!-- LOCAL: You can save these files to your site and update links -->
    
        
        <link rel="stylesheet" href="https://aimingoo.github.io/gitmint/style/default.css">
        <script src="https://aimingoo.github.io/gitmint/dist/gitmint.browser.js"></script>
    
<!-- END LOCAL -->

    
      <style>
        a.gitment-editor-footer-tip { display: none; }
        .gitment-container.gitment-footer-container { display: none; }
      </style>
    

    







  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

<script type="text/javascript" src="/live2d/script.js"></script>
<canvas id="live2dcanvas" width="300" height="400" class="live2d"></canvas>
<style>
  #live2dcanvas {
    position: fixed;
    left: 0px;
    z-index: 999;
    pointer-events: none;
    bottom: -50px;
  }
</style>
<script>loadlive2d("live2dcanvas"
,"/live2d/models/tororo.model.json",0.5)</script><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config("");
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="custom_mathjax_source">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->

</body>
</html>
